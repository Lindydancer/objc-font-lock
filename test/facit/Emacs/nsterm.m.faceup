«m:/* »«x:From "Emacs". Unicode dash replaced with "-", as it doesn't work
 * well with "faceup". See MODIFIED in code below. */»
«m:/* »«x:NeXT/Open/GNUstep / MacOSX communication module.

Copyright (C) 1989, 1993-1994, 2005-2006, 2008-2014 Free Software
Foundation, Inc.

This file is part of GNU Emacs.

GNU Emacs is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU Emacs is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.  */»

«m:/*»«x:
Originally by Carl Edman
Updated by Christian Limpach (chris@nice.ch)
OpenStep/Rhapsody port by Scott Bender (sbender@harmony-ds.com)
MacOSX/Aqua port by Christophe de Dinechin (descubes@earthlink.net)
GNUstep port and post-20 update by Adrian Robert (arobert@cogsci.ucsd.edu)
*/»

«m:/* »«x:This should be the first include, as it may set up #defines affecting
   interpretation of even the system includes. */»
«p:#include» «s:<config.h>»

«p:#include» «s:<fcntl.h>»
«p:#include» «s:<math.h>»
«p:#include» «s:<pthread.h>»
«p:#include» «s:<sys/types.h>»
«p:#include» «s:<time.h>»
«p:#include» «s:<signal.h>»
«p:#include» «s:<unistd.h>»

«p:#include» «s:<c-ctype.h>»
«p:#include» «s:<c-strcase.h>»
«p:#include» «s:<ftoastr.h>»

«p:#include» «s:"lisp.h"»
«p:#include» «s:"blockinput.h"»
«p:#include» «s:"sysselect.h"»
«p:#include» «s:"nsterm.h"»
«p:#include» «s:"systime.h"»
«p:#include» «s:"character.h"»
«p:#include» «s:"fontset.h"»
«p:#include» «s:"composite.h"»
«p:#include» «s:"ccl.h"»

«p:#include» «s:"termhooks.h"»
«p:#include» «s:"termchar.h"»

«p:#include» «s:"window.h"»
«p:#include» «s:"keyboard.h"»
«p:#include» «s:"buffer.h"»
«p:#include» «s:"font.h"»

«p:#ifdef» NS_IMPL_GNUSTEP
«p:#include» «s:"process.h"»
«p:#endif»

«p:#ifdef» NS_IMPL_COCOA
«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
«p:#include» «s:"macfont.h"»
«p:#endif»
«p:#endif»

«m:/* »«x:call tracing */»
«p:#if» 0
«t:int» «v:term_trace_num» = 0;
«p:#define» «f:NSTRACE»(«v:x»)        fprintf (stderr, «s:"%s:%d: [%d] "» #x «s:"\n"»,         \
                                __FILE__, __LINE__, ++term_trace_num)
«p:#else»
«p:#define» «f:NSTRACE»(«v:x»)
«p:#endif»

«m:/* »«x:Detailed tracing. "S" means "size" and "LL" stands for "lower left". */»
«p:#if» 0
«t:int» «v:term_trace_num» = 0;
«p:#define» «f:NSTRACE_SIZE»(«v:str»,«v:size») fprintf (stderr,                         \
                                   «s:"%s:%d: [%d]   "» str                 \
                                   «s:" (S:%.0f x %.0f)\n"», \
                                   __FILE__, __LINE__, ++term_trace_num,\
                                   size.height,                       \
                                   size.width)
«p:#define» «f:NSTRACE_RECT»(«v:s»,«v:r») fprintf (stderr,                              \
                                   «s:"%s:%d: [%d]   "» s                   \
                                   «s:" (LL:%.0f x %.0f -> S:%.0f x %.0f)\n"», \
                                   __FILE__, __LINE__, ++term_trace_num,\
                                   r.origin.x,                          \
                                   r.origin.y,                          \
                                   r.size.height,                       \
                                   r.size.width)
«p:#else»
«p:#define» «f:NSTRACE_SIZE»(«v:str»,«v:size»)
«p:#define» «f:NSTRACE_RECT»(«v:s»,«v:r»)
«p:#endif»

«k:extern» «t:NSString» *«v:NSMenuDidBeginTrackingNotification»;

«m:/* »«x:==========================================================================

   NSColor, EmacsColor category.

   ========================================================================== */»
«k:@implementation» «t:NSColor» («t:EmacsColor»)
+ («t:NSColor» *)«f:colorForEmacsRed»:(«t:CGFloat»)«v:red» «f:green»:(«t:CGFloat»)«v:green»
                         «f:blue»:(«t:CGFloat»)«v:blue» «f:alpha»:(«t:CGFloat»)«v:alpha»
{
«p:#ifdef» NS_IMPL_COCOA
«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
  «k:if» (ns_use_srgb_colorspace)
      «k:return» «:objc-font-lock-background-face:«w:[»«t:NSColor» «f:colorWithSRGBRed»: red»
                                 «:objc-font-lock-background-face:«f:green»: green»
                                  «:objc-font-lock-background-face:«f:blue»: blue»
                                 «:objc-font-lock-background-face:«f:alpha»: alpha«w:]»»;
«p:#endif»
«p:#endif»
  «k:return» «:objc-font-lock-background-face:«w:[»«t:NSColor» «f:colorWithCalibratedRed»: red»
                                   «:objc-font-lock-background-face:«f:green»: green»
                                    «:objc-font-lock-background-face:«f:blue»: blue»
                                   «:objc-font-lock-background-face:«f:alpha»: alpha«w:]»»;
}

- («t:NSColor» *)«f:colorUsingDefaultColorSpace»
{
«p:#ifdef» NS_IMPL_COCOA
«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
  «k:if» (ns_use_srgb_colorspace)
    «k:return» «:objc-font-lock-background-face:«w:[»«k:self» «f:colorUsingColorSpace»: «:objc-font-lock-background-face:«w:[»«t:NSColorSpace» «f:sRGBColorSpace»«w:]»»«w:]»»;
«p:#endif»
«p:#endif»
  «k:return» «:objc-font-lock-background-face:«w:[»«k:self» «f:colorUsingColorSpaceName»: NSCalibratedRGBColorSpace«w:]»»;
}

«k:@end»

«m:/* »«x:==========================================================================

    Local declarations

   ========================================================================== */»

«m:/* »«x:Convert a symbol indexed with an NSxxx value to a value as defined
   in keyboard.c (lispy_function_key). I hope this is a correct way
   of doing things... */»
«k:static» «t:unsigned» «v:convert_ns_to_X_keysym»[] =
{
  NSHomeFunctionKey,            0x50,
  NSLeftArrowFunctionKey,       0x51,
  NSUpArrowFunctionKey,         0x52,
  NSRightArrowFunctionKey,      0x53,
  NSDownArrowFunctionKey,       0x54,
  NSPageUpFunctionKey,          0x55,
  NSPageDownFunctionKey,        0x56,
  NSEndFunctionKey,             0x57,
  NSBeginFunctionKey,           0x58,
  NSSelectFunctionKey,          0x60,
  NSPrintFunctionKey,           0x61,
  NSClearLineFunctionKey,       0x0B,
  NSExecuteFunctionKey,         0x62,
  NSInsertFunctionKey,          0x63,
  NSUndoFunctionKey,            0x65,
  NSRedoFunctionKey,            0x66,
  NSMenuFunctionKey,            0x67,
  NSFindFunctionKey,            0x68,
  NSHelpFunctionKey,            0x6A,
  NSBreakFunctionKey,           0x6B,

  NSF1FunctionKey,              0xBE,
  NSF2FunctionKey,              0xBF,
  NSF3FunctionKey,              0xC0,
  NSF4FunctionKey,              0xC1,
  NSF5FunctionKey,              0xC2,
  NSF6FunctionKey,              0xC3,
  NSF7FunctionKey,              0xC4,
  NSF8FunctionKey,              0xC5,
  NSF9FunctionKey,              0xC6,
  NSF10FunctionKey,             0xC7,
  NSF11FunctionKey,             0xC8,
  NSF12FunctionKey,             0xC9,
  NSF13FunctionKey,             0xCA,
  NSF14FunctionKey,             0xCB,
  NSF15FunctionKey,             0xCC,
  NSF16FunctionKey,             0xCD,
  NSF17FunctionKey,             0xCE,
  NSF18FunctionKey,             0xCF,
  NSF19FunctionKey,             0xD0,
  NSF20FunctionKey,             0xD1,
  NSF21FunctionKey,             0xD2,
  NSF22FunctionKey,             0xD3,
  NSF23FunctionKey,             0xD4,
  NSF24FunctionKey,             0xD5,

  NSBackspaceCharacter,         0x08,  «m:/* »«x:8: Not on some KBs. */»
  NSDeleteCharacter,            0xFF,  «m:/* »«x:127: Big 'delete' key upper right. */»
  NSDeleteFunctionKey,          0x9F,  «m:/* »«x:63272: Del forw key off main array. */»

  NSTabCharacter,		0x09,
  0x19,				0x09,  «m:/* »«x:left tab->regular since pass shift */»
  NSCarriageReturnCharacter,	0x0D,
  NSNewlineCharacter,		0x0D,
  NSEnterCharacter,		0x8D,

  0x41|NSNumericPadKeyMask,	0xAE,  «m:/* »«x:KP_Decimal */»
  0x43|NSNumericPadKeyMask,	0xAA,  «m:/* »«x:KP_Multiply */»
  0x45|NSNumericPadKeyMask,	0xAB,  «m:/* »«x:KP_Add */»
  0x4B|NSNumericPadKeyMask,	0xAF,  «m:/* »«x:KP_Divide */»
  0x4E|NSNumericPadKeyMask,	0xAD,  «m:/* »«x:KP_Subtract */»
  0x51|NSNumericPadKeyMask,	0xBD,  «m:/* »«x:KP_Equal */»
  0x52|NSNumericPadKeyMask,	0xB0,  «m:/* »«x:KP_0 */»
  0x53|NSNumericPadKeyMask,	0xB1,  «m:/* »«x:KP_1 */»
  0x54|NSNumericPadKeyMask,	0xB2,  «m:/* »«x:KP_2 */»
  0x55|NSNumericPadKeyMask,	0xB3,  «m:/* »«x:KP_3 */»
  0x56|NSNumericPadKeyMask,	0xB4,  «m:/* »«x:KP_4 */»
  0x57|NSNumericPadKeyMask,	0xB5,  «m:/* »«x:KP_5 */»
  0x58|NSNumericPadKeyMask,	0xB6,  «m:/* »«x:KP_6 */»
  0x59|NSNumericPadKeyMask,	0xB7,  «m:/* »«x:KP_7 */»
  0x5B|NSNumericPadKeyMask,	0xB8,  «m:/* »«x:KP_8 */»
  0x5C|NSNumericPadKeyMask,	0xB9,  «m:/* »«x:KP_9 */»

  0x1B,				0x1B   «m:/* »«x:escape */»
};

«k:static» «t:Lisp_Object» «v:Qmodifier_value»;
«t:Lisp_Object» «v:Qalt», «v:Qcontrol», «v:Qhyper», «v:Qmeta», «v:Qsuper»;
«k:extern» «t:Lisp_Object» «v:Qcursor_color», «v:Qcursor_type», «v:Qns», «v:Qleft»;

«k:static» «t:Lisp_Object» «v:QUTF8_STRING»;
«k:static» «t:Lisp_Object» «v:Qcocoa», «v:Qgnustep»;
«k:static» «t:Lisp_Object» «v:Qfile», «v:Qurl»;

«m:/* »«x:On OS X picks up the default NSGlobalDomain AppleAntiAliasingThreshold,
   the maximum font size to NOT antialias.  On GNUstep there is currently
   no way to control this behavior. */»
«t:float» «v:ns_antialias_threshold»;

«t:NSArray» *«v:ns_send_types» =0, *«v:ns_return_types» =0, *«v:ns_drag_types» =0;
«t:NSString» *«v:ns_app_name» = @«s:"Emacs"»;  «m:/* »«x:default changed later */»

«m:/* »«x:Display variables */»
«k:struct» «t:ns_display_info» *«t:x_display_list»; «m:/* »«x:Chain of existing displays */»
«t:long» «v:context_menu_value» = 0;

«m:/* »«x:display update */»
«k:static» «k:struct» «t:frame» *«t:ns_updating_frame»;
«k:static» «t:NSView» *«v:focus_view» = NULL;
«k:static» «t:int» «v:ns_window_num» = 0;
«p:#ifdef» NS_IMPL_GNUSTEP
«k:static» «t:NSRect» «v:uRect»;
«p:#endif»
«k:static» «t:BOOL» «v:gsaved» = «c:NO»;
«k:static» «t:BOOL» «v:ns_fake_keydown» = «c:NO»;
«p:#ifdef» NS_IMPL_COCOA
«k:static» «t:BOOL» «v:ns_menu_bar_is_hidden» = «c:NO»;
«p:#endif»
«m:/*»«x:static int debug_lock = 0; */»

«m:/* »«x:event loop */»
«k:static» «t:BOOL» «v:send_appdefined» = «c:YES»;
«p:#define» «v:NO_APPDEFINED_DATA» (-8)
«k:static» «t:int» «v:last_appdefined_event_data» = NO_APPDEFINED_DATA;
«k:static» «t:NSTimer» *«v:timed_entry» = 0;
«k:static» «t:NSTimer» *«v:scroll_repeat_entry» = «c:nil»;
«k:static» «t:fd_set» «v:select_readfds», «v:select_writefds»;
«k:enum» { «v:SELECT_HAVE_READ» = 1, «v:SELECT_HAVE_WRITE» = 2, «v:SELECT_HAVE_TMO» = 4 };
«k:static» «t:int» «v:select_nfds» = 0, «v:select_valid» = 0;
«k:static» «k:struct» «t:timespec» «t:select_timeout» = { 0, 0 };
«k:static» «t:int» «v:selfds»[2] = { -1, -1 };
«k:static» «t:pthread_mutex_t» «v:select_mutex»;
«k:static» «t:int» «v:apploopnr» = 0;
«k:static» «t:NSAutoreleasePool» *«v:outerpool»;
«k:static» «k:struct» «t:input_event» *«t:emacs_event» = NULL;
«k:static» «k:struct» «t:input_event» *«t:q_event_ptr» = NULL;
«k:static» «t:int» «v:n_emacs_events_pending» = 0;
«k:static» «t:NSMutableArray» *«v:ns_pending_files», *«v:ns_pending_service_names»,
  *«v:ns_pending_service_args»;
«k:static» «t:BOOL» «v:ns_do_open_file» = «c:NO»;
«k:static» «t:BOOL» «v:ns_last_use_native_fullscreen»;

«k:static» «k:struct» {
  «k:struct» «t:input_event» *«t:q»;
  «t:int» «v:nr», «v:cap»;
} hold_event_q = {
  NULL, 0, 0
};

«p:#ifdef» NS_IMPL_COCOA
«m:/*»«x:
 * State for pending menu activation:
 * MENU_NONE     Normal state
 * MENU_PENDING  A menu has been clicked on, but has been canceled so we can
 *               run lisp to update the menu.
 * MENU_OPENING  Menu is up to date, and the click event is redone so the menu
 *               will open.
 */»
«p:#define» «v:MENU_NONE» 0
«p:#define» «v:MENU_PENDING» 1
«p:#define» «v:MENU_OPENING» 2
«k:static» «t:int» «v:menu_will_open_state» = MENU_NONE;

«m:/* »«x:Saved position for menu click.  */»
«k:static» «t:CGPoint» «v:menu_mouse_point»;
«p:#endif»

«m:/* »«x:Convert modifiers in a NeXTstep event to emacs style modifiers.  */»
«p:#define» «v:NS_FUNCTION_KEY_MASK» 0x800000
«p:#define» «v:NSLeftControlKeyMask»    (0x000001 | NSControlKeyMask)
«p:#define» «v:NSRightControlKeyMask»   (0x002000 | NSControlKeyMask)
«p:#define» «v:NSLeftCommandKeyMask»    (0x000008 | NSCommandKeyMask)
«p:#define» «v:NSRightCommandKeyMask»   (0x000010 | NSCommandKeyMask)
«p:#define» «v:NSLeftAlternateKeyMask»  (0x000020 | NSAlternateKeyMask)
«p:#define» «v:NSRightAlternateKeyMask» (0x000040 | NSAlternateKeyMask)
«p:#define» «f:EV_MODIFIERS2»(«v:flags»)                          \
    (((flags & NSHelpKeyMask) ?           \
           hyper_modifier : 0)                        \
     | («n:!»EQ (ns_right_alternate_modifier, Qleft) && \
        ((flags & NSRightAlternateKeyMask) \
         == NSRightAlternateKeyMask) ? \
           parse_solitary_modifier (ns_right_alternate_modifier) : 0) \
     | ((flags & NSAlternateKeyMask) ?                 \
           parse_solitary_modifier (ns_alternate_modifier) : 0)   \
     | ((flags & NSShiftKeyMask) ?     \
           shift_modifier : 0)                        \
     | («n:!»EQ (ns_right_control_modifier, Qleft) && \
        ((flags & NSRightControlKeyMask) \
         == NSRightControlKeyMask) ? \
           parse_solitary_modifier (ns_right_control_modifier) : 0) \
     | ((flags & NSControlKeyMask) ?      \
           parse_solitary_modifier (ns_control_modifier) : 0)     \
     | ((flags & NS_FUNCTION_KEY_MASK) ?  \
           parse_solitary_modifier (ns_function_modifier) : 0)    \
     | («n:!»EQ (ns_right_command_modifier, Qleft) && \
        ((flags & NSRightCommandKeyMask) \
         == NSRightCommandKeyMask) ? \
           parse_solitary_modifier (ns_right_command_modifier) : 0) \
     | ((flags & NSCommandKeyMask) ?      \
           parse_solitary_modifier (ns_command_modifier):0))
«p:#define» «f:EV_MODIFIERS»(«v:e») EV_MODIFIERS2 («:objc-font-lock-background-face:«w:[»e «f:modifierFlags»«w:]»»)

«p:#define» «f:EV_UDMODIFIERS»(«v:e»)                                      \
    (((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSLeftMouseDown) ? down_modifier : 0)       \
     | ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSRightMouseDown) ? down_modifier : 0)    \
     | ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSOtherMouseDown) ? down_modifier : 0)    \
     | ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSLeftMouseDragged) ? down_modifier : 0)  \
     | ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSRightMouseDragged) ? down_modifier : 0) \
     | ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSOtherMouseDragged) ? down_modifier : 0) \
     | ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSLeftMouseUp)   ? up_modifier   : 0)     \
     | ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSRightMouseUp)   ? up_modifier   : 0)    \
     | ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSOtherMouseUp)   ? up_modifier   : 0))

«p:#define» «f:EV_BUTTON»(«v:e»)                                                         \
    (((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSLeftMouseDown) || («:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSLeftMouseUp)) ? 0 :    \
      ((«:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSRightMouseDown) || («:objc-font-lock-background-face:«w:[»e «f:type»«w:]»» == NSRightMouseUp)) ? 2 : \
     «:objc-font-lock-background-face:«w:[»e «f:buttonNumber»«w:]»» - 1)

«m:/* »«x:Convert the time field to a timestamp in milliseconds. */»
«p:#define» «f:EV_TIMESTAMP»(«v:e») («:objc-font-lock-background-face:«w:[»e «f:timestamp»«w:]»» * 1000)

«m:/* »«x:This is a piece of code which is common to all the event handling
   methods.  Maybe it should even be a function.  */»
«p:#define» «f:EV_TRAILER»(«v:e»)                                                   \
  {                                                                     \
    XSETFRAME (emacs_event->frame_or_window, emacsframe);               \
    EV_TRAILER2 (e);                                                    \
  }

«p:#define» «f:EV_TRAILER2»(«v:e»)                                                  \
  {                                                                     \
      «k:if» (e) emacs_event->timestamp = EV_TIMESTAMP (e);                 \
      «k:if» (q_event_ptr)                                                  \
        {                                                               \
          n_emacs_events_pending++;                                     \
          kbd_buffer_store_event_hold (emacs_event, q_event_ptr);       \
        }                                                               \
      «k:else»                                                              \
        hold_event (emacs_event);                                       \
      EVENT_INIT (*emacs_event);                                        \
      ns_send_appdefined (-1);                                          \
    }

«m:/* »«x:TODO: get rid of need for these forward declarations */»
«k:static» «t:void» «f:ns_condemn_scroll_bars» («k:struct» «t:frame» *«t:f»);
«k:static» «t:void» «f:ns_judge_scroll_bars» («k:struct» «t:frame» *«t:f»);
«t:void» «f:x_set_frame_alpha» («k:struct» «t:frame» *«t:f»);


«m:/* »«x:==========================================================================

    Utilities

   ========================================================================== */»

«k:static» «t:void»
«f:hold_event» («k:struct» «t:input_event» *«t:event»)
{
  «k:if» (hold_event_q.nr == hold_event_q.cap)
    {
      «k:if» (hold_event_q.cap == 0) hold_event_q.cap = 10;
      «k:else» hold_event_q.cap *= 2;
      hold_event_q.q =
        xrealloc (hold_event_q.q, hold_event_q.cap * sizeof *hold_event_q.q);
    }

  hold_event_q.q[hold_event_q.nr++] = *event;
  «m:/* »«x:Make sure ns_read_socket is called, i.e. we have input.  */»
  raise (SIGIO);
  send_appdefined = «c:YES»;
}

«k:static» «t:Lisp_Object»
«f:append2» («t:Lisp_Object» «v:list», «t:Lisp_Object» «v:item»)
«m:/* »«x:--------------------------------------------------------------------------
   Utility to append to a list
   -------------------------------------------------------------------------- */»
{
  «t:Lisp_Object» «v:array»[2];
  array[0] = list;
  array[1] = list1 (item);
  «k:return» Fnconc (2, &array[0]);
}


«k:const» «t:char» *
«f:ns_etc_directory» («t:void»)
«m:/* »«x:If running as a self-contained app bundle, return as a string the
   filename of the etc directory, if present; else nil.  */»
{
  «t:NSBundle» *«v:bundle» = «:objc-font-lock-background-face:«w:[»«t:NSBundle» «f:mainBundle»«w:]»»;
  «t:NSString» *«v:resourceDir» = «:objc-font-lock-background-face:«w:[»bundle «f:resourcePath»«w:]»»;
  «t:NSString» *«v:resourcePath»;
  «t:NSFileManager» *«v:fileManager» = «:objc-font-lock-background-face:«w:[»«t:NSFileManager» «f:defaultManager»«w:]»»;
  «t:BOOL» «v:isDir»;

  resourcePath = «:objc-font-lock-background-face:«w:[»resourceDir «f:stringByAppendingPathComponent»: @«s:"etc"»«w:]»»;
  «k:if» («:objc-font-lock-background-face:«w:[»fileManager «f:fileExistsAtPath»: resourcePath «f:isDirectory»: &isDir«w:]»»)
    {
      «k:if» (isDir) «k:return» «:objc-font-lock-background-face:«w:[»resourcePath «f:UTF8String»«w:]»»;
    }
  «k:return» NULL;
}


«k:const» «t:char» *
«f:ns_exec_path» («t:void»)
«m:/* »«x:If running as a self-contained app bundle, return as a path string
   the filenames of the libexec and bin directories, ie libexec:bin.
   Otherwise, return nil.
   Normally, Emacs does not add its own bin/ directory to the PATH.
   However, a self-contained NS build has a different layout, with
   bin/ and libexec/ subdirectories in the directory that contains
   Emacs.app itself.
   We put libexec first, because init_callproc_1 uses the first
   element to initialize exec-directory.  An alternative would be
   for init_callproc to check for invocation-directory/libexec.
*/»
{
  «t:NSBundle» *«v:bundle» = «:objc-font-lock-background-face:«w:[»«t:NSBundle» «f:mainBundle»«w:]»»;
  «t:NSString» *«v:resourceDir» = «:objc-font-lock-background-face:«w:[»bundle «f:resourcePath»«w:]»»;
  «t:NSString» *«v:binDir» = «:objc-font-lock-background-face:«w:[»bundle «f:bundlePath»«w:]»»;
  «t:NSString» *«v:resourcePath», *«v:resourcePaths»;
  «t:NSRange» «v:range»;
  «t:NSString» *«v:pathSeparator» = «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithFormat»: @«s:"%c"», SEPCHAR«w:]»»;
  «t:NSFileManager» *«v:fileManager» = «:objc-font-lock-background-face:«w:[»«t:NSFileManager» «f:defaultManager»«w:]»»;
  «t:NSArray» *«v:paths»;
  «t:NSEnumerator» *«v:pathEnum»;
  «t:BOOL» «v:isDir»;

  range = «:objc-font-lock-background-face:«w:[»resourceDir «f:rangeOfString»: @«s:"Contents"»«w:]»»;
  «k:if» (range.location != NSNotFound)
    {
      binDir = «:objc-font-lock-background-face:«w:[»binDir «f:stringByAppendingPathComponent»: @«s:"Contents"»«w:]»»;
«p:#ifdef» NS_IMPL_COCOA
      binDir = «:objc-font-lock-background-face:«w:[»binDir «f:stringByAppendingPathComponent»: @«s:"MacOS"»«w:]»»;
«p:#endif»
    }

  paths = «:objc-font-lock-background-face:«w:[»binDir «f:stringsByAppendingPaths»:»
                «:objc-font-lock-background-face:«:objc-font-lock-background-face:«w:[»«t:NSArray» «f:arrayWithObjects»: @«s:"libexec"», @«s:"bin"», «c:nil»«w:]»»«w:]»»;
  pathEnum = «:objc-font-lock-background-face:«w:[»paths «f:objectEnumerator»«w:]»»;
  resourcePaths = @«s:""»;

  «k:while» ((resourcePath = «:objc-font-lock-background-face:«w:[»pathEnum «f:nextObject»«w:]»»))
    {
      «k:if» («:objc-font-lock-background-face:«w:[»fileManager «f:fileExistsAtPath»: resourcePath «f:isDirectory»: &isDir«w:]»»)
        «k:if» (isDir)
          {
            «k:if» («:objc-font-lock-background-face:«w:[»resourcePaths «f:length»«w:]»» > 0)
              resourcePaths
                = «:objc-font-lock-background-face:«w:[»resourcePaths «f:stringByAppendingString»: pathSeparator«w:]»»;
            resourcePaths
              = «:objc-font-lock-background-face:«w:[»resourcePaths «f:stringByAppendingString»: resourcePath«w:]»»;
          }
    }
  «k:if» («:objc-font-lock-background-face:«w:[»resourcePaths «f:length»«w:]»» > 0) «k:return» «:objc-font-lock-background-face:«w:[»resourcePaths «f:UTF8String»«w:]»»;

  «k:return» NULL;
}


«k:const» «t:char» *
«f:ns_load_path» («t:void»)
«m:/* »«x:If running as a self-contained app bundle, return as a path string
   the filenames of the site-lisp and lisp directories.
   Ie, site-lisp:lisp.  Otherwise, return nil.  */»
{
  «t:NSBundle» *«v:bundle» = «:objc-font-lock-background-face:«w:[»«t:NSBundle» «f:mainBundle»«w:]»»;
  «t:NSString» *«v:resourceDir» = «:objc-font-lock-background-face:«w:[»bundle «f:resourcePath»«w:]»»;
  «t:NSString» *«v:resourcePath», *«v:resourcePaths»;
  «t:NSString» *«v:pathSeparator» = «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithFormat»: @«s:"%c"», SEPCHAR«w:]»»;
  «t:NSFileManager» *«v:fileManager» = «:objc-font-lock-background-face:«w:[»«t:NSFileManager» «f:defaultManager»«w:]»»;
  «t:BOOL» «v:isDir»;
  «t:NSArray» *«v:paths» = «:objc-font-lock-background-face:«w:[»resourceDir «f:stringsByAppendingPaths»:»
                              «:objc-font-lock-background-face:«:objc-font-lock-background-face:«w:[»«t:NSArray» «f:arrayWithObjects»:»»
                                         «:objc-font-lock-background-face:«:objc-font-lock-background-face:@«s:"site-lisp"», @«s:"lisp"», «c:nil»«w:]»»«w:]»»;
  «t:NSEnumerator» *«v:pathEnum» = «:objc-font-lock-background-face:«w:[»paths «f:objectEnumerator»«w:]»»;
  resourcePaths = @«s:""»;

  «m:/* »«x:Hack to skip site-lisp.  */»
  «k:if» (no_site_lisp) resourcePath = «:objc-font-lock-background-face:«w:[»pathEnum «f:nextObject»«w:]»»;

  «k:while» ((resourcePath = «:objc-font-lock-background-face:«w:[»pathEnum «f:nextObject»«w:]»»))
    {
      «k:if» («:objc-font-lock-background-face:«w:[»fileManager «f:fileExistsAtPath»: resourcePath «f:isDirectory»: &isDir«w:]»»)
        «k:if» (isDir)
          {
            «k:if» («:objc-font-lock-background-face:«w:[»resourcePaths «f:length»«w:]»» > 0)
              resourcePaths
                = «:objc-font-lock-background-face:«w:[»resourcePaths «f:stringByAppendingString»: pathSeparator«w:]»»;
            resourcePaths
              = «:objc-font-lock-background-face:«w:[»resourcePaths «f:stringByAppendingString»: resourcePath«w:]»»;
          }
    }
  «k:if» («:objc-font-lock-background-face:«w:[»resourcePaths «f:length»«w:]»» > 0) «k:return» «:objc-font-lock-background-face:«w:[»resourcePaths «f:UTF8String»«w:]»»;

  «k:return» NULL;
}

«k:static» «t:void»
«f:ns_timeout» («t:int» «v:usecs»)
«m:/* »«x:--------------------------------------------------------------------------
     Blocking timer utility used by ns_ring_bell
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:timespec» «t:wakeup» = timespec_add (current_timespec (),
					 make_timespec (0, usecs * 1000));

  «m:/* »«x:Keep waiting until past the time wakeup.  */»
  «k:while» (1)
    {
      «k:struct» «t:timespec» «t:timeout», «t:now» = current_timespec ();
      «k:if» (timespec_cmp (wakeup, now) <= 0)
	«k:break»;
      timeout = timespec_sub (wakeup, now);

      «m:/* »«x:Try to wait that long--but we might wake up sooner.  */»
      pselect (0, NULL, NULL, NULL, &timeout, NULL);
    }
}


«t:void»
«f:ns_release_object» («t:void» *«v:obj»)
«m:/* »«x:--------------------------------------------------------------------------
    Release an object (callable from C)
   -------------------------------------------------------------------------- */»
{
    «:objc-font-lock-background-face:«w:[»(«t:id»)«t:obj» «f:release»«w:]»»;
}


«t:void»
«f:ns_retain_object» («t:void» *«v:obj»)
«m:/* »«x:--------------------------------------------------------------------------
    Retain an object (callable from C)
   -------------------------------------------------------------------------- */»
{
    «:objc-font-lock-background-face:«w:[»(«t:id»)«t:obj» «f:retain»«w:]»»;
}


«t:void» *
«f:ns_alloc_autorelease_pool» («t:void»)
«m:/* »«x:--------------------------------------------------------------------------
     Allocate a pool for temporary objects (callable from C)
   -------------------------------------------------------------------------- */»
{
  «k:return» «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSAutoreleasePool» «f:alloc»«w:]»» «f:init»«w:]»»;
}


«t:void»
«f:ns_release_autorelease_pool» («t:void» *«v:pool»)
«m:/* »«x:--------------------------------------------------------------------------
     Free a pool and temporary objects it refers to (callable from C)
   -------------------------------------------------------------------------- */»
{
  ns_release_object (pool);
}



«m:/* »«x:==========================================================================

    Focus (clipping) and screen update

   ========================================================================== */»

«m://»«x:
»«m:// »«x:Window constraining
»«m:// »«x:-------------------
»«m://»«x:
»«m:// »«x:To ensure that the windows are not placed under the menu bar, they
»«m:// »«x:are typically moved by the call-back constrainFrameRect. However,
»«m:// »«x:by overriding it, it's possible to inhibit this, leaving the window
»«m:// »«x:in it's original position.
»«m://»«x:
»«m:// »«x:It's possible to hide the menu bar. However, technically, it's only
»«m:// »«x:possible to hide it when the application is active. To ensure that
»«m:// »«x:this work properly, the menu bar and window constraining are
»«m:// »«x:deferred until the application becomes active.
»«m://»«x:
»«m:// »«x:Even though it's not possible to manually move a window above the
»«m:// »«x:top of the screen, it is allowed if it's done programmatically,
»«m:// »«x:when the menu is hidden. This allows the editable area to cover the
»«m:// »«x:full screen height.
»«m://»«x:
»«m:// »«x:Test cases
»«m:// »«x:----------
»«m://»«x:
»«m:// »«x:Use the following extra files:
»«m://»«x:
»«m://    »«x:init.el:
»«m://       »«x:;; Hide menu and place frame slightly above the top of the screen.
»«m://       »«x:(setq ns-auto-hide-menu-bar t)
»«m://       »«x:(set-frame-position (selected-frame) 0 -20)
»«m://»«x:
»«m:// »«x:Test 1:
»«m://»«x:
»«m://    »«x:emacs -Q -l init.el
»«m://»«x:
»«m://    »«x:Result: No menu bar, and the title bar should be above the screen.
»«m://»«x:
»«m:// »«x:Test 2:
»«m://»«x:
»«m://    »«x:emacs -Q
»«m://»«x:
»«m://    »«x:Result: Menu bar visible, frame placed immediately below the menu.
»«m://»«x:
»
«k:static» «t:void»
«f:ns_constrain_all_frames» («t:void»)
{
  «t:Lisp_Object» «v:tail», «v:frame»;

  «v:FOR_EACH_FRAME» («t:tail», «t:frame»)
    {
      «k:struct» «t:frame» *«t:f» = XFRAME (frame);
      «k:if» (FRAME_NS_P (f))
        {
          «t:NSView» *«v:view» = FRAME_NS_VIEW (f);
          «m:/* »«x:This no-op will trigger the default window placing
           * constraint system. */»
          «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:setFrameOrigin»:«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:frame»«w:]»».origin«w:]»»;
        }
    }
}


«m:/* »«x:True, if the menu bar should be hidden.  */»

«k:static» «t:BOOL»
«f:ns_menu_bar_should_be_hidden» («t:void»)
{
  «k:return» «n:!»NILP (ns_auto_hide_menu_bar)
    && «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:respondsToSelector»:«k:@selector»(setPresentationOptions:)«w:]»»;
}


«m:/* »«x:Show or hide the menu bar, based on user setting.  */»

«k:static» «t:void»
«f:ns_update_auto_hide_menu_bar» («t:void»)
{
«p:#ifdef» NS_IMPL_COCOA
«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
  block_input ();

  NSTRACE (ns_update_auto_hide_menu_bar);

  «k:if» (NSApp != «c:nil» && «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:isActive»«w:]»»)
    {
      «m:// »«x:Note, "setPresentationOptions" triggers an error unless the
»      «m:// »«x:application is active.
»      «t:BOOL» «v:menu_bar_should_be_hidden» = ns_menu_bar_should_be_hidden ();

      «k:if» (menu_bar_should_be_hidden != ns_menu_bar_is_hidden)
        {
          «t:NSApplicationPresentationOptions» «v:options»
            = NSApplicationPresentationDefault;

          «k:if» (menu_bar_should_be_hidden)
            options |= NSApplicationPresentationAutoHideMenuBar
              | NSApplicationPresentationAutoHideDock;

          «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setPresentationOptions»: options«w:]»»;

          ns_menu_bar_is_hidden = menu_bar_should_be_hidden;

          «k:if» («n:!»ns_menu_bar_is_hidden)
            {
              ns_constrain_all_frames ();
            }
        }
    }

  unblock_input ();
«p:#endif»
«p:#endif»
}


«k:static» «t:void»
«f:ns_update_begin» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
   Prepare for a grouped sequence of drawing calls
   external (RIF) call; whole frame, called before update_window_begin
   -------------------------------------------------------------------------- */»
{
  «t:EmacsView» *«v:view» = FRAME_NS_VIEW (f);
  NSTRACE (ns_update_begin);

  ns_update_auto_hide_menu_bar ();

«p:#ifdef» NS_IMPL_COCOA
  «k:if» («:objc-font-lock-background-face:«w:[»view «f:isFullscreen»«w:]»» && «:objc-font-lock-background-face:«w:[»view «f:fsIsNative»«w:]»»)
  {
    «m:// »«x:Fix reappearing tool bar in fullscreen for OSX 10.7
»    «t:BOOL» «v:tbar_visible» = FRAME_EXTERNAL_TOOL_BAR (f) ? «c:YES» : «c:NO»;
    «t:NSToolbar» *«v:toolbar» = «:objc-font-lock-background-face:«w:[»FRAME_NS_VIEW (f) «f:toolbar»«w:]»»;
    «k:if» («n:!» tbar_visible != «n:!» «:objc-font-lock-background-face:«w:[»toolbar «f:isVisible»«w:]»»)
      «:objc-font-lock-background-face:«w:[»toolbar «f:setVisible»: tbar_visible«w:]»»;
  }
«p:#endif»

  ns_updating_frame = f;
  «:objc-font-lock-background-face:«w:[»view «f:lockFocus»«w:]»»;

  «m:/* »«x:drawRect may have been called for say the minibuffer, and then clip path
     is for the minibuffer.  But the display engine may draw more because
     we have set the frame as garbaged.  So reset clip path to the whole
     view.  */»
«p:#ifdef» NS_IMPL_COCOA
  {
    «t:NSBezierPath» *«v:bp»;
    «t:NSRect» «v:r» = «:objc-font-lock-background-face:«w:[»view «f:frame»«w:]»»;
    «t:NSRect» «v:cr» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:frame»«w:]»»;
    «m:/* »«x:If a large frame size is set, r may be larger than the window frame
       before constrained.  In that case don't change the clip path, as we
       will clear in to the tool bar and title bar.  */»
    «k:if» (r.size.height
        + FRAME_NS_TITLEBAR_HEIGHT (f)
        + «f:FRAME_TOOLBAR_HEIGHT» (f) <= cr.size.height)
      {
        bp = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSBezierPath» «f:bezierPathWithRect»: r«w:]»» «f:retain»«w:]»»;
        «:objc-font-lock-background-face:«w:[»bp «f:setClip»«w:]»»;
        «:objc-font-lock-background-face:«w:[»bp «f:release»«w:]»»;
      }
  }
«p:#endif»

«p:#ifdef» NS_IMPL_GNUSTEP
  uRect = NSMakeRect (0, 0, 0, 0);
«p:#endif»
}


«k:static» «t:void»
«f:ns_update_window_begin» («k:struct» «t:window» *«t:w»)
«m:/* »«x:--------------------------------------------------------------------------
   Prepare for a grouped sequence of drawing calls
   external (RIF) call; for one window, called after update_begin
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:frame» *«t:f» = XFRAME (WINDOW_FRAME (w));
  «t:Mouse_HLInfo» *«v:hlinfo» = MOUSE_HL_INFO (f);

  NSTRACE (ns_update_window_begin);
  w->output_cursor = w->cursor;

  block_input ();

  «k:if» (f == hlinfo->mouse_face_mouse_frame)
    {
      «m:/* »«x:Don't do highlighting for mouse motion during the update.  */»
      hlinfo->mouse_face_defer = 1;

        «m:/* »«x:If the frame needs to be redrawn,
           simply forget about any prior mouse highlighting.  */»
      «k:if» (FRAME_GARBAGED_P (f))
        hlinfo->mouse_face_window = Qnil;

      «m:/* »«x:(further code for mouse faces ifdef'd out in other terms elided) */»
    }

  unblock_input ();
}


«k:static» «t:void»
«f:ns_update_window_end» («k:struct» «t:window» *«t:w», «t:bool» «v:cursor_on_p»,
                      «t:bool» «v:mouse_face_overwritten_p»)
«m:/* »«x:--------------------------------------------------------------------------
   Finished a grouped sequence of drawing calls
   external (RIF) call; for one window called before update_end
   -------------------------------------------------------------------------- */»
{
  «m:/* »«x:note: this fn is nearly identical in all terms */»
  «k:if» («n:!»w->pseudo_window_p)
    {
      block_input ();

      «k:if» (cursor_on_p)
	display_and_set_cursor (w, 1,
				w->output_cursor.hpos, w->output_cursor.vpos,
				w->output_cursor.x, w->output_cursor.y);

      «k:if» (draw_window_fringes (w, 1))
	{
	  «k:if» (WINDOW_RIGHT_DIVIDER_WIDTH (w))
	    x_draw_right_divider (w);
	  «k:else»
	    x_draw_vertical_border (w);
	}

      unblock_input ();
    }

  «m:/* »«x:If a row with mouse-face was overwritten, arrange for
     frame_up_to_date to redisplay the mouse highlight.  */»
  «k:if» (mouse_face_overwritten_p)
    reset_mouse_highlight (MOUSE_HL_INFO (XFRAME (w->frame)));

  NSTRACE (update_window_end);
}


«k:static» «t:void»
«f:ns_update_end» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
   Finished a grouped sequence of drawing calls
   external (RIF) call; for whole frame, called after update_window_end
   -------------------------------------------------------------------------- */»
{
  «t:EmacsView» *«v:view» = FRAME_NS_VIEW (f);

«m:/*   »«x:if (f == MOUSE_HL_INFO (f)->mouse_face_mouse_frame) */»
  MOUSE_HL_INFO (f)->mouse_face_defer = 0;

  block_input ();

  «:objc-font-lock-background-face:«w:[»view «f:unlockFocus»«w:]»»;
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:flushWindow»«w:]»»;

  unblock_input ();
  ns_updating_frame = NULL;
  NSTRACE (ns_update_end);
}

«k:static» «t:void»
«f:ns_focus» («k:struct» «t:frame» *«t:f», «t:NSRect» *«v:r», «t:int» «v:n»)
«m:/* »«x:--------------------------------------------------------------------------
   Internal: Focus on given frame.  During small local updates this is used to
     draw, however during large updates, ns_update_begin and ns_update_end are
     called to wrap the whole thing, in which case these calls are stubbed out.
     Except, on GNUstep, we accumulate the rectangle being drawn into, because
     the back end won't do this automatically, and will just end up flushing
     the entire window.
   -------------------------------------------------------------------------- */»
{
«m://  »«x:NSTRACE (ns_focus);
»«m:/* »«x:static int c =0;
   fprintf (stderr, "focus: %d", c++);
   if (r) fprintf (stderr, " (%.0f, %.0f : %.0f x %.0f)", r->origin.x, r->origin.y, r->size.width, r->size.height);
   fprintf (stderr, "\n"); */»

  «k:if» (f != ns_updating_frame)
    {
      «t:NSView» *«v:view» = FRAME_NS_VIEW (f);
      «k:if» (view != focus_view)
        {
          «k:if» (focus_view != NULL)
            {
              «:objc-font-lock-background-face:«w:[»focus_view «f:unlockFocus»«w:]»»;
              «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»focus_view «f:window»«w:]»» «f:flushWindow»«w:]»»;
«m:/*»«x:debug_lock--; */»
            }

          «k:if» (view)
            «:objc-font-lock-background-face:«w:[»view «f:lockFocus»«w:]»»;
          focus_view = view;
«m:/*»«x:if (view) debug_lock++; */»
        }
    }

  «m:/* »«x:clipping */»
  «k:if» (r)
    {
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSGraphicsContext» «f:currentContext»«w:]»» «f:saveGraphicsState»«w:]»»;
      «k:if» (n == 2)
        NSRectClipList (r, 2);
      «k:else»
        NSRectClip (*r);
      gsaved = «c:YES»;
    }
}


«k:static» «t:void»
«f:ns_unfocus» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     Internal: Remove focus on given frame
   -------------------------------------------------------------------------- */»
{
«m://  »«x:NSTRACE (ns_unfocus);
»
  «k:if» (gsaved)
    {
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSGraphicsContext» «f:currentContext»«w:]»» «f:restoreGraphicsState»«w:]»»;
      gsaved = «c:NO»;
    }

  «k:if» (f != ns_updating_frame)
    {
      «k:if» (focus_view != NULL)
        {
          «:objc-font-lock-background-face:«w:[»focus_view «f:unlockFocus»«w:]»»;
          «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»focus_view «f:window»«w:]»» «f:flushWindow»«w:]»»;
          focus_view = NULL;
«m:/*»«x:debug_lock--; */»
        }
    }
}


«k:static» «t:void»
«f:ns_clip_to_row» («k:struct» «t:window» *«t:w», «k:struct» «t:glyph_row» *«t:row»,
		«k:enum» «t:glyph_row_area» «t:area», «t:BOOL» «v:gc»)
«m:/* »«x:--------------------------------------------------------------------------
     Internal (but parallels other terms): Focus drawing on given row
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:frame» *«t:f» = XFRAME (WINDOW_FRAME (w));
  «t:NSRect» «v:clip_rect»;
  «t:int» «v:window_x», «v:window_y», «v:window_width»;

  window_box (w, area, &window_x, &window_y, &window_width, 0);

  clip_rect.origin.x = window_x;
  clip_rect.origin.y = WINDOW_TO_FRAME_PIXEL_Y (w, max (0, row->y));
  clip_rect.origin.y = max (clip_rect.origin.y, window_y);
  clip_rect.size.width = window_width;
  clip_rect.size.height = row->visible_height;

  ns_focus (f, &clip_rect, 1);
}


«k:static» «t:void»
«f:ns_ring_bell» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     "Beep" routine
   -------------------------------------------------------------------------- */»
{
  NSTRACE (ns_ring_bell);
  «k:if» (visible_bell)
    {
      «t:NSAutoreleasePool» *«v:pool»;
      «k:struct» «t:frame» *«t:frame» = SELECTED_FRAME ();
      «t:NSView» *«v:view»;

      block_input ();
      pool = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSAutoreleasePool» «f:alloc»«w:]»» «f:init»«w:]»»;

      view = FRAME_NS_VIEW (frame);
      «k:if» (view != «c:nil»)
        {
          «t:NSRect» «v:r», «v:surr»;
          «t:NSPoint» «v:dim» = NSMakePoint (128, 128);

          r = «:objc-font-lock-background-face:«w:[»view «f:bounds»«w:]»»;
          r.origin.x += (r.size.width - dim.x) / 2;
          r.origin.y += (r.size.height - dim.y) / 2;
          r.size.width = dim.x;
          r.size.height = dim.y;
          surr = NSInsetRect (r, -2, -2);
          ns_focus (frame, &surr, 1);
          «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:cacheImageInRect»: «:objc-font-lock-background-face:«w:[»view «f:convertRect»: surr «f:toView»:«c:nil»«w:]»»«w:]»»;
          «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (NS_FACE_FOREGROUND»
                                      «:objc-font-lock-background-face:(FRAME_DEFAULT_FACE (frame)), frame) «f:set»«w:]»»;
          «t:NSRectFill» («v:r»);
          «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:flushWindow»«w:]»»;
          ns_timeout (150000);
          «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:restoreCachedImage»«w:]»»;
          «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:flushWindow»«w:]»»;
          ns_unfocus (frame);
        }
      «:objc-font-lock-background-face:«w:[»pool «f:release»«w:]»»;
      unblock_input ();
    }
  «k:else»
    {
      NSBeep ();
    }
}

«m:/* »«x:==========================================================================

    Frame / window manager related functions

   ========================================================================== */»


«k:static» «t:void»
«f:ns_raise_frame» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     Bring window to foreground and make it active
   -------------------------------------------------------------------------- */»
{
  «t:NSView» *«v:view»;
  check_window_system (f);
  view = FRAME_NS_VIEW (f);
  block_input ();
  «k:if» (FRAME_VISIBLE_P (f))
    «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:makeKeyAndOrderFront»: NSApp«w:]»»;
  unblock_input ();
}


«k:static» «t:void»
«f:ns_lower_frame» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     Send window to back
   -------------------------------------------------------------------------- */»
{
  «t:NSView» *«v:view»;
  check_window_system (f);
  view = FRAME_NS_VIEW (f);
  block_input ();
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:orderBack»: NSApp«w:]»»;
  unblock_input ();
}


«k:static» «t:void»
«f:ns_frame_raise_lower» («k:struct» «t:frame» *«t:f», «t:int» «v:raise»)
«m:/* »«x:--------------------------------------------------------------------------
     External (hook)
   -------------------------------------------------------------------------- */»
{
  NSTRACE (ns_frame_raise_lower);

  «k:if» (raise)
    ns_raise_frame (f);
  «k:else»
    ns_lower_frame (f);
}


«k:static» «t:void»
«f:ns_frame_rehighlight» («k:struct» «t:frame» *«t:frame»)
«m:/* »«x:--------------------------------------------------------------------------
     External (hook): called on things like window switching within frame
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:ns_display_info» *«t:dpyinfo» = FRAME_DISPLAY_INFO (frame);
  «k:struct» «t:frame» *«t:old_highlight» = dpyinfo->x_highlight_frame;

  NSTRACE (ns_frame_rehighlight);
  «k:if» (dpyinfo->x_focus_frame)
    {
      dpyinfo->x_highlight_frame
	= (FRAMEP (FRAME_FOCUS_FRAME (dpyinfo->x_focus_frame))
           ? XFRAME (FRAME_FOCUS_FRAME (dpyinfo->x_focus_frame))
           : dpyinfo->x_focus_frame);
      «k:if» («n:!»FRAME_LIVE_P (dpyinfo->x_highlight_frame))
        {
          fset_focus_frame (dpyinfo->x_focus_frame, Qnil);
          dpyinfo->x_highlight_frame = dpyinfo->x_focus_frame;
        }
    }
  «k:else»
      dpyinfo->x_highlight_frame = 0;

  «k:if» (dpyinfo->x_highlight_frame &&
         dpyinfo->x_highlight_frame != old_highlight)
    {
      «k:if» (old_highlight)
	{
          x_update_cursor (old_highlight, 1);
	  x_set_frame_alpha (old_highlight);
	}
      «k:if» (dpyinfo->x_highlight_frame)
	{
          x_update_cursor (dpyinfo->x_highlight_frame, 1);
          x_set_frame_alpha (dpyinfo->x_highlight_frame);
	}
    }
}


«t:void»
«f:x_make_frame_visible» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     External: Show the window (X11 semantics)
   -------------------------------------------------------------------------- */»
{
  NSTRACE (x_make_frame_visible);
  «m:/* »«x:XXX: at some points in past this was not needed, as the only place that
     called this (frame.c:Fraise_frame ()) also called raise_lower;
     if this ends up the case again, comment this out again. */»
  «k:if» («n:!»FRAME_VISIBLE_P (f))
    {
      «t:EmacsView» *«v:view» = («t:EmacsView» *)FRAME_NS_VIEW (f);

      SET_FRAME_VISIBLE (f, 1);
      ns_raise_frame (f);

      «m:/* »«x:Making a new frame from a fullscreen frame will make the new frame
         fullscreen also.  So skip handleFS as this will print an error.  */»
      «k:if» («:objc-font-lock-background-face:«w:[»view «f:fsIsNative»«w:]»» && f->want_fullscreen == FULLSCREEN_BOTH
          && «:objc-font-lock-background-face:«w:[»view «f:isFullscreen»«w:]»»)
        «k:return»;

      «k:if» (f->want_fullscreen != FULLSCREEN_NONE)
        {
          block_input ();
          «:objc-font-lock-background-face:«w:[»view «f:handleFS»«w:]»»;
          unblock_input ();
        }
    }
}


«t:void»
«f:x_make_frame_invisible» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     External: Hide the window (X11 semantics)
   -------------------------------------------------------------------------- */»
{
  «t:NSView» *«v:view»;
  NSTRACE (x_make_frame_invisible);
  check_window_system (f);
  view = FRAME_NS_VIEW (f);
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:orderOut»: NSApp«w:]»»;
  SET_FRAME_VISIBLE (f, 0);
  SET_FRAME_ICONIFIED (f, 0);
}


«t:void»
«f:x_iconify_frame» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     External: Iconify window
   -------------------------------------------------------------------------- */»
{
  «t:NSView» *«v:view»;
  «k:struct» «t:ns_display_info» *«t:dpyinfo»;

  NSTRACE (x_iconify_frame);
  check_window_system (f);
  view = FRAME_NS_VIEW (f);
  dpyinfo = FRAME_DISPLAY_INFO (f);

  «k:if» (dpyinfo->x_highlight_frame == f)
    dpyinfo->x_highlight_frame = 0;

  «k:if» («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:windowNumber»«w:]»» <= 0)
    {
      «m:/* »«x:the window is still deferred.  Make it very small, bring it
         on screen and order it out. */»
      «t:NSRect» «v:s» = { { 100, 100}, {0, 0} };
      «t:NSRect» «v:t»;
      t = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:frame»«w:]»»;
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:setFrame»: s «f:display»: «c:NO»«w:]»»;
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:orderBack»: NSApp«w:]»»;
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:orderOut»: NSApp«w:]»»;
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:setFrame»: t «f:display»: «c:NO»«w:]»»;
    }
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:miniaturize»: NSApp«w:]»»;
}

«m:/* »«x:Free X resources of frame F.  */»

«t:void»
«f:x_free_frame_resources» («k:struct» «t:frame» *«t:f»)
{
  «t:NSView» *«v:view»;
  «k:struct» «t:ns_display_info» *«t:dpyinfo»;
  «t:Mouse_HLInfo» *«v:hlinfo»;

  NSTRACE (x_free_frame_resources);
  check_window_system (f);
  view = FRAME_NS_VIEW (f);
  dpyinfo = FRAME_DISPLAY_INFO (f);
  hlinfo = MOUSE_HL_INFO (f);

  «:objc-font-lock-background-face:«w:[»(«t:EmacsView» *)«t:view» «f:setWindowClosing»: «c:YES»«w:]»»; «m:/* »«x:may not have been informed */»

  block_input ();

  free_frame_menubar (f);
  free_frame_faces (f);

  «k:if» (f == dpyinfo->x_focus_frame)
    dpyinfo->x_focus_frame = 0;
  «k:if» (f == dpyinfo->x_highlight_frame)
    dpyinfo->x_highlight_frame = 0;
  «k:if» (f == hlinfo->mouse_face_mouse_frame)
    reset_mouse_highlight (hlinfo);

  «k:if» (f->output_data.ns->miniimage != «c:nil»)
    «:objc-font-lock-background-face:«w:[»f->output_data.ns->miniimage «f:release»«w:]»»;

  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:close»«w:]»»;
  «:objc-font-lock-background-face:«w:[»view «f:release»«w:]»»;

  xfree (f->output_data.ns);

  unblock_input ();
}

«t:void»
«f:x_destroy_window» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     External: Delete the window
   -------------------------------------------------------------------------- */»
{
  NSTRACE (x_destroy_window);
  check_window_system (f);
  x_free_frame_resources (f);
  ns_window_num--;
}


«t:void»
«f:x_set_offset» («k:struct» «t:frame» *«t:f», «t:int» «v:xoff», «t:int» «v:yoff», «t:int» «v:change_grav»)
«m:/* »«x:--------------------------------------------------------------------------
     External: Position the window
   -------------------------------------------------------------------------- */»
{
  «t:NSView» *«v:view» = FRAME_NS_VIEW (f);
  «t:NSArray» *«v:screens» = «:objc-font-lock-background-face:«w:[»«t:NSScreen» «f:screens»«w:]»»;
  «t:NSScreen» *«v:fscreen» = «:objc-font-lock-background-face:«w:[»screens «f:objectAtIndex»: 0«w:]»»;
  «t:NSScreen» *«v:screen» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:screen»«w:]»»;

  NSTRACE (x_set_offset);

  block_input ();

  f->left_pos = xoff;
  f->top_pos = yoff;

  «k:if» (view != «c:nil» && screen && fscreen)
    {
      f->left_pos = f->size_hint_flags & XNegative
        ? «:objc-font-lock-background-face:«w:[»screen «f:visibleFrame»«w:]»».size.width + f->left_pos - FRAME_PIXEL_WIDTH (f)
        : f->left_pos;
      «m:/* »«x:We use visibleFrame here to take menu bar into account.
	 Ideally we should also adjust left/top with visibleFrame.origin.  */»

      f->top_pos = f->size_hint_flags & YNegative
        ? («:objc-font-lock-background-face:«w:[»screen «f:visibleFrame»«w:]»».size.height + f->top_pos
           - FRAME_PIXEL_HEIGHT (f) - «f:FRAME_NS_TITLEBAR_HEIGHT» (f)
           - «f:FRAME_TOOLBAR_HEIGHT» (f))
        : f->top_pos;
«p:#ifdef» NS_IMPL_GNUSTEP
      «k:if» (f->left_pos < 100)
        f->left_pos = 100;  «m:/* »«x:don't overlap menu */»
«p:#endif»
      «m:/* »«x:Constrain the setFrameTopLeftPoint so we don't move behind the
         menu bar.  */»
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:setFrameTopLeftPoint»:»
                       «:objc-font-lock-background-face:NSMakePoint (SCREENMAXBOUND (f->left_pos),»
                                    «:objc-font-lock-background-face:SCREENMAXBOUND («:objc-font-lock-background-face:«w:[»fscreen «f:frame»«w:]»».size.height»
                                                    «:objc-font-lock-background-face:- NS_TOP_POS (f)))«w:]»»;
      f->size_hint_flags &= ~(XNegative|YNegative);
    }

  unblock_input ();
}


«t:void»
«f:x_set_window_size» («k:struct» «t:frame» *«t:f»,
                   «t:int» «v:change_grav»,
                   «t:int» «v:width»,
                   «t:int» «v:height»,
                   «t:bool» «v:pixelwise»)
«m:/* »«x:--------------------------------------------------------------------------
     Adjust window pixel size based on given character grid size
     Impl is a bit more complex than other terms, need to do some
     internal clipping.
   -------------------------------------------------------------------------- */»
{
  «t:EmacsView» *«v:view» = FRAME_NS_VIEW (f);
  «t:NSWindow» *«v:window» = «:objc-font-lock-background-face:«w:[»view «f:window»«w:]»»;
  «t:NSRect» «v:wr» = «:objc-font-lock-background-face:«w:[»window «f:frame»«w:]»»;
  «t:int» «v:tb» = FRAME_EXTERNAL_TOOL_BAR (f);
  «t:int» «v:pixelwidth», «v:pixelheight»;
  «t:int» «v:rows», «v:cols»;

  NSTRACE (x_set_window_size);

  «k:if» (view == «c:nil»)
    «k:return»;

«m:/*»«x:fprintf (stderr, "\tsetWindowSize: %d x %d, pixelwise %d, font size %d x %d\n", width, height, pixelwise, FRAME_COLUMN_WIDTH (f), FRAME_LINE_HEIGHT (f));*/»

  block_input ();

  check_frame_size (f, &width, &height, pixelwise);

  compute_fringe_widths (f, 0);

  «k:if» (pixelwise)
    {
      pixelwidth = FRAME_TEXT_TO_PIXEL_WIDTH (f, width);
      pixelheight = FRAME_TEXT_TO_PIXEL_HEIGHT (f, height);
      cols = FRAME_PIXEL_WIDTH_TO_TEXT_COLS (f, pixelwidth);
      rows = FRAME_PIXEL_HEIGHT_TO_TEXT_LINES (f, pixelheight);
    }
  «k:else»
    {
      pixelwidth =  FRAME_TEXT_COLS_TO_PIXEL_WIDTH   (f, width);
      pixelheight = FRAME_TEXT_LINES_TO_PIXEL_HEIGHT (f, height);
      cols = width;
      rows = height;
    }

  «m:/* »«x:If we have a toolbar, take its height into account. */»
  «k:if» (tb && «n:!» «:objc-font-lock-background-face:«w:[»view «f:isFullscreen»«w:]»»)
    {
    «m:/* »«x:NOTE: previously this would generate wrong result if toolbar not
             yet displayed and fixing toolbar_height=32 helped, but
             now (200903) seems no longer needed */»
    FRAME_TOOLBAR_HEIGHT (f) =
      NSHeight («:objc-font-lock-background-face:«w:[»window «f:frameRectForContentRect»: NSMakeRect (0, 0, 0, 0)«w:]»»)
        - «f:FRAME_NS_TITLEBAR_HEIGHT» (f);
«p:#ifdef» NS_IMPL_GNUSTEP
      FRAME_TOOLBAR_HEIGHT (f) -= 3;
«p:#endif»
    }
  «k:else»
    FRAME_TOOLBAR_HEIGHT (f) = 0;

  wr.size.width = pixelwidth + f->border_width;
  wr.size.height = pixelheight;
  «k:if» («n:!» «:objc-font-lock-background-face:«w:[»view «f:isFullscreen»«w:]»»)
    wr.size.height += FRAME_NS_TITLEBAR_HEIGHT (f)
      + «f:FRAME_TOOLBAR_HEIGHT» (f);

  «m:/* »«x:Do not try to constrain to this screen.  We may have multiple
     screens, and want Emacs to span those.  Constraining to screen
     prevents that, and that is not nice to the user.  */»
 «k:if» (f->output_data.ns->zooming)
   f->output_data.ns->zooming = 0;
 «k:else»
   wr.origin.y += FRAME_PIXEL_HEIGHT (f) - «f:pixelheight»;

  «:objc-font-lock-background-face:«w:[»view «f:setRows»: rows «f:andColumns»: cols«w:]»»;
  «:objc-font-lock-background-face:«w:[»window «f:setFrame»: wr «f:display»: «c:YES»«w:]»»;

  «m:/* »«x:This is a trick to compensate for Emacs' managing the scrollbar area
     as a fixed number of standard character columns.  Instead of leaving
     blank space for the extra, we chopped it off above.  Now for
     left-hand scrollbars, we shift all rendering to the left by the
     difference between the real width and Emacs' imagined one.  For
     right-hand bars, don't worry about it since the extra is never used.
     (Obviously doesn't work for vertically split windows tho..) */»
  {
    «t:NSPoint» «v:origin» = FRAME_HAS_VERTICAL_SCROLL_BARS_ON_LEFT (f)
      ? NSMakePoint (FRAME_SCROLL_BAR_COLS (f) * FRAME_COLUMN_WIDTH (f)
                     - «f:NS_SCROLL_BAR_WIDTH» (f), 0)
      : NSMakePoint (0, 0);
    «:objc-font-lock-background-face:«w:[»view «f:setFrame»: NSMakeRect (0, 0, pixelwidth, pixelheight)«w:]»»;
    «:objc-font-lock-background-face:«w:[»view «f:setBoundsOrigin»: origin«w:]»»;
  }

  change_frame_size (f, width, height, 0, 1, 0, pixelwise);
«m:/*  »«x:SET_FRAME_GARBAGED (f); // this short-circuits expose call in drawRect */»

  mark_window_cursors_off (XWINDOW (f->root_window));
  cancel_mouse_face (f);

  unblock_input ();
}


«k:static» «t:void»
«f:ns_fullscreen_hook» («k:struct» «t:frame» *«t:f»)
{
  «t:EmacsView» *«v:view» = («t:EmacsView» *)FRAME_NS_VIEW (f);

  «k:if» («n:!»FRAME_VISIBLE_P (f))
    «k:return»;

   «k:if» («n:!» «:objc-font-lock-background-face:«w:[»view «f:fsIsNative»«w:]»» && f->want_fullscreen == FULLSCREEN_BOTH)
    {
      «m:/* »«x:Old style fs don't initiate correctly if created from
         init/default-frame alist, so use a timer (not nice...).
      */»
      «:objc-font-lock-background-face:«w:[»«t:NSTimer» «f:scheduledTimerWithTimeInterval»: 0.5 «f:target»: view»
                                     «:objc-font-lock-background-face:«f:selector»: «k:@selector» (handleFS)»
                                     «:objc-font-lock-background-face:«f:userInfo»: «c:nil» «f:repeats»: «c:NO»«w:]»»;
      «k:return»;
    }

  block_input ();
  «:objc-font-lock-background-face:«w:[»view «f:handleFS»«w:]»»;
  unblock_input ();
}

«m:/* »«x:==========================================================================

    Color management

   ========================================================================== */»


«t:NSColor» *
«f:ns_lookup_indexed_color» («t:unsigned» «t:long» idx, «k:struct» «t:frame» *«t:f»)
{
  «k:struct» «t:ns_color_table» *«t:color_table» = FRAME_DISPLAY_INFO (f)->color_table;
  «k:if» (idx < 1 || idx >= color_table->avail)
    «k:return» «c:nil»;
  «k:return» color_table->colors[idx];
}


«t:unsigned» «t:long»
ns_index_color («t:NSColor» *«v:color», «k:struct» «t:frame» *«t:f»)
{
  «k:struct» «t:ns_color_table» *«t:color_table» = FRAME_DISPLAY_INFO (f)->color_table;
  «t:ptrdiff_t» «v:idx»;
  «t:ptrdiff_t» «v:i»;

  «k:if» («n:!»color_table->colors)
    {
      color_table->size = NS_COLOR_CAPACITY;
      color_table->avail = 1; «m:/* »«x:skip idx=0 as marker */»
      color_table->colors = xmalloc (color_table->size * sizeof («t:NSColor» *));
      color_table->colors[0] = «c:nil»;
      color_table->empty_indices = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSMutableSet» «f:alloc»«w:]»» «f:init»«w:]»»;
    }

  «m:/* »«x:Do we already have this color?  */»
  «k:for» (i = 1; i < color_table->avail; i++)
    «k:if» (color_table->colors[i] && «:objc-font-lock-background-face:«w:[»color_table->colors[i] «f:isEqual»: color«w:]»»)
      «k:return» i;

  «k:if» («:objc-font-lock-background-face:«w:[»color_table->empty_indices «f:count»«w:]»» > 0)
    {
      «t:NSNumber» *«v:index» = «:objc-font-lock-background-face:«w:[»color_table->empty_indices «f:anyObject»«w:]»»;
      «:objc-font-lock-background-face:«w:[»color_table->empty_indices «f:removeObject»: index«w:]»»;
      idx = «:objc-font-lock-background-face:«w:[»index «f:unsignedLongValue»«w:]»»;
    }
  «k:else»
    {
      «k:if» (color_table->avail == color_table->size)
	color_table->colors =
	  xpalloc (color_table->colors, &color_table->size, 1,
		   min (ULONG_MAX, PTRDIFF_MAX), sizeof *color_table->colors);
      idx = color_table->avail++;
    }

  color_table->colors[idx] = color;
  «:objc-font-lock-background-face:«w:[»color «f:retain»«w:]»»;
«m:/*»«x:fprintf(stderr, "color_table: allocated %d\n",idx);*/»
  «k:return» idx;
}


«t:void»
«f:ns_free_indexed_color» («t:unsigned» «t:long» idx, «k:struct» «t:frame» *«t:f»)
{
  «k:struct» «t:ns_color_table» *«t:color_table»;
  «t:NSColor» *«v:color»;
  «t:NSNumber» *«v:index»;

  «k:if» («n:!»f)
    «k:return»;

  color_table = FRAME_DISPLAY_INFO (f)->color_table;

  «k:if» (idx <= 0 || idx >= color_table->size) {
    message1 («s:"ns_free_indexed_color: Color index out of range.\n"»);
    «k:return»;
  }

  index = «:objc-font-lock-background-face:«w:[»«t:NSNumber» «f:numberWithUnsignedInt»: idx«w:]»»;
  «k:if» («:objc-font-lock-background-face:«w:[»color_table->empty_indices «f:containsObject»: index«w:]»») {
    message1 («s:"ns_free_indexed_color: attempt to free already freed color.\n"»);
    «k:return»;
  }

  color = color_table->colors[idx];
  «:objc-font-lock-background-face:«w:[»color «f:release»«w:]»»;
  color_table->colors[idx] = «c:nil»;
  «:objc-font-lock-background-face:«w:[»color_table->empty_indices «f:addObject»: index«w:]»»;
«m:/*»«x:fprintf(stderr, "color_table: FREED %d\n",idx);*/»
}


«k:static» «t:int»
«f:ns_get_color» («k:const» «t:char» *«v:name», «t:NSColor» **«v:col»)
«m:/* »«x:--------------------------------------------------------------------------
     Parse a color name
   -------------------------------------------------------------------------- */»
«m:/* »«x:On *Step, we attempt to mimic the X11 platform here, down to installing an
   X11 rgb.txt-compatible color list in Emacs.clr (see ns_term_init()).
   See: http://thread.gmane.org/gmane.emacs.devel/113050/focus=113272). */»
{
  «t:NSColor» *«v:new» = «c:nil»;
  «k:static» «t:char» «v:hex»[20];
  «t:int» «v:scaling»;
  «t:float» «v:r» = -1.0, «v:g», «v:b»;
  «t:NSString» *«v:nsname» = «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»: name«w:]»»;

«m:/*»«x:fprintf (stderr, "ns_get_color: '%s'\n", name); */»
  block_input ();

  «k:if» («:objc-font-lock-background-face:«w:[»nsname «f:isEqualToString»: @«s:"ns_selection_bg_color"»«w:]»»)
    {
«p:#ifdef» NS_IMPL_COCOA
      «t:NSString» *«v:defname» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSUserDefaults» «f:standardUserDefaults»«w:]»»»
                            «:objc-font-lock-background-face:«f:stringForKey»: @«s:"AppleHighlightColor"»«w:]»»;
      «k:if» (defname != «c:nil»)
        nsname = defname;
      «k:else»
«p:#endif»
      «k:if» ((new = «:objc-font-lock-background-face:«w:[»«t:NSColor» «f:selectedTextBackgroundColor»«w:]»») != «c:nil»)
        {
          *col = «:objc-font-lock-background-face:«w:[»new «f:colorUsingDefaultColorSpace»«w:]»»;
          unblock_input ();
          «k:return» 0;
        }
      «k:else»
        nsname = NS_SELECTION_BG_COLOR_DEFAULT;

      name = «:objc-font-lock-background-face:«w:[»nsname «f:UTF8String»«w:]»»;
    }
  «k:else» «k:if» («:objc-font-lock-background-face:«w:[»nsname «f:isEqualToString»: @«s:"ns_selection_fg_color"»«w:]»»)
    {
      «m:/* »«x:NOTE: OSX applications normally don't set foreground selection, but
         text may be unreadable if we don't.
      */»
      «k:if» ((new = «:objc-font-lock-background-face:«w:[»«t:NSColor» «f:selectedTextColor»«w:]»») != «c:nil»)
        {
          *col = «:objc-font-lock-background-face:«w:[»new «f:colorUsingDefaultColorSpace»«w:]»»;
          unblock_input ();
          «k:return» 0;
        }

      nsname = NS_SELECTION_FG_COLOR_DEFAULT;
      name = «:objc-font-lock-background-face:«w:[»nsname «f:UTF8String»«w:]»»;
    }

  «m:/* »«x:First, check for some sort of numeric specification. */»
  hex[0] = «s:'\0'»;

  «k:if» (name[0] == «s:'0'» || name[0] == «s:'1'» || name[0] == «s:'.'»)  «m:/* »«x:RGB decimal */»
    {
      «t:NSScanner» *«v:scanner» = «:objc-font-lock-background-face:«w:[»«t:NSScanner» «f:scannerWithString»: nsname«w:]»»;
      «:objc-font-lock-background-face:«w:[»scanner «f:scanFloat»: &r«w:]»»;
      «:objc-font-lock-background-face:«w:[»scanner «f:scanFloat»: &g«w:]»»;
      «:objc-font-lock-background-face:«w:[»scanner «f:scanFloat»: &b«w:]»»;
    }
  «k:else» «k:if» («n:!»strncmp(name, «s:"rgb:"», 4))  «m:/* »«x:A newer X11 format -- rgb:r/g/b */»
    scaling = (snprintf (hex, «t:sizeof» «v:hex», «s:"%s"», name + 4) - 2) / 3;
  «k:else» «k:if» (name[0] == «s:'#'»)        «m:/* »«x:An old X11 format; convert to newer */»
    {
      «t:int» «v:len» = (strlen(name) - 1);
      «t:int» «v:start» = (len % 3 == 0) ? 1 : len / 4 + 1;
      «t:int» «v:i»;
      scaling = strlen(name+start) / 3;
      «k:for» (i = 0; i < 3; i++)
	sprintf (hex + i * (scaling + 1), «s:"%.*s/"», scaling,
		 name + start + i * scaling);
      hex[3 * (scaling + 1) - 1] = «s:'\0'»;
    }

  «k:if» (hex[0])
    {
      «t:int» «v:rr», «v:gg», «v:bb»;
      «t:float» «v:fscale» = scaling == 4 ? 65535.0 : (scaling == 2 ? 255.0 : 15.0);
      «k:if» (sscanf (hex, «s:"%x/%x/%x"», &rr, &gg, &bb))
        {
          r = rr / fscale;
          g = gg / fscale;
          b = bb / fscale;
        }
    }

  «k:if» (r >= 0.0F)
    {
      *col = «:objc-font-lock-background-face:«w:[»«t:NSColor» «f:colorForEmacsRed»: r «f:green»: g «f:blue»: b «f:alpha»: 1.0«w:]»»;
      unblock_input ();
      «k:return» 0;
    }

  «m:/* »«x:Otherwise, color is expected to be from a list */»
  {
    «t:NSEnumerator» *«v:lenum», *«v:cenum»;
    «t:NSString» *«v:name»;
    «t:NSColorList» *«v:clist»;

«p:#ifdef» NS_IMPL_GNUSTEP
    «m:/* »«x:XXX: who is wrong, the requestor or the implementation? */»
    «k:if» («:objc-font-lock-background-face:«w:[»nsname «f:compare»: @«s:"Highlight"» «f:options»: NSCaseInsensitiveSearch«w:]»»
        == NSOrderedSame)
      nsname = @«s:"highlightColor"»;
«p:#endif»

    lenum = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSColorList» «f:availableColorLists»«w:]»» «f:objectEnumerator»«w:]»»;
    «k:while» ( (clist = «:objc-font-lock-background-face:«w:[»lenum «f:nextObject»«w:]»») && new == «c:nil»)
      {
        cenum = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»clist «f:allKeys»«w:]»» «f:objectEnumerator»«w:]»»;
        «k:while» ( (name = «:objc-font-lock-background-face:«w:[»cenum «f:nextObject»«w:]»») && new == «c:nil» )
          {
            «k:if» («:objc-font-lock-background-face:«w:[»name «f:compare»: nsname»
                      «:objc-font-lock-background-face:«f:options»: NSCaseInsensitiveSearch«w:]»» == NSOrderedSame )
              new = «:objc-font-lock-background-face:«w:[»clist «f:colorWithKey»: name«w:]»»;
          }
      }
  }

  «k:if» (new)
    *col = «:objc-font-lock-background-face:«w:[»new «f:colorUsingDefaultColorSpace»«w:]»»;
  unblock_input ();
  «k:return» new ? 0 : 1;
}


«t:int»
«f:ns_lisp_to_color» («t:Lisp_Object» «v:color», «t:NSColor» **«v:col»)
«m:/* »«x:--------------------------------------------------------------------------
     Convert a Lisp string object to a NS color
   -------------------------------------------------------------------------- */»
{
  NSTRACE (ns_lisp_to_color);
  «k:if» (STRINGP (color))
    «k:return» ns_get_color (SSDATA (color), col);
  «k:else» «k:if» (SYMBOLP (color))
    «k:return» ns_get_color (SSDATA (SYMBOL_NAME (color)), col);
  «k:return» 1;
}


«t:Lisp_Object»
«f:ns_color_to_lisp» («t:NSColor» *«v:col»)
«m:/* »«x:--------------------------------------------------------------------------
     Convert a color to a lisp string with the RGB equivalent
   -------------------------------------------------------------------------- */»
{
  «t:EmacsCGFloat» «v:red», «v:green», «v:blue», «v:alpha», «v:gray»;
  «t:char» «v:buf»[1024];
  «k:const» «t:char» *«v:str»;
  NSTRACE (ns_color_to_lisp);

  block_input ();
  «k:if» («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»col «f:colorSpaceName»«w:]»» «f:isEqualToString»: NSNamedColorSpace«w:]»»)

      «k:if» ((str =«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»col «f:colorNameComponent»«w:]»» «f:UTF8String»«w:]»»))
        {
          unblock_input ();
          «k:return» build_string ((«t:char» *)str);
        }

    «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»col «f:colorUsingDefaultColorSpace»«w:]»»»
        «:objc-font-lock-background-face:«f:getRed»: &red «f:green»: &green «f:blue»: &blue «f:alpha»: &alpha«w:]»»;
  «k:if» (red == green && red == blue)
    {
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»col «f:colorUsingColorSpaceName»: NSCalibratedWhiteColorSpace«w:]»»»
            «:objc-font-lock-background-face:«f:getWhite»: &gray «f:alpha»: &alpha«w:]»»;
      snprintf (buf, sizeof (buf), «s:"#%2.2lx%2.2lx%2.2lx"»,
		lrint (gray * 0xff), lrint (gray * 0xff), lrint (gray * 0xff));
      unblock_input ();
      «k:return» build_string (buf);
    }

  snprintf (buf, sizeof (buf), «s:"#%2.2lx%2.2lx%2.2lx"»,
            lrint (red*0xff), lrint (green*0xff), lrint (blue*0xff));

  unblock_input ();
  «k:return» build_string (buf);
}


«t:void»
«f:ns_query_color»(«t:void» *«v:col», «t:XColor» *«v:color_def», «t:int» «v:setPixel»)
«m:/* »«x:--------------------------------------------------------------------------
         Get ARGB values out of NSColor col and put them into color_def.
         If setPixel, set the pixel to a concatenated version.
         and set color_def pixel to the resulting index.
   -------------------------------------------------------------------------- */»
{
  «t:EmacsCGFloat» «v:r», «v:g», «v:b», «v:a»;

  «:objc-font-lock-background-face:«w:[»((«t:NSColor» *)col) «f:getRed»: &r «f:green»: &g «f:blue»: &b «f:alpha»: &a«w:]»»;
  color_def->red   = r * 65535;
  color_def->green = g * 65535;
  color_def->blue  = b * 65535;

  «k:if» (setPixel == «c:YES»)
    color_def->pixel
      = ARGB_TO_ULONG((«t:int»)(a*255),
		      («t:int»)(r*255), («t:int»)(g*255), («t:int»)(b*255));
}


«t:bool»
«f:ns_defined_color» («k:struct» «t:frame» *«t:f»,
                  «k:const» «t:char» *«v:name»,
                  «t:XColor» *«v:color_def»,
                  «t:bool» «v:alloc»,
                  «t:bool» «v:makeIndex»)
«m:/* »«x:--------------------------------------------------------------------------
         Return true if named color found, and set color_def rgb accordingly.
         If makeIndex and alloc are nonzero put the color in the color_table,
         and set color_def pixel to the resulting index.
         If makeIndex is zero, set color_def pixel to ARGB.
         Return false if not found
   -------------------------------------------------------------------------- */»
{
  «t:NSColor» *«v:col»;
  NSTRACE (ns_defined_color);

  block_input ();
  «k:if» (ns_get_color (name, &col) != 0) «m:/* »«x:Color not found  */»
    {
      unblock_input ();
      «k:return» 0;
    }
  «k:if» (makeIndex && alloc)
    color_def->pixel = ns_index_color (col, f);
  ns_query_color (col, color_def, «n:!»makeIndex);
  unblock_input ();
  «k:return» 1;
}


«t:void»
«f:x_set_frame_alpha» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     change the entire-frame transparency
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:ns_display_info» *«t:dpyinfo» = FRAME_DISPLAY_INFO (f);
  «t:double» «v:alpha» = 1.0;
  «t:double» «v:alpha_min» = 1.0;

  «k:if» (dpyinfo->x_highlight_frame == f)
    alpha = f->alpha[0];
  «k:else»
    alpha = f->alpha[1];

  «k:if» (FLOATP (Vframe_alpha_lower_limit))
    alpha_min = XFLOAT_DATA (Vframe_alpha_lower_limit);
  «k:else» «k:if» (INTEGERP (Vframe_alpha_lower_limit))
    alpha_min = (XINT (Vframe_alpha_lower_limit)) / 100.0;

  «k:if» (alpha < 0.0)
    «k:return»;
  «k:else» «k:if» (1.0 < alpha)
    alpha = 1.0;
  «k:else» «k:if» (0.0 <= alpha && alpha < alpha_min && alpha_min <= 1.0)
    alpha = alpha_min;

«p:#ifdef» NS_IMPL_COCOA
  {
    «t:EmacsView» *«v:view» = FRAME_NS_VIEW (f);
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:setAlphaValue»: alpha«w:]»»;
  }
«p:#endif»
}


«m:/* »«x:==========================================================================

    Mouse handling

   ========================================================================== */»


«t:void»
«f:x_set_mouse_pixel_position» («k:struct» «t:frame» *«t:f», «t:int» «v:pix_x», «t:int» «v:pix_y»)
«m:/* »«x:--------------------------------------------------------------------------
     Programmatically reposition mouse pointer in pixel coordinates
   -------------------------------------------------------------------------- */»
{
  NSTRACE (x_set_mouse_pixel_position);
  ns_raise_frame (f);
«p:#if» 0
  «m:/* »«x:FIXME: this does not work, and what about GNUstep? */»
«p:#ifdef» NS_IMPL_COCOA
  «:objc-font-lock-background-face:«w:[»FRAME_NS_VIEW (f) «f:lockFocus»«w:]»»;
  PSsetmouse ((«t:float»)pix_x, («t:float»)pix_y);
  «:objc-font-lock-background-face:«w:[»FRAME_NS_VIEW (f) «f:unlockFocus»«w:]»»;
«p:#endif»
«p:#endif»
}


«t:void»
«f:x_set_mouse_position» («k:struct» «t:frame» *«t:f», «t:int» «v:h», «t:int» «v:v»)
«m:/* »«x:--------------------------------------------------------------------------
     Programmatically reposition mouse pointer in character coordinates
   -------------------------------------------------------------------------- */»
{
  «t:int» «v:pix_x», «v:pix_y»;

  pix_x = FRAME_COL_TO_PIXEL_X (f, h) + «f:FRAME_COLUMN_WIDTH» (f) / 2;
  pix_y = FRAME_LINE_TO_PIXEL_Y (f, v) + «f:FRAME_LINE_HEIGHT» (f) / 2;

  «k:if» (pix_x < 0) pix_x = 0;
  «k:if» (pix_x > FRAME_PIXEL_WIDTH (f)) pix_x = FRAME_PIXEL_WIDTH (f);

  «k:if» (pix_y < 0) pix_y = 0;
  «k:if» (pix_y > FRAME_PIXEL_HEIGHT (f)) pix_y = FRAME_PIXEL_HEIGHT (f);

  x_set_mouse_pixel_position (f, pix_x, pix_y);
}


«k:static» «t:int»
«f:note_mouse_movement» («k:struct» «t:frame» *«t:frame», «t:CGFloat» «v:x», «t:CGFloat» «v:y»)
«m:/*   »«x:------------------------------------------------------------------------
     Called by EmacsView on mouseMovement events.  Passes on
     to emacs mainstream code if we moved off of a rect of interest
     known as last_mouse_glyph.
     ------------------------------------------------------------------------ */»
{
  «k:struct» «t:ns_display_info» *«t:dpyinfo» = FRAME_DISPLAY_INFO (frame);
  «t:NSRect» *«v:r»;

«m://  »«x:NSTRACE (note_mouse_movement);
»
  dpyinfo->last_mouse_motion_frame = frame;
  r = &dpyinfo->last_mouse_glyph;

  «m:/* »«x:Note, this doesn't get called for enter/leave, since we don't have a
     position.  Those are taken care of in the corresponding NSView methods. */»

  «m:/* »«x:has movement gone beyond last rect we were tracking? */»
  «k:if» (x < r->origin.x || x >= r->origin.x + r->size.width
      || y < r->origin.y || y >= r->origin.y + r->size.height)
    {
      ns_update_begin (frame);
      frame->mouse_moved = 1;
      note_mouse_highlight (frame, x, y);
      remember_mouse_glyph (frame, x, y, r);
      ns_update_end (frame);
      «k:return» 1;
    }

  «k:return» 0;
}


«k:static» «t:void»
«f:ns_mouse_position» («k:struct» «t:frame» **«t:fp», «t:int» «v:insist», «t:Lisp_Object» *«v:bar_window»,
                   «k:enum» «t:scroll_bar_part» *«t:part», «t:Lisp_Object» *«v:x», «t:Lisp_Object» *«v:y»,
                   «t:Time» *«v:time»)
«m:/* »«x:--------------------------------------------------------------------------
    External (hook): inform emacs about mouse position and hit parts.
    If a scrollbar is being dragged, set bar_window, part, x, y, time.
    x & y should be position in the scrollbar (the whole bar, not the handle)
    and length of scrollbar respectively
   -------------------------------------------------------------------------- */»
{
  «t:id» «v:view»;
  «t:NSPoint» «v:position»;
  «t:Lisp_Object» «v:frame», «v:tail»;
  «k:struct» «t:frame» *«t:f»;
  «k:struct» «t:ns_display_info» *«t:dpyinfo»;

  NSTRACE (ns_mouse_position);

  «k:if» (*fp == NULL)
    {
      fprintf (stderr, «s:"Warning: ns_mouse_position () called with null *fp.\n"»);
      «k:return»;
    }

  dpyinfo = FRAME_DISPLAY_INFO (*fp);

  block_input ();

  «k:if» (dpyinfo->last_mouse_scroll_bar != «c:nil» && insist == 0)
    {
      «m:/* »«x:TODO: we do not use this path at the moment because drag events will
           go directly to the EmacsScroller.  Leaving code in for now. */»
      «:objc-font-lock-background-face:«w:[»dpyinfo->last_mouse_scroll_bar»
	  «:objc-font-lock-background-face:«f:getMouseMotionPart»: («t:int» *)«t:part» «f:window»: bar_window «f:x»: x «f:y»: y«w:]»»;
      «k:if» (time)
	*time = dpyinfo->last_mouse_movement_time;
      dpyinfo->last_mouse_scroll_bar = «c:nil»;
    }
  «k:else»
    {
      «m:/* »«x:Clear the mouse-moved flag for every frame on this display.  */»
      FOR_EACH_FRAME (tail, frame)
        «k:if» (FRAME_NS_P (XFRAME (frame))
            && FRAME_NS_DISPLAY (XFRAME (frame)) == FRAME_NS_DISPLAY (*fp))
          XFRAME (frame)->mouse_moved = 0;

      dpyinfo->last_mouse_scroll_bar = «c:nil»;
      «k:if» (dpyinfo->last_mouse_frame
	  && FRAME_LIVE_P (dpyinfo->last_mouse_frame))
        f = dpyinfo->last_mouse_frame;
      «k:else»
        f = dpyinfo->x_focus_frame ? dpyinfo->x_focus_frame
                                    : SELECTED_FRAME ();

      «k:if» (f && FRAME_NS_P (f))
        {
          view = FRAME_NS_VIEW (*fp);

          position = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:mouseLocationOutsideOfEventStream»«w:]»»;
          position = «:objc-font-lock-background-face:«w:[»view «f:convertPoint»: position «f:fromView»: «c:nil»«w:]»»;
          remember_mouse_glyph (f, position.x, position.y,
				&dpyinfo->last_mouse_glyph);
«m:/*»«x:fprintf (stderr, "ns_mouse_position: %.0f, %.0f\n", position.x, position.y); */»

          «k:if» (bar_window) *bar_window = Qnil;
          «k:if» (part) *part = 0; «m:/*»«x:scroll_bar_handle; */»

          «k:if» (x) XSETINT (*x, lrint (position.x));
          «k:if» (y) XSETINT (*y, lrint (position.y));
          «k:if» (time)
	    *time = dpyinfo->last_mouse_movement_time;
          *fp = f;
        }
    }

  unblock_input ();
}


«k:static» «t:void»
«f:ns_frame_up_to_date» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
    External (hook): Fix up mouse highlighting right after a full update.
    Can't use FRAME_MOUSE_UPDATE due to ns_frame_begin and ns_frame_end calls.
   -------------------------------------------------------------------------- */»
{
  NSTRACE (ns_frame_up_to_date);

  «k:if» (FRAME_NS_P (f))
    {
      «t:Mouse_HLInfo» *«v:hlinfo» = MOUSE_HL_INFO (f);
      «k:if» (f == hlinfo->mouse_face_mouse_frame)
	{
	  block_input ();
	  ns_update_begin(f);
	  note_mouse_highlight (hlinfo->mouse_face_mouse_frame,
				hlinfo->mouse_face_mouse_x,
				hlinfo->mouse_face_mouse_y);
	  ns_update_end(f);
	  unblock_input ();
	}
    }
}


«k:static» «t:void»
«f:ns_define_frame_cursor» («k:struct» «t:frame» *«t:f», «t:Cursor» «v:cursor»)
«m:/* »«x:--------------------------------------------------------------------------
    External (RIF): set frame mouse pointer type.
   -------------------------------------------------------------------------- */»
{
  NSTRACE (ns_define_frame_cursor);
  «k:if» (FRAME_POINTER_TYPE (f) != cursor)
    {
      «t:EmacsView» *«v:view» = FRAME_NS_VIEW (f);
      FRAME_POINTER_TYPE (f) = cursor;
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:invalidateCursorRectsForView»: view«w:]»»;
      «m:/* »«x:Redisplay assumes this function also draws the changed frame
         cursor, but this function doesn't, so do it explicitly.  */»
      x_update_cursor (f, 1);
    }
}



«m:/* »«x:==========================================================================

    Keyboard handling

   ========================================================================== */»


«k:static» «t:unsigned»
«f:ns_convert_key» («t:unsigned» «v:code»)
«m:/* »«x:--------------------------------------------------------------------------
    Internal call used by NSView-keyDown.
   -------------------------------------------------------------------------- */»
{
  «k:const» «t:unsigned» «v:last_keysym» = (sizeof (convert_ns_to_X_keysym)
                                / sizeof (convert_ns_to_X_keysym[0]));
  «t:unsigned» «v:keysym»;
  «m:/* »«x:An array would be faster, but less easy to read. */»
  «k:for» (keysym = 0; keysym < last_keysym; keysym += 2)
    «k:if» (code == convert_ns_to_X_keysym[keysym])
      «k:return» 0xFF00 | convert_ns_to_X_keysym[keysym+1];
  «k:return» 0;
«m:/* »«x:if decide to use keyCode and Carbon table, use this line:
     return code > 0xff ? 0 : 0xFF00 | ns_keycode_to_xkeysym_table[code]; */»
}


«t:char» *
«f:x_get_keysym_name» («t:int» «v:keysym»)
«m:/* »«x:--------------------------------------------------------------------------
    Called by keyboard.c.  Not sure if the return val is important, except
    that it be unique.
   -------------------------------------------------------------------------- */»
{
  «k:static» «t:char» «v:value»[16];
  NSTRACE (x_get_keysym_name);
  sprintf (value, «s:"%d"», keysym);
  «k:return» value;
}



«m:/* »«x:==========================================================================

    Block drawing operations

   ========================================================================== */»


«k:static» «t:void»
«f:ns_redraw_scroll_bars» («k:struct» «t:frame» *«t:f»)
{
  «t:int» «v:i»;
  «t:id» «v:view»;
  «t:NSArray» *«v:subviews» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»FRAME_NS_VIEW (f) «f:superview»«w:]»» «f:subviews»«w:]»»;
  NSTRACE (ns_redraw_scroll_bars);
  «k:for» (i =«:objc-font-lock-background-face:«w:[»subviews «f:count»«w:]»»-1; i >= 0; i--)
    {
      view = «:objc-font-lock-background-face:«w:[»subviews «f:objectAtIndex»: i«w:]»»;
      «k:if» («n:!»«:objc-font-lock-background-face:«w:[»view «f:isKindOfClass»: «:objc-font-lock-background-face:«w:[»«t:EmacsScroller» «f:class»«w:]»»«w:]»») «k:continue»;
      «:objc-font-lock-background-face:«w:[»view «f:display»«w:]»»;
    }
}


«t:void»
«f:ns_clear_frame» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
      External (hook): Erase the entire frame
   -------------------------------------------------------------------------- */»
{
  «t:NSView» *«v:view» = FRAME_NS_VIEW (f);
  «t:NSRect» «v:r»;

  NSTRACE (ns_clear_frame);

 «m:/* »«x:comes on initial frame because we have
    after-make-frame-functions = select-frame */»
 «k:if» («n:!»FRAME_DEFAULT_FACE (f))
   «k:return»;

  mark_window_cursors_off (XWINDOW (FRAME_ROOT_WINDOW (f)));

  r = «:objc-font-lock-background-face:«w:[»view «f:bounds»«w:]»»;

  block_input ();
  ns_focus (f, &r, 1);
  «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (NS_FACE_BACKGROUND (FRAME_DEFAULT_FACE (f)), f) «f:set»«w:]»»;
  «t:NSRectFill» («v:r»);
  ns_unfocus (f);

  «m:/* »«x:as of 2006/11 or so this is now needed */»
  ns_redraw_scroll_bars (f);
  unblock_input ();
}


«k:static» «t:void»
«f:ns_clear_frame_area» («k:struct» «t:frame» *«t:f», «t:int» «v:x», «t:int» «v:y», «t:int» «v:width», «t:int» «v:height»)
«m:/* »«x:--------------------------------------------------------------------------
    External (RIF):  Clear section of frame
   -------------------------------------------------------------------------- */»
{
  «t:NSRect» «v:r» = NSMakeRect (x, y, width, height);
  «t:NSView» *«v:view» = FRAME_NS_VIEW (f);
  «k:struct» «t:face» *«t:face» = FRAME_DEFAULT_FACE (f);

  «k:if» («n:!»view || «n:!»face)
    «k:return»;

  NSTRACE (ns_clear_frame_area);

  r = NSIntersectionRect (r, «:objc-font-lock-background-face:«w:[»view «f:frame»«w:]»»);
  ns_focus (f, &r, 1);
  «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (NS_FACE_BACKGROUND (face), f) «f:set»«w:]»»;

  «t:NSRectFill» («v:r»);

  ns_unfocus (f);
  «k:return»;
}


«k:static» «t:void»
«f:ns_scroll_run» («k:struct» «t:window» *«t:w», «k:struct» «t:run» *«t:run»)
«m:/* »«x:--------------------------------------------------------------------------
    External (RIF):  Insert or delete n lines at line vpos
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:frame» *«t:f» = XFRAME (w->frame);
  «t:int» «v:x», «v:y», «v:width», «v:height», «v:from_y», «v:to_y», «v:bottom_y»;

  NSTRACE (ns_scroll_run);

  «m:/* »«x:begin copy from other terms */»
  «m:/* »«x:Get frame-relative bounding box of the text display area of W,
     without mode lines.  Include in this box the left and right
     fringe of W.  */»
  window_box (w, ANY_AREA, &x, &y, &width, &height);

  from_y = WINDOW_TO_FRAME_PIXEL_Y (w, run->current_y);
  to_y = WINDOW_TO_FRAME_PIXEL_Y (w, run->desired_y);
  bottom_y = y + height;

  «k:if» (to_y < from_y)
    {
      «m:/* »«x:Scrolling up.  Make sure we don't copy part of the mode
	 line at the bottom.  */»
      «k:if» (from_y + run->height > bottom_y)
	height = bottom_y - from_y;
      «k:else»
	height = run->height;
    }
  «k:else»
    {
      «m:/* »«x:Scrolling down.  Make sure we don't copy over the mode line.
	 at the bottom.  */»
      «k:if» (to_y + run->height > bottom_y)
	height = bottom_y - to_y;
      «k:else»
	height = run->height;
    }
  «m:/* »«x:end copy from other terms */»

  «k:if» (height == 0)
      «k:return»;

  block_input ();

  x_clear_cursor (w);

  {
    «t:NSRect» «v:srcRect» = NSMakeRect (x, from_y, width, height);
    «t:NSRect» «v:dstRect» = NSMakeRect (x, to_y, width, height);
    «t:NSPoint» «v:dstOrigin» = NSMakePoint (x, to_y);

    ns_focus (f, &dstRect, 1);
    NSCopyBits (0, srcRect , dstOrigin);
    ns_unfocus (f);
  }

  unblock_input ();
}


«k:static» «t:void»
«f:ns_after_update_window_line» («k:struct» «t:window» *«t:w», «k:struct» «t:glyph_row» *«t:desired_row»)
«m:/* »«x:--------------------------------------------------------------------------
    External (RIF): preparatory to fringe update after text was updated
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:frame» *«t:f»;
  «t:int» «v:width», «v:height»;

  NSTRACE (ns_after_update_window_line);

  «m:/* »«x:begin copy from other terms */»
  eassert (w);

  «k:if» («n:!»desired_row->mode_line_p && «n:!»w->pseudo_window_p)
    desired_row->redraw_fringe_bitmaps_p = 1;

  «m:/* »«x:When a window has disappeared, make sure that no rest of
     full-width rows stays visible in the internal border.  */»
  «k:if» (windows_or_buffers_changed
      && desired_row->full_width_p
      && (f = XFRAME (w->frame),
	  width = FRAME_INTERNAL_BORDER_WIDTH (f),
	  width != 0)
      && (height = desired_row->visible_height,
	  height > 0))
    {
      «t:int» «v:y» = WINDOW_TO_FRAME_PIXEL_Y (w, max (0, desired_row->y));

      block_input ();
      ns_clear_frame_area (f, 0, y, width, height);
      ns_clear_frame_area (f,
                           FRAME_PIXEL_WIDTH (f) - «f:width»,
                           y, width, height);
      unblock_input ();
    }
}


«k:static» «t:void»
«f:ns_shift_glyphs_for_insert» («k:struct» «t:frame» *«t:f»,
                           «t:int» «v:x», «t:int» «v:y», «t:int» «v:width», «t:int» «v:height»,
                           «t:int» «v:shift_by»)
«m:/* »«x:--------------------------------------------------------------------------
    External (RIF): copy an area horizontally, don't worry about clearing src
   -------------------------------------------------------------------------- */»
{
  «t:NSRect» «v:srcRect» = NSMakeRect (x, y, width, height);
  «t:NSRect» «v:dstRect» = NSMakeRect (x+shift_by, y, width, height);
  «t:NSPoint» «v:dstOrigin» = dstRect.origin;

  NSTRACE (ns_shift_glyphs_for_insert);

  ns_focus (f, &dstRect, 1);
  NSCopyBits (0, srcRect, dstOrigin);
  ns_unfocus (f);
}



«m:/* »«x:==========================================================================

    Character encoding and metrics

   ========================================================================== */»


«k:static» «t:void»
«f:ns_compute_glyph_string_overhangs» («k:struct» «t:glyph_string» *«t:s»)
«m:/* »«x:--------------------------------------------------------------------------
     External (RIF); compute left/right overhang of whole string and set in s
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:font» *«t:font» = s->font;

  «k:if» (s->char2b)
    {
      «k:struct» «t:font_metrics» «t:metrics»;
      «t:unsigned» «t:int» codes[2];
      codes[0] = *(s->char2b);
      codes[1] = *(s->char2b + s->nchars - 1);

      font->driver->text_extents (font, codes, 2, &metrics);
      s->left_overhang = -metrics.lbearing;
      s->right_overhang
	= metrics.rbearing > metrics.width
	? metrics.rbearing - metrics.width : 0;
    }
  «k:else»
    {
      s->left_overhang = 0;
      «k:if» (EQ (font->driver->type, Qns))
        s->right_overhang = ((«k:struct» «t:nsfont_info» *)font)->ital ?
          FONT_HEIGHT (font) * 0.2 : 0;
      «k:else»
        s->right_overhang = 0;
    }
}



«m:/* »«x:==========================================================================

    Fringe and cursor drawing

   ========================================================================== */»


«k:extern» «t:int» «v:max_used_fringe_bitmap»;
«k:static» «t:void»
«f:ns_draw_fringe_bitmap» («k:struct» «t:window» *«t:w», «k:struct» «t:glyph_row» *«t:row»,
                      «k:struct» «t:draw_fringe_bitmap_params» *«t:p»)
«m:/* »«x:--------------------------------------------------------------------------
    External (RIF); fringe-related
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:frame» *«t:f» = XFRAME (WINDOW_FRAME (w));
  «k:struct» «t:face» *«t:face» = p->face;
  «k:static» «t:EmacsImage» **«v:bimgs» = NULL;
  «k:static» «t:int» «v:nBimgs» = 0;

  «m:/* »«x:grow bimgs if needed */»
  «k:if» (nBimgs < max_used_fringe_bitmap)
    {
      bimgs = xrealloc (bimgs, max_used_fringe_bitmap * sizeof *bimgs);
      memset (bimgs + nBimgs, 0,
	      (max_used_fringe_bitmap - nBimgs) * sizeof *bimgs);
      nBimgs = max_used_fringe_bitmap;
    }

  «m:/* »«x:Must clip because of partially visible lines.  */»
  ns_clip_to_row (w, row, ANY_AREA, «c:YES»);

  «k:if» («n:!»p->overlay_p)
    {
      «t:int» «v:bx» = p->bx, «v:by» = p->by, «v:nx» = p->nx, «v:ny» = p->ny;

      «m:/* »«x:If the fringe is adjacent to the left (right) scroll bar of a
	 leftmost (rightmost, respectively) window, then extend its
	 background to the gap between the fringe and the bar.  */»
      «k:if» ((WINDOW_LEFTMOST_P (w)
	   && WINDOW_HAS_VERTICAL_SCROLL_BAR_ON_LEFT (w))
	  || (WINDOW_RIGHTMOST_P (w)
	      && WINDOW_HAS_VERTICAL_SCROLL_BAR_ON_RIGHT (w)))
	{
	  «t:int» «v:sb_width» = WINDOW_CONFIG_SCROLL_BAR_WIDTH (w);

	  «k:if» (sb_width > 0)
	    {
	      «t:int» «v:bar_area_x» = WINDOW_SCROLL_BAR_AREA_X (w);
	      «t:int» «v:bar_area_width» = (WINDOW_CONFIG_SCROLL_BAR_COLS (w)
				    * FRAME_COLUMN_WIDTH (f));

	      «k:if» (bx < 0)
		{
		  «m:/* »«x:Bitmap fills the fringe.  */»
		  «k:if» (bar_area_x + bar_area_width == p->x)
		    bx = bar_area_x + sb_width;
		  «k:else» «k:if» (p->x + p->wd == bar_area_x)
		    bx = bar_area_x;
		  «k:if» (bx >= 0)
		    {
		      «t:int» «v:header_line_height» = WINDOW_HEADER_LINE_HEIGHT (w);

		      nx = bar_area_width - sb_width;
		      by = WINDOW_TO_FRAME_PIXEL_Y (w, max (header_line_height,
							    row->y));
		      ny = row->visible_height;
		    }
		}
	      «k:else»
		{
		  «k:if» (bar_area_x + bar_area_width == bx)
		    {
		      bx = bar_area_x + sb_width;
		      nx += bar_area_width - sb_width;
		    }
		  «k:else» «k:if» (bx + nx == bar_area_x)
		    nx += bar_area_width - sb_width;
		}
	    }
	}

      «k:if» (bx >= 0 && nx > 0)
        {
          «t:NSRect» «v:r» = NSMakeRect (bx, by, nx, ny);
          «t:NSRectClip» («v:r»);
          «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (face->background, f) «f:set»«w:]»»;
          «t:NSRectFill» («v:r»);
        }
    }

  «k:if» (p->which)
    {
      «t:NSRect» «v:r» = NSMakeRect (p->x, p->y, p->wd, p->h);
      «t:EmacsImage» *«v:img» = bimgs[p->which - 1];

      «k:if» («n:!»img)
        {
          «t:unsigned» «t:short» *bits = p->bits + p->dh;
          «t:int» «v:len» = p->h;
          «t:int» «v:i»;
          «t:unsigned» «t:char» *cbits = xmalloc (len);

          «k:for» (i = 0; i < len; i++)
            cbits[i] = ~(bits[i] & 0xff);
          img = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsImage» «f:alloc»«w:]»» «f:initFromXBM»: cbits «f:width»: 8 «f:height»: p->h»
                                           «:objc-font-lock-background-face:«f:flip»: «c:NO»«w:]»»;
          bimgs[p->which - 1] = img;
          xfree (cbits);
        }

      «t:NSRectClip» («v:r»);
      «m:/* »«x:Since we composite the bitmap instead of just blitting it, we need
         to erase the whole background. */»
      «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color(face->background, f) «f:set»«w:]»»;
      «t:NSRectFill» («v:r»);
      «:objc-font-lock-background-face:«w:[»img «f:setXBMColor»: ns_lookup_indexed_color(face->foreground, f)«w:]»»;
«p:#if» «p:defined» (NS_IMPL_COCOA) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
      «:objc-font-lock-background-face:«w:[»img «f:drawInRect»: r»
              «:objc-font-lock-background-face:«f:fromRect»: NSZeroRect»
             «:objc-font-lock-background-face:«f:operation»: NSCompositeSourceOver»
              «:objc-font-lock-background-face:«f:fraction»: 1.0»
           «:objc-font-lock-background-face:«f:respectFlipped»: «c:YES»»
                «:objc-font-lock-background-face:«f:hints»: «c:nil»«w:]»»;
«p:#else»
      {
        «t:NSPoint» «v:pt» = r.origin;
        pt.y += p->h;
        «:objc-font-lock-background-face:«w:[»img «f:compositeToPoint»: pt «f:operation»: NSCompositeSourceOver«w:]»»;
      }
«p:#endif»
    }
  ns_unfocus (f);
}


«k:static» «t:void»
«f:ns_draw_window_cursor» («k:struct» «t:window» *«t:w», «k:struct» «t:glyph_row» *«t:glyph_row»,
		       «t:int» «v:x», «t:int» «v:y», «k:enum» «t:text_cursor_kinds» «t:cursor_type»,
		       «t:int» «v:cursor_width», «t:bool» «v:on_p», «t:bool» «v:active_p»)
«m:/* »«x:--------------------------------------------------------------------------
     External call (RIF): draw cursor.
     Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
   -------------------------------------------------------------------------- */»
{
  «t:NSRect» «v:r», «v:s»;
  «t:int» «v:fx», «v:fy», «v:h», «v:cursor_height»;
  «k:struct» «t:frame» *«t:f» = WINDOW_XFRAME (w);
  «k:struct» «t:glyph» *«t:phys_cursor_glyph»;
  «k:struct» «t:glyph» *«t:cursor_glyph»;
  «k:struct» «t:face» *«t:face»;
  «t:NSColor» *«v:hollow_color» = FRAME_BACKGROUND_COLOR (f);

  «m:/* »«x:If cursor is out of bounds, don't draw garbage.  This can happen
     in mini-buffer windows when switching between echo area glyphs
     and mini-buffer.  */»

  NSTRACE (dumpcursor);

  «k:if» («n:!»on_p)
    «k:return»;

  w->phys_cursor_type = cursor_type;
  w->phys_cursor_on_p = on_p;

  «k:if» (cursor_type == NO_CURSOR)
    {
      w->phys_cursor_width = 0;
      «k:return»;
    }

  «k:if» ((phys_cursor_glyph = get_phys_cursor_glyph (w)) == NULL)
    {
      «k:if» (glyph_row->exact_window_width_line_p
          && w->phys_cursor.hpos >= glyph_row->used[TEXT_AREA])
        {
          glyph_row->cursor_in_fringe_p = 1;
          draw_fringe_bitmap (w, glyph_row, 0);
        }
      «k:return»;
    }

  «m:/* »«x:We draw the cursor (with NSRectFill), then draw the glyph on top
     (other terminals do it the other way round).  We must set
     w->phys_cursor_width to the cursor width.  For bar cursors, that
     is CURSOR_WIDTH; for box cursors, it is the glyph width.  */»
  get_phys_cursor_geometry (w, glyph_row, phys_cursor_glyph, &fx, &fy, &h);

  «m:/* »«x:The above get_phys_cursor_geometry call set w->phys_cursor_width
     to the glyph width; replace with CURSOR_WIDTH for (V)BAR cursors. */»
  «k:if» (cursor_type == BAR_CURSOR)
    {
      «k:if» (cursor_width < 1)
	cursor_width = max (FRAME_CURSOR_WIDTH (f), 1);
      w->phys_cursor_width = cursor_width;
    }
  «m:/* »«x:If we have an HBAR, "cursor_width" MAY specify height. */»
  «k:else» «k:if» (cursor_type == HBAR_CURSOR)
    {
      cursor_height = (cursor_width < 1) ? lrint (0.25 * h) : cursor_width;
      fy += h - cursor_height;
      h = cursor_height;
    }

  r.origin.x = fx, r.origin.y = fy;
  r.size.height = h;
  r.size.width = w->phys_cursor_width;

  «m:/* »«x:TODO: only needed in rare cases with last-resort font in HELLO..
     should we do this more efficiently? */»
  ns_clip_to_row (w, glyph_row, ANY_AREA, «c:NO»); «m:/* »«x:do ns_focus(f, &r, 1); if remove */»


  face = FACE_FROM_ID (f, phys_cursor_glyph->face_id);
  «k:if» (face && NS_FACE_BACKGROUND (face)
      == ns_index_color (FRAME_CURSOR_COLOR (f), f))
    {
      «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (NS_FACE_FOREGROUND (face), f) «f:set»«w:]»»;
      hollow_color = FRAME_CURSOR_COLOR (f);
    }
  «k:else»
    «:objc-font-lock-background-face:«w:[»FRAME_CURSOR_COLOR (f) «f:set»«w:]»»;

«p:#ifdef» NS_IMPL_COCOA
  «m:/* »«x:TODO: This makes drawing of cursor plus that of phys_cursor_glyph
           atomic.  Cleaner ways of doing this should be investigated.
           One way would be to set a global variable DRAWING_CURSOR
  	   when making the call to draw_phys..(), don't focus in that
  	   case, then move the ns_unfocus() here after that call. */»
  NSDisableScreenUpdates ();
«p:#endif»

  «k:switch» (cursor_type)
    {
    «k:case» NO_CURSOR:
      «k:break»;
    «k:case» FILLED_BOX_CURSOR:
      «t:NSRectFill» («v:r»);
      «k:break»;
    «k:case» HOLLOW_BOX_CURSOR:
      «t:NSRectFill» («v:r»);
      «:objc-font-lock-background-face:«w:[»hollow_color «f:set»«w:]»»;
      «t:NSRectFill» («v:NSInsetRect» («t:r», 1, 1));
      «:objc-font-lock-background-face:«w:[»FRAME_CURSOR_COLOR (f) «f:set»«w:]»»;
      «k:break»;
    «k:case» HBAR_CURSOR:
      «t:NSRectFill» («v:r»);
      «k:break»;
    «k:case» BAR_CURSOR:
      s = r;
      «m:/* »«x:If the character under cursor is R2L, draw the bar cursor
         on the right of its glyph, rather than on the left.  */»
      cursor_glyph = get_phys_cursor_glyph (w);
      «k:if» ((cursor_glyph->resolved_level & 1) != 0)
        s.origin.x += cursor_glyph->pixel_width - s.size.width;

      «t:NSRectFill» («v:s»);
      «k:break»;
    }
  ns_unfocus (f);

  «m:/* »«x:draw the character under the cursor */»
  «k:if» (cursor_type != NO_CURSOR)
    draw_phys_cursor_glyph (w, glyph_row, DRAW_CURSOR);

«p:#ifdef» NS_IMPL_COCOA
  NSEnableScreenUpdates ();
«p:#endif»

}


«k:static» «t:void»
«f:ns_draw_vertical_window_border» («k:struct» «t:window» *«t:w», «t:int» «v:x», «t:int» «v:y0», «t:int» «v:y1»)
«m:/* »«x:--------------------------------------------------------------------------
     External (RIF): Draw a vertical line.
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:frame» *«t:f» = XFRAME (WINDOW_FRAME (w));
  «k:struct» «t:face» *«t:face»;
  «t:NSRect» «v:r» = NSMakeRect (x, y0, 1, y1-y0);

  NSTRACE (ns_draw_vertical_window_border);

  face = FACE_FROM_ID (f, VERTICAL_BORDER_FACE_ID);
  «k:if» (face)
      «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color(face->foreground, f) «f:set»«w:]»»;

  ns_focus (f, &r, 1);
  «t:NSRectFill»(«v:r»);
  ns_unfocus (f);
}


«k:static» «t:void»
«f:ns_draw_window_divider» («k:struct» «t:window» *«t:w», «t:int» «v:x0», «t:int» «v:x1», «t:int» «v:y0», «t:int» «v:y1»)
«m:/* »«x:--------------------------------------------------------------------------
     External (RIF): Draw a window divider.
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:frame» *«t:f» = XFRAME (WINDOW_FRAME (w));
  «k:struct» «t:face» *«t:face»;
  «t:NSRect» «v:r» = NSMakeRect (x0, y0, x1-x0, y1-y0);

  NSTRACE (ns_draw_window_divider);

  face = FACE_FROM_ID (f, WINDOW_DIVIDER_FACE_ID);
  «k:if» (face)
      «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color(face->foreground, f) «f:set»«w:]»»;

  ns_focus (f, &r, 1);
  «t:NSRectFill»(«v:r»);
  ns_unfocus (f);
}


«t:void»
«f:show_hourglass» («k:struct» «t:atimer» *«t:timer»)
{
  «k:if» (hourglass_shown_p)
    «k:return»;

  block_input ();

  «m:/* »«x:TODO: add NSProgressIndicator to selected frame (see macfns.c) */»

  hourglass_shown_p = 1;
  unblock_input ();
}


«t:void»
«f:hide_hourglass» («t:void»)
{
  «k:if» («n:!»hourglass_shown_p)
    «k:return»;

  block_input ();

  «m:/* »«x:TODO: remove NSProgressIndicator from all frames */»

  hourglass_shown_p = 0;
  unblock_input ();
}



«m:/* »«x:==========================================================================

    Glyph drawing operations

   ========================================================================== */»

«k:static» «t:int»
«f:ns_get_glyph_string_clip_rect» («k:struct» «t:glyph_string» *«t:s», «t:NativeRectangle» *«v:nr»)
«m:/* »«x:--------------------------------------------------------------------------
    Wrapper utility to account for internal border width on full-width lines,
    and allow top full-width rows to hit the frame top.  nr should be pointer
    to two successive NSRects.  Number of rects actually used is returned.
   -------------------------------------------------------------------------- */»
{
  «t:int» «v:n» = get_glyph_string_clip_rects (s, nr, 2);
  «k:return» n;
}

«m:/* »«x:--------------------------------------------------------------------
   Draw a wavy line under glyph string s. The wave fills wave_height
   pixels from y.

                    x          wave_length = 2
                                 --
                y    *   *   *   *   *
                     |* * * * * * * * *
    wave_height = 3  | *   *   *   *
  --------------------------------------------------------------------- */»

«k:static» «t:void»
«f:ns_draw_underwave» («k:struct» «t:glyph_string» *«t:s», «t:EmacsCGFloat» «v:width», «t:EmacsCGFloat» «v:x»)
{
  «t:int» «v:wave_height» = 3, «v:wave_length» = 2;
  «t:int» «v:y», «v:dx», «v:dy», «v:odd», «v:xmax»;
  «t:NSPoint» «v:a», «v:b»;
  «t:NSRect» «v:waveClip»;

  dx = wave_length;
  dy = wave_height - 1;
  y =  s->ybase - wave_height + 3;
  xmax = x + width;

  «m:/* »«x:Find and set clipping rectangle */»
  waveClip = NSMakeRect (x, y, width, wave_height);
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSGraphicsContext» «f:currentContext»«w:]»» «f:saveGraphicsState»«w:]»»;
  «t:NSRectClip» («v:waveClip»);

  «m:/* »«x:Draw the waves */»
  a.x = x - ((«t:int»)(x) % dx) + («t:EmacsCGFloat») 0.5;
  b.x = a.x + dx;
  odd = («t:int»)(a.x/dx) % 2;
  a.y = b.y = y + 0.5;

  «k:if» (odd)
    a.y += dy;
  «k:else»
    b.y += dy;

  «k:while» (a.x <= xmax)
    {
      «:objc-font-lock-background-face:«w:[»«t:NSBezierPath» «f:strokeLineFromPoint»:a «f:toPoint»:b«w:]»»;
      a.x = b.x, a.y = b.y;
      b.x += dx, b.y = y + 0.5 + odd*dy;
      odd = «n:!»odd;
    }

  «m:/* »«x:Restore previous clipping rectangle(s) */»
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSGraphicsContext» «f:currentContext»«w:]»» «f:restoreGraphicsState»«w:]»»;
}



«t:void»
«f:ns_draw_text_decoration» («k:struct» «t:glyph_string» *«t:s», «k:struct» «t:face» *«t:face»,
                         «t:NSColor» *«v:defaultCol», «t:CGFloat» «v:width», «t:CGFloat» «v:x»)
«m:/* »«x:--------------------------------------------------------------------------
   Draw underline, overline, and strike-through on glyph string s.
   -------------------------------------------------------------------------- */»
{
  «k:if» (s->for_overlaps)
    «k:return»;

  «m:/* »«x:Do underline. */»
  «k:if» (face->underline_p)
    {
      «k:if» (s->face->underline_type == FACE_UNDER_WAVE)
        {
          «k:if» (face->underline_defaulted_p)
            «:objc-font-lock-background-face:«w:[»defaultCol «f:set»«w:]»»;
          «k:else»
            «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (face->underline_color, s->f) «f:set»«w:]»»;

          ns_draw_underwave (s, width, x);
        }
      «k:else» «k:if» (s->face->underline_type == FACE_UNDER_LINE)
        {

          «t:NSRect» «v:r»;
          «t:unsigned» «t:long» thickness, position;

          «m:/* »«x:If the prev was underlined, match its appearance. */»
          «k:if» (s->prev && s->prev->face->underline_p
	      && s->prev->face->underline_type == FACE_UNDER_LINE
              && s->prev->underline_thickness > 0)
            {
              thickness = s->prev->underline_thickness;
              position = s->prev->underline_position;
            }
          «k:else»
            {
              «k:struct» «t:font» *«t:font»;
              «t:unsigned» «t:long» descent;

              font=s->font;
              descent = s->y + s->height - s->ybase;

              «m:/* »«x:Use underline thickness of font, defaulting to 1. */»
              thickness = (font && font->underline_thickness > 0)
                ? font->underline_thickness : 1;

              «m:/* »«x:Determine the offset of underlining from the baseline. */»
              «k:if» (x_underline_at_descent_line)
                position = descent - thickness;
              «k:else» «k:if» (x_use_underline_position_properties
                       && font && font->underline_position >= 0)
                position = font->underline_position;
              «k:else» «k:if» (font)
                position = lround (font->descent / 2);
              «k:else»
                position = underline_minimum_offset;

              position = max (position, underline_minimum_offset);

              «m:/* »«x:Ensure underlining is not cropped. */»
              «k:if» (descent <= position)
                {
                  position = descent - 1;
                  thickness = 1;
                }
              «k:else» «k:if» (descent < position + thickness)
                thickness = 1;
            }

          s->underline_thickness = thickness;
          s->underline_position = position;

          r = NSMakeRect (x, s->ybase + position, width, thickness);

          «k:if» (face->underline_defaulted_p)
            «:objc-font-lock-background-face:«w:[»defaultCol «f:set»«w:]»»;
          «k:else»
            «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (face->underline_color, s->f) «f:set»«w:]»»;
          «t:NSRectFill» («v:r»);
        }
    }
  «m:/* »«x:Do overline. We follow other terms in using a thickness of 1
     and ignoring overline_margin. */»
  «k:if» (face->overline_p)
    {
      «t:NSRect» «v:r»;
      r = NSMakeRect (x, s->y, width, 1);

      «k:if» (face->overline_color_defaulted_p)
        «:objc-font-lock-background-face:«w:[»defaultCol «f:set»«w:]»»;
      «k:else»
        «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (face->overline_color, s->f) «f:set»«w:]»»;
      «t:NSRectFill» («v:r»);
    }

  «m:/* »«x:Do strike-through.  We follow other terms for thickness and
     vertical position.*/»
  «k:if» (face->strike_through_p)
    {
      «t:NSRect» «v:r»;
      «t:unsigned» «t:long» dy;

      dy = lrint ((s->height - 1) / 2);
      r = NSMakeRect (x, s->y + dy, width, 1);

      «k:if» (face->strike_through_color_defaulted_p)
        «:objc-font-lock-background-face:«w:[»defaultCol «f:set»«w:]»»;
      «k:else»
        «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (face->strike_through_color, s->f) «f:set»«w:]»»;
      «t:NSRectFill» («v:r»);
    }
}

«k:static» «t:void»
«f:ns_draw_box» («t:NSRect» «v:r», «t:CGFloat» «v:thickness», «t:NSColor» *«v:col»,
             «t:char» «v:left_p», «t:char» «v:right_p»)
«m:/* »«x:--------------------------------------------------------------------------
    Draw an unfilled rect inside r, optionally leaving left and/or right open.
    Note we can't just use an NSDrawRect command, because of the possibility
    of some sides not being drawn, and because the rect will be filled.
   -------------------------------------------------------------------------- */»
{
  «t:NSRect» «v:s» = r;
  «:objc-font-lock-background-face:«w:[»col «f:set»«w:]»»;

  «m:/* »«x:top, bottom */»
  s.size.height = thickness;
  «t:NSRectFill» («v:s»);
  s.origin.y += r.size.height - thickness;
  «t:NSRectFill» («v:s»);

  s.size.height = r.size.height;
  s.origin.y = r.origin.y;

  «m:/* »«x:left, right (optional) */»
  s.size.width = thickness;
  «k:if» (left_p)
    «t:NSRectFill» («v:s»);
  «k:if» (right_p)
    {
      s.origin.x += r.size.width - thickness;
      «t:NSRectFill» («v:s»);
    }
}


«k:static» «t:void»
«f:ns_draw_relief» («t:NSRect» «v:r», «t:int» «v:thickness», «t:char» «v:raised_p»,
               «t:char» «v:top_p», «t:char» «v:bottom_p», «t:char» «v:left_p», «t:char» «v:right_p»,
               «k:struct» «t:glyph_string» *«t:s»)
«m:/* »«x:--------------------------------------------------------------------------
    Draw a relief rect inside r, optionally leaving some sides open.
    Note we can't just use an NSDrawBezel command, because of the possibility
    of some sides not being drawn, and because the rect will be filled.
   -------------------------------------------------------------------------- */»
{
  «k:static» «t:NSColor» *«v:baseCol» = «c:nil», *«v:lightCol» = «c:nil», *«v:darkCol» = «c:nil»;
  «t:NSColor» *«v:newBaseCol» = «c:nil»;
  «t:NSRect» «v:sr» = r;

  NSTRACE (ns_draw_relief);

  «m:/* »«x:set up colors */»

  «k:if» (s->face->use_box_color_for_shadows_p)
    {
      newBaseCol = ns_lookup_indexed_color (s->face->box_color, s->f);
    }
«m:/*     »«x:else if (s->first_glyph->type == IMAGE_GLYPH
	   && s->img->pixmap
   	   && !IMAGE_BACKGROUND_TRANSPARENT (s->img, s->f, 0))
       {
         newBaseCol = IMAGE_BACKGROUND  (s->img, s->f, 0);
       } */»
  «k:else»
    {
      newBaseCol = ns_lookup_indexed_color (s->face->background, s->f);
    }

  «k:if» (newBaseCol == «c:nil»)
    newBaseCol = «:objc-font-lock-background-face:«w:[»«t:NSColor» «f:grayColor»«w:]»»;

  «k:if» (newBaseCol != baseCol)  «m:/* »«x:TODO: better check */»
    {
      «:objc-font-lock-background-face:«w:[»baseCol «f:release»«w:]»»;
      baseCol = «:objc-font-lock-background-face:«w:[»newBaseCol «f:retain»«w:]»»;
      «:objc-font-lock-background-face:«w:[»lightCol «f:release»«w:]»»;
      lightCol = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»baseCol «f:highlightWithLevel»: 0.2«w:]»» «f:retain»«w:]»»;
      «:objc-font-lock-background-face:«w:[»darkCol «f:release»«w:]»»;
      darkCol = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»baseCol «f:shadowWithLevel»: 0.3«w:]»» «f:retain»«w:]»»;
    }

  «:objc-font-lock-background-face:«w:[»(raised_p ? lightCol : darkCol) «f:set»«w:]»»;

  «m:/* »«x:TODO: mitering. Using NSBezierPath doesn't work because of color switch. */»

  «m:/* »«x:top */»
  sr.size.height = thickness;
  «k:if» (top_p) «t:NSRectFill» («v:sr»);

  «m:/* »«x:left */»
  sr.size.height = r.size.height;
  sr.size.width = thickness;
  «k:if» (left_p) «t:NSRectFill» («v:sr»);

  «:objc-font-lock-background-face:«w:[»(raised_p ? darkCol : lightCol) «f:set»«w:]»»;

  «m:/* »«x:bottom */»
  sr.size.width = r.size.width;
  sr.size.height = thickness;
  sr.origin.y += r.size.height - thickness;
  «k:if» (bottom_p) «t:NSRectFill» («v:sr»);

  «m:/* »«x:right */»
  sr.size.height = r.size.height;
  sr.origin.y = r.origin.y;
  sr.size.width = thickness;
  sr.origin.x += r.size.width - thickness;
  «k:if» (right_p) «t:NSRectFill» («v:sr»);
}


«k:static» «t:void»
«f:ns_dumpglyphs_box_or_relief» («k:struct» «t:glyph_string» *«t:s»)
«m:/* »«x:--------------------------------------------------------------------------
      Function modeled after x_draw_glyph_string_box ().
      Sets up parameters for drawing.
   -------------------------------------------------------------------------- */»
{
  «t:int» «v:right_x», «v:last_x»;
  «t:char» «v:left_p», «v:right_p»;
  «k:struct» «t:glyph» *«t:last_glyph»;
  «t:NSRect» «v:r»;
  «t:int» «v:thickness»;
  «k:struct» «t:face» *«t:face»;

  «k:if» (s->hl == DRAW_MOUSE_FACE)
    {
      face = FACE_FROM_ID (s->f, MOUSE_HL_INFO (s->f)->mouse_face_face_id);
      «k:if» («n:!»face)
        face = FACE_FROM_ID (s->f, MOUSE_FACE_ID);
    }
  «k:else»
    face = s->face;

  thickness = face->box_line_width;

  NSTRACE (ns_dumpglyphs_box_or_relief);

  last_x = ((s->row->full_width_p && «n:!»s->w->pseudo_window_p)
	    ? WINDOW_RIGHT_EDGE_X (s->w)
	    : window_box_right (s->w, s->area));
  last_glyph = (s->cmp || s->img
                ? s->first_glyph : s->first_glyph + s->nchars-1);

  right_x = ((s->row->full_width_p && s->extends_to_end_of_line_p
	      ? last_x - 1 : min (last_x, s->x + s->background_width) - 1));

  left_p = (s->first_glyph->left_box_line_p
	    || (s->hl == DRAW_MOUSE_FACE
		&& (s->prev == NULL || s->prev->hl != s->hl)));
  right_p = (last_glyph->right_box_line_p
	     || (s->hl == DRAW_MOUSE_FACE
		 && (s->next == NULL || s->next->hl != s->hl)));

  r = NSMakeRect (s->x, s->y, right_x - s->x + 1, s->height);

  «m:/* »«x:TODO: Sometimes box_color is 0 and this seems wrong; should investigate. */»
  «k:if» (s->face->box == FACE_SIMPLE_BOX && s->face->box_color)
    {
      ns_draw_box (r, abs (thickness),
                   ns_lookup_indexed_color (face->box_color, s->f),
                  left_p, right_p);
    }
  «k:else»
    {
      ns_draw_relief (r, abs (thickness), s->face->box == FACE_RAISED_BOX,
                     1, 1, left_p, right_p, s);
    }
}


«k:static» «t:void»
«f:ns_maybe_dumpglyphs_background» («k:struct» «t:glyph_string» *«t:s», «t:char» «v:force_p»)
«m:/* »«x:--------------------------------------------------------------------------
      Modeled after x_draw_glyph_string_background, which draws BG in
      certain cases.  Others are left to the text rendering routine.
   -------------------------------------------------------------------------- */»
{
  NSTRACE (ns_maybe_dumpglyphs_background);

  «k:if» («n:!»s->background_filled_p«m:/* »«x:|| s->hl == DRAW_MOUSE_FACE*/»)
    {
      «t:int» «v:box_line_width» = max (s->face->box_line_width, 0);
      «k:if» (FONT_HEIGHT (s->font) < s->height - 2 * box_line_width
          || s->font_not_found_p || s->extends_to_end_of_line_p || force_p)
	{
          «k:struct» «t:face» *«t:face»;
          «k:if» (s->hl == DRAW_MOUSE_FACE)
            {
              face = FACE_FROM_ID (s->f,
				   MOUSE_HL_INFO (s->f)->mouse_face_face_id);
              «k:if» («n:!»face)
                face = FACE_FROM_ID (s->f, MOUSE_FACE_ID);
            }
          «k:else»
            face = FACE_FROM_ID (s->f, s->first_glyph->face_id);
          «k:if» («n:!»face->stipple)
            «:objc-font-lock-background-face:«w:[»(NS_FACE_BACKGROUND (face) != 0»
              «:objc-font-lock-background-face:? ns_lookup_indexed_color (NS_FACE_BACKGROUND (face), s->f)»
              «:objc-font-lock-background-face:: FRAME_BACKGROUND_COLOR (s->f)) «f:set»«w:]»»;
          «k:else»
            {
              «k:struct» «t:ns_display_info» *«t:dpyinfo» = FRAME_DISPLAY_INFO (s->f);
              «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»dpyinfo->bitmaps[face->stipple-1].img «f:stippleMask»«w:]»» «f:set»«w:]»»;
            }

          «k:if» (s->hl != DRAW_CURSOR)
            {
              «t:NSRect» «v:r» = NSMakeRect (s->x, s->y + box_line_width,
                                    s->background_width,
                                    s->height-2*box_line_width);
              «t:NSRectFill» («v:r»);
            }

	  s->background_filled_p = 1;
	}
    }
}


«k:static» «t:void»
«f:ns_dumpglyphs_image» («k:struct» «t:glyph_string» *«t:s», «t:NSRect» «v:r»)
«m:/* »«x:--------------------------------------------------------------------------
      Renders an image and associated borders.
   -------------------------------------------------------------------------- */»
{
  «t:EmacsImage» *«v:img» = s->img->pixmap;
  «t:int» «v:box_line_vwidth» = max (s->face->box_line_width, 0);
  «t:int» «v:x» = s->x, «v:y» = s->ybase - image_ascent (s->img, s->face, &s->slice);
  «t:int» «v:bg_x», «v:bg_y», «v:bg_height»;
  «t:int» «v:th»;
  «t:char» «v:raised_p»;
  «t:NSRect» «v:br»;
  «k:struct» «t:face» *«t:face»;
  «t:NSColor» *«v:tdCol»;

  NSTRACE (ns_dumpglyphs_image);

  «k:if» (s->face->box != FACE_NO_BOX
      && s->first_glyph->left_box_line_p && s->slice.x == 0)
    x += abs (s->face->box_line_width);

  bg_x = x;
  bg_y =  s->slice.y == 0 ? s->y : s->y + box_line_vwidth;
  bg_height = s->height;
  «m:/* »«x:other terms have this, but was causing problems w/tabbar mode */»
  «m:/* »«x:- 2 * box_line_vwidth; */»

  «k:if» (s->slice.x == 0) x += s->img->hmargin;
  «k:if» (s->slice.y == 0) y += s->img->vmargin;

  «m:/* »«x:Draw BG: if we need larger area than image itself cleared, do that,
     otherwise, since we composite the image under NS (instead of mucking
     with its background color), we must clear just the image area. */»
  «k:if» (s->hl == DRAW_MOUSE_FACE)
    {
      face = FACE_FROM_ID (s->f, MOUSE_HL_INFO (s->f)->mouse_face_face_id);
      «k:if» («n:!»face)
       face = FACE_FROM_ID (s->f, MOUSE_FACE_ID);
    }
  «k:else»
    face = FACE_FROM_ID (s->f, s->first_glyph->face_id);

  «:objc-font-lock-background-face:«w:[»ns_lookup_indexed_color (NS_FACE_BACKGROUND (face), s->f) «f:set»«w:]»»;

  «k:if» (bg_height > s->slice.height || s->img->hmargin || s->img->vmargin
      || s->img->mask || s->img->pixmap == 0 || s->width != s->background_width)
    {
      br = NSMakeRect (bg_x, bg_y, s->background_width, bg_height);
      s->background_filled_p = 1;
    }
  «k:else»
    {
      br = NSMakeRect (x, y, s->slice.width, s->slice.height);
    }

  «t:NSRectFill» («v:br»);

  «m:/* »«x:Draw the image.. do we need to draw placeholder if img ==nil? */»
  «k:if» (img != «c:nil»)
    {
«p:#if» «p:defined» (NS_IMPL_COCOA) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
      «t:NSRect» «v:dr» = NSMakeRect (x, y, s->slice.width, s->slice.height);
      «t:NSRect» «v:ir» = NSMakeRect (s->slice.x, s->slice.y,
                              s->slice.width, s->slice.height);
      «:objc-font-lock-background-face:«w:[»img «f:drawInRect»: dr»
             «:objc-font-lock-background-face:«f:fromRect»: ir»
             «:objc-font-lock-background-face:«f:operation»: NSCompositeSourceOver»
              «:objc-font-lock-background-face:«f:fraction»: 1.0»
           «:objc-font-lock-background-face:«f:respectFlipped»: «c:YES»»
                «:objc-font-lock-background-face:«f:hints»: «c:nil»«w:]»»;
«p:#else»
      «:objc-font-lock-background-face:«w:[»img «f:compositeToPoint»: NSMakePoint (x, y + s->slice.height)»
                  «:objc-font-lock-background-face:«f:operation»: NSCompositeSourceOver«w:]»»;
«p:#endif»
    }

  «k:if» (s->hl == DRAW_CURSOR)
    {
    «:objc-font-lock-background-face:«w:[»FRAME_CURSOR_COLOR (s->f) «f:set»«w:]»»;
    «k:if» (s->w->phys_cursor_type == FILLED_BOX_CURSOR)
      tdCol = ns_lookup_indexed_color (NS_FACE_BACKGROUND (face), s->f);
    «k:else»
      «m:/* »«x:Currently on NS img->mask is always 0. Since
         get_window_cursor_type specifies a hollow box cursor when on
         a non-masked image we never reach this clause. But we put it
         in in anticipation of better support for image masks on
         NS. */»
      tdCol = ns_lookup_indexed_color (NS_FACE_FOREGROUND (face), s->f);
    }
  «k:else»
    {
      tdCol = ns_lookup_indexed_color (NS_FACE_FOREGROUND (face), s->f);
    }

  «m:/* »«x:Draw underline, overline, strike-through. */»
  ns_draw_text_decoration (s, face, tdCol, br.size.width, br.origin.x);

  «m:/* »«x:Draw relief, if requested */»
  «k:if» (s->img->relief || s->hl ==DRAW_IMAGE_RAISED || s->hl ==DRAW_IMAGE_SUNKEN)
    {
      «k:if» (s->hl == DRAW_IMAGE_SUNKEN || s->hl == DRAW_IMAGE_RAISED)
        {
          th = tool_bar_button_relief >= 0 ?
            tool_bar_button_relief : DEFAULT_TOOL_BAR_BUTTON_RELIEF;
          raised_p = (s->hl == DRAW_IMAGE_RAISED);
        }
      «k:else»
        {
          th = abs (s->img->relief);
          raised_p = (s->img->relief > 0);
        }

      r.origin.x = x - th;
      r.origin.y = y - th;
      r.size.width = s->slice.width + 2*th-1;
      r.size.height = s->slice.height + 2*th-1;
      ns_draw_relief (r, th, raised_p,
                      s->slice.y == 0,
                      s->slice.y + s->slice.height == s->img->height,
                      s->slice.x == 0,
                      s->slice.x + s->slice.width == s->img->width, s);
    }

  «m:/* »«x:If there is no mask, the background won't be seen,
     so draw a rectangle on the image for the cursor.
     Do this for all images, getting transparency right is not reliable.  */»
  «k:if» (s->hl == DRAW_CURSOR)
    {
      «t:int» «v:thickness» = abs (s->img->relief);
      «k:if» (thickness == 0) thickness = 1;
      ns_draw_box (br, thickness, FRAME_CURSOR_COLOR (s->f), 1, 1);
    }
}


«k:static» «t:void»
«f:ns_dumpglyphs_stretch» («k:struct» «t:glyph_string» *«t:s»)
{
  «t:NSRect» «v:r»[2];
  «t:int» «v:n», «v:i»;
  «k:struct» «t:face» *«t:face»;
  «t:NSColor» *«v:fgCol», *«v:bgCol»;

  «k:if» («n:!»s->background_filled_p)
    {
      n = ns_get_glyph_string_clip_rect (s, r);
      *r = NSMakeRect (s->x, s->y, s->background_width, s->height);

      ns_focus (s->f, r, n);

      «k:if» (s->hl == DRAW_MOUSE_FACE)
       {
         face = FACE_FROM_ID (s->f, MOUSE_HL_INFO (s->f)->mouse_face_face_id);
         «k:if» («n:!»face)
           face = FACE_FROM_ID (s->f, MOUSE_FACE_ID);
       }
      «k:else»
       face = FACE_FROM_ID (s->f, s->first_glyph->face_id);

      bgCol = ns_lookup_indexed_color (NS_FACE_BACKGROUND (face), s->f);
      fgCol = ns_lookup_indexed_color (NS_FACE_FOREGROUND (face), s->f);

      «k:for» (i = 0; i < n; ++i)
        {
          «k:if» («n:!»s->row->full_width_p)
            {
	      «t:int» «v:overrun», «v:leftoverrun»;

              «m:/* »«x:truncate to avoid overwriting fringe and/or scrollbar */»
	      overrun = max (0, (s->x + s->background_width)
			     - («t:WINDOW_BOX_RIGHT_EDGE_X» (s->w)
				- «f:WINDOW_RIGHT_FRINGE_WIDTH» (s->w)));
              r[i].size.width -= overrun;

	      «m:/* »«x:truncate to avoid overwriting to left of the window box */»
	      leftoverrun = (WINDOW_BOX_LEFT_EDGE_X (s->w)
			     + «f:WINDOW_LEFT_FRINGE_WIDTH» (s->w)) - «f:s»->x;

	      «k:if» (leftoverrun > 0)
		{
		  r[i].origin.x += leftoverrun;
		  r[i].size.width -= leftoverrun;
		}

              «m:/* »«x:XXX: Try to work between problem where a stretch glyph on
                 a partially-visible bottom row will clear part of the
                 modeline, and another where list-buffers headers and similar
                 rows erroneously have visible_height set to 0.  Not sure
                 where this is coming from as other terms seem not to show. */»
              r[i].size.height = min (s->height, s->row->visible_height);
            }

          «:objc-font-lock-background-face:«w:[»bgCol «f:set»«w:]»»;

          «m:/* »«x:NOTE: under NS this is NOT used to draw cursors, but we must avoid
             overwriting cursor (usually when cursor on a tab) */»
          «k:if» (s->hl == DRAW_CURSOR)
            {
              «t:CGFloat» «v:x», «v:width»;

              x = r[i].origin.x;
              width = s->w->phys_cursor_width;
              r[i].size.width -= width;
              r[i].origin.x += width;

              «t:NSRectFill» («v:r»[i]);

              «m:/* »«x:Draw overlining, etc. on the cursor. */»
              «k:if» (s->w->phys_cursor_type == FILLED_BOX_CURSOR)
                ns_draw_text_decoration (s, face, bgCol, width, x);
              «k:else»
                ns_draw_text_decoration (s, face, fgCol, width, x);
            }
          «k:else»
            {
              «t:NSRectFill» («v:r»[i]);
            }

          «m:/* »«x:Draw overlining, etc. on the stretch glyph (or the part
             of the stretch glyph after the cursor). */»
          ns_draw_text_decoration (s, face, fgCol, r[i].size.width,
                                   r[i].origin.x);
        }
      ns_unfocus (s->f);
      s->background_filled_p = 1;
    }
}


«k:static» «t:void»
«f:ns_draw_glyph_string» («k:struct» «t:glyph_string» *«t:s»)
«m:/* »«x:--------------------------------------------------------------------------
      External (RIF): Main draw-text call.
   -------------------------------------------------------------------------- */»
{
  «m:/* »«x:TODO (optimize): focus for box and contents draw */»
  «t:NSRect» «v:r»[2];
  «t:int» «v:n», «v:flags»;
  «t:char» «v:box_drawn_p» = 0;
  «k:struct» «t:font» *«t:font» = s->face->font;
  «k:if» («n:!» font) font = FRAME_FONT (s->f);

  NSTRACE (ns_draw_glyph_string);

  «k:if» (s->next && s->right_overhang && «n:!»s->for_overlaps«m:/*»«x:&&s->hl!=DRAW_CURSOR*/»)
    {
      «t:int» «v:width»;
      «k:struct» «t:glyph_string» *«t:next»;

      «k:for» (width = 0, next = s->next;
	   next && width < s->right_overhang;
	   width += next->width, next = next->next)
	«k:if» (next->first_glyph->type != IMAGE_GLYPH)
          {
            «k:if» (next->first_glyph->type != STRETCH_GLYPH)
              {
                n = ns_get_glyph_string_clip_rect (s->next, r);
                ns_focus (s->f, r, n);
                ns_maybe_dumpglyphs_background (s->next, 1);
                ns_unfocus (s->f);
              }
            «k:else»
              {
                ns_dumpglyphs_stretch (s->next);
              }
            next->num_clips = 0;
          }
    }

  «k:if» («n:!»s->for_overlaps && s->face->box != FACE_NO_BOX
        && (s->first_glyph->type == CHAR_GLYPH
	    || s->first_glyph->type == COMPOSITE_GLYPH))
    {
      n = ns_get_glyph_string_clip_rect (s, r);
      ns_focus (s->f, r, n);
      ns_maybe_dumpglyphs_background (s, 1);
      ns_dumpglyphs_box_or_relief (s);
      ns_unfocus (s->f);
      box_drawn_p = 1;
    }

  «k:switch» (s->first_glyph->type)
    {

    «k:case» IMAGE_GLYPH:
      n = ns_get_glyph_string_clip_rect (s, r);
      ns_focus (s->f, r, n);
      ns_dumpglyphs_image (s, r[0]);
      ns_unfocus (s->f);
      «k:break»;

    «k:case» STRETCH_GLYPH:
      ns_dumpglyphs_stretch (s);
      «k:break»;

    «k:case» CHAR_GLYPH:
    «k:case» COMPOSITE_GLYPH:
      n = ns_get_glyph_string_clip_rect (s, r);
      ns_focus (s->f, r, n);

      «k:if» (s->for_overlaps || (s->cmp_from > 0
			      && «n:!» s->first_glyph->u.cmp.automatic))
        s->background_filled_p = 1;
      «k:else»
        ns_maybe_dumpglyphs_background
          (s, s->first_glyph->type == COMPOSITE_GLYPH);

      flags = s->hl == DRAW_CURSOR ? NS_DUMPGLYPH_CURSOR :
        (s->hl == DRAW_MOUSE_FACE ? NS_DUMPGLYPH_MOUSEFACE :
         (s->for_overlaps ? NS_DUMPGLYPH_FOREGROUND :
          NS_DUMPGLYPH_NORMAL));

      «k:if» (s->hl == DRAW_CURSOR && s->w->phys_cursor_type == FILLED_BOX_CURSOR)
        {
          «t:unsigned» «t:long» tmp = NS_FACE_BACKGROUND (s->face);
          NS_FACE_BACKGROUND (s->face) = NS_FACE_FOREGROUND (s->face);
          NS_FACE_FOREGROUND (s->face) = tmp;
        }

      font->driver->draw
        (s, 0, s->nchars, s->x, s->y,
         (flags == NS_DUMPGLYPH_NORMAL && «n:!»s->background_filled_p)
         || flags == NS_DUMPGLYPH_MOUSEFACE);

      {
        «t:NSColor» *«v:col» = (NS_FACE_FOREGROUND (s->face) != 0
                        ? ns_lookup_indexed_color (NS_FACE_FOREGROUND (s->face),
                                                   s->f)
                        : FRAME_FOREGROUND_COLOR (s->f));
        «:objc-font-lock-background-face:«w:[»col «f:set»«w:]»»;

        «m:/* »«x:Draw underline, overline, strike-through. */»
        ns_draw_text_decoration (s, s->face, col, s->width, s->x);
      }

      «k:if» (s->hl == DRAW_CURSOR && s->w->phys_cursor_type == FILLED_BOX_CURSOR)
        {
          «t:unsigned» «t:long» tmp = NS_FACE_BACKGROUND (s->face);
          NS_FACE_BACKGROUND (s->face) = NS_FACE_FOREGROUND (s->face);
          NS_FACE_FOREGROUND (s->face) = tmp;
        }

      ns_unfocus (s->f);
      «k:break»;

    «k:case» GLYPHLESS_GLYPH:
      n = ns_get_glyph_string_clip_rect (s, r);
      ns_focus (s->f, r, n);

      «k:if» (s->for_overlaps || (s->cmp_from > 0
			      && «n:!» s->first_glyph->u.cmp.automatic))
        s->background_filled_p = 1;
      «k:else»
        ns_maybe_dumpglyphs_background
          (s, s->first_glyph->type == COMPOSITE_GLYPH);
      «m:/* »«x:... */»
      «m:/* »«x:Not yet implemented.  */»
      «m:/* »«x:... */»
      ns_unfocus (s->f);
      «k:break»;

    «k:default»:
      emacs_abort ();
    }

  «m:/* »«x:Draw box if not done already. */»
  «k:if» («n:!»s->for_overlaps && «n:!»box_drawn_p && s->face->box != FACE_NO_BOX)
    {
      n = ns_get_glyph_string_clip_rect (s, r);
      ns_focus (s->f, r, n);
      ns_dumpglyphs_box_or_relief (s);
      ns_unfocus (s->f);
    }

  s->num_clips = 0;
}



«m:/* »«x:==========================================================================

    Event loop

   ========================================================================== */»


«k:static» «t:void»
«f:ns_send_appdefined» («t:int» «v:value»)
«m:/* »«x:--------------------------------------------------------------------------
    Internal: post an appdefined event which EmacsApp-sendEvent will
              recognize and take as a command to halt the event loop.
   -------------------------------------------------------------------------- */»
{
  «m:/*»«x:NSTRACE (ns_send_appdefined); */»

«p:#ifdef» NS_IMPL_GNUSTEP
  «m:// »«x:GNUStep needs postEvent to happen on the main thread.
»  «k:if» («n:!» «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSThread» «f:currentThread»«w:]»» «f:isMainThread»«w:]»»)
    {
      «t:EmacsApp» *«v:app» = («t:EmacsApp» *)NSApp;
      app->nextappdefined = value;
      «:objc-font-lock-background-face:«w:[»app «f:performSelectorOnMainThread»:«k:@selector» (sendFromMainThread:)»
                            «:objc-font-lock-background-face:«f:withObject»:«c:nil»»
                         «:objc-font-lock-background-face:«f:waitUntilDone»:«c:YES»«w:]»»;
      «k:return»;
    }
«p:#endif»

  «m:/* »«x:Only post this event if we haven't already posted one.  This will end
       the [NXApp run] main loop after having processed all events queued at
       this moment.  */»
  «k:if» (send_appdefined)
    {
      «t:NSEvent» *«v:nxev»;

      «m:/* »«x:We only need one NX_APPDEFINED event to stop NXApp from running.  */»
      send_appdefined = «c:NO»;

      «m:/* »«x:Don't need wakeup timer any more */»
      «k:if» (timed_entry)
        {
          «:objc-font-lock-background-face:«w:[»timed_entry «f:invalidate»«w:]»»;
          «:objc-font-lock-background-face:«w:[»timed_entry «f:release»«w:]»»;
          timed_entry = «c:nil»;
        }

      nxev = «:objc-font-lock-background-face:«w:[»«t:NSEvent» «f:otherEventWithType»: NSApplicationDefined»
                                «:objc-font-lock-background-face:«f:location»: NSMakePoint (0, 0)»
                           «:objc-font-lock-background-face:«f:modifierFlags»: 0»
                               «:objc-font-lock-background-face:«f:timestamp»: 0»
                            «:objc-font-lock-background-face:«f:windowNumber»: «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSApp» «f:mainWindow»«w:]»» «f:windowNumber»«w:]»»»
                                 «:objc-font-lock-background-face:«f:context»: «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:context»«w:]»»»
                                 «:objc-font-lock-background-face:«f:subtype»: 0»
                                   «:objc-font-lock-background-face:«f:data1»: value»
                                   «:objc-font-lock-background-face:«f:data2»: 0«w:]»»;

      «m:/* »«x:Post an application defined event on the event queue.  When this is
         received the [NXApp run] will return, thus having processed all
         events which are currently queued.  */»
      «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:postEvent»: nxev «f:atStart»: «c:NO»«w:]»»;
    }
}

«p:#ifdef» HAVE_NATIVE_FS
«k:static» «t:void»
«f:check_native_fs» ()
{
  «t:Lisp_Object» «v:frame», «v:tail»;

  «k:if» (ns_last_use_native_fullscreen == ns_use_native_fullscreen)
    «k:return»;

  ns_last_use_native_fullscreen = ns_use_native_fullscreen;

  «v:FOR_EACH_FRAME» («t:tail», «t:frame»)
    {
      «k:struct» «t:frame» *«t:f» = XFRAME (frame);
      «k:if» (FRAME_NS_P (f))
        {
          «t:EmacsView» *«v:view» = FRAME_NS_VIEW (f);
          «:objc-font-lock-background-face:«w:[»view «f:updateCollectionBehavior»«w:]»»;
        }
    }
}
«p:#endif»

«m:/* »«x:GNUStep and OSX <= 10.4 does not have cancelTracking.  */»
«p:#if» «p:defined» (NS_IMPL_COCOA) && \
  MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
«m:/* »«x:Check if menu open should be canceled or continued as normal.  */»
«t:void»
«f:ns_check_menu_open» («t:NSMenu» *«v:menu»)
{
  «m:/* »«x:Click in menu bar? */»
  «t:NSArray» *«v:a» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSApp» «f:mainMenu»«w:]»» «f:itemArray»«w:]»»;
  «t:int» «v:i»;
  «t:BOOL» «v:found» = «c:NO»;

  «k:if» (menu == «c:nil») «m:// »«x:Menu tracking ended.
»    {
      «k:if» (menu_will_open_state == MENU_OPENING)
        menu_will_open_state = MENU_NONE;
      «k:return»;
    }

  «k:for» (i = 0; «n:!» found && i < «:objc-font-lock-background-face:«w:[»a «f:count»«w:]»»; i++)
    found = menu == «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»a «f:objectAtIndex»:i«w:]»» «f:submenu»«w:]»»;
  «k:if» (found)
    {
      «k:if» (menu_will_open_state == MENU_NONE && emacs_event)
        {
          «t:NSEvent» *«v:theEvent» = «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:currentEvent»«w:]»»;
          «k:struct» «t:frame» *«t:emacsframe» = SELECTED_FRAME ();

          «:objc-font-lock-background-face:«w:[»menu «f:cancelTracking»«w:]»»;
          menu_will_open_state = MENU_PENDING;
          emacs_event->kind = MENU_BAR_ACTIVATE_EVENT;
          EV_TRAILER (theEvent);

          «t:CGEventRef» «v:ourEvent» = CGEventCreate (NULL);
          menu_mouse_point = CGEventGetLocation (ourEvent);
          «t:CFRelease» («v:ourEvent»);
        }
      «k:else» «k:if» (menu_will_open_state == MENU_OPENING)
        {
          menu_will_open_state = MENU_NONE;
        }
    }
}

«m:/* »«x:Redo saved menu click if state is MENU_PENDING.  */»
«t:void»
«f:ns_check_pending_open_menu» ()
{
  «k:if» (menu_will_open_state == MENU_PENDING)
    {
      «t:CGEventSourceRef» «v:source»
        = CGEventSourceCreate (kCGEventSourceStateHIDSystemState);

      «t:CGEventRef» «v:event» = CGEventCreateMouseEvent (source,
                                                  kCGEventLeftMouseDown,
                                                  menu_mouse_point,
                                                  kCGMouseButtonLeft);
      CGEventSetType («v:event», kCGEventLeftMouseDown);
      CGEventPost (kCGHIDEventTap, event);
      «t:CFRelease» («v:event»);
      «t:CFRelease» («v:source»);

      menu_will_open_state = MENU_OPENING;
    }
}
«p:#endif» «m:/* »«x:NS_IMPL_COCOA) && >= MAC_OS_X_VERSION_10_5 */»

«k:static» «t:int»
«f:ns_read_socket» («k:struct» «t:terminal» *«t:terminal», «k:struct» «t:input_event» *«t:hold_quit»)
«m:/* »«x:--------------------------------------------------------------------------
     External (hook): Post an event to ourself and keep reading events until
     we read it back again.  In effect process all events which were waiting.
     From 21+ we have to manage the event buffer ourselves.
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:input_event» «t:ev»;
  «t:int» «v:nevents»;

«m:/* »«x:NSTRACE (ns_read_socket); */»

«p:#ifdef» HAVE_NATIVE_FS
  check_native_fs ();
«p:#endif»

  «k:if» («:objc-font-lock-background-face:«w:[»«t:NSApp» «f:modalWindow»«w:]»» != «c:nil»)
    «k:return» -1;

  «k:if» (hold_event_q.nr > 0)
    {
      «t:int» «v:i»;
      «k:for» (i = 0; i < hold_event_q.nr; ++i)
        kbd_buffer_store_event_hold (&hold_event_q.q[i], hold_quit);
      hold_event_q.nr = 0;
      «k:return» i;
    }

  block_input ();
  n_emacs_events_pending = 0;
  EVENT_INIT (ev);
  emacs_event = &ev;
  q_event_ptr = hold_quit;

  «m:/* »«x:we manage autorelease pools by allocate/reallocate each time around
     the loop; strict nesting is occasionally violated but seems not to
     matter.. earlier methods using full nesting caused major memory leaks */»
  «:objc-font-lock-background-face:«w:[»outerpool «f:release»«w:]»»;
  outerpool = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSAutoreleasePool» «f:alloc»«w:]»» «f:init»«w:]»»;

  «m:/* »«x:If have pending open-file requests, attend to the next one of those. */»
  «k:if» (ns_pending_files && «:objc-font-lock-background-face:«w:[»ns_pending_files «f:count»«w:]»» != 0
      && «:objc-font-lock-background-face:«w:[»(«t:EmacsApp» *)«t:NSApp» «f:openFile»: «:objc-font-lock-background-face:«w:[»ns_pending_files «f:objectAtIndex»: 0«w:]»»«w:]»»)
    {
      «:objc-font-lock-background-face:«w:[»ns_pending_files «f:removeObjectAtIndex»: 0«w:]»»;
    }
  «m:/* »«x:Deal with pending service requests. */»
  «k:else» «k:if» (ns_pending_service_names && «:objc-font-lock-background-face:«w:[»ns_pending_service_names «f:count»«w:]»» != 0
    && «:objc-font-lock-background-face:«w:[»(«t:EmacsApp» *)»
         «:objc-font-lock-background-face:«t:NSApp» «f:fulfillService»: «:objc-font-lock-background-face:«w:[»ns_pending_service_names «f:objectAtIndex»: 0«w:]»»»
                      «:objc-font-lock-background-face:«f:withArg»: «:objc-font-lock-background-face:«w:[»ns_pending_service_args «f:objectAtIndex»: 0«w:]»»«w:]»»)
    {
      «:objc-font-lock-background-face:«w:[»ns_pending_service_names «f:removeObjectAtIndex»: 0«w:]»»;
      «:objc-font-lock-background-face:«w:[»ns_pending_service_args «f:removeObjectAtIndex»: 0«w:]»»;
    }
  «k:else»
    {
      «m:/* »«x:Run and wait for events.  We must always send one NX_APPDEFINED event
         to ourself, otherwise [NXApp run] will never exit.  */»
      send_appdefined = «c:YES»;
      ns_send_appdefined (-1);

      «k:if» (++apploopnr != 1)
        {
          emacs_abort ();
        }
      «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:run»«w:]»»;
      --apploopnr;
    }

  nevents = n_emacs_events_pending;
  n_emacs_events_pending = 0;
  emacs_event = q_event_ptr = NULL;
  unblock_input ();

  «k:return» nevents;
}


«t:int»
«f:ns_select» («t:int» «v:nfds», «t:fd_set» *«v:readfds», «t:fd_set» *«v:writefds»,
	   «t:fd_set» *«v:exceptfds», «k:struct» timespec «k:const» *«t:timeout»,
	   sigset_t «k:const» *«v:sigmask»)
«m:/* »«x:--------------------------------------------------------------------------
     Replacement for select, checking for events
   -------------------------------------------------------------------------- */»
{
  «t:int» «v:result»;
  «t:int» «v:t», «v:k», «v:nr» = 0;
  «k:struct» «t:input_event» «t:event»;
  «t:char» «v:c»;

«m:/*  »«x:NSTRACE (ns_select); */»

«p:#ifdef» HAVE_NATIVE_FS
  check_native_fs ();
«p:#endif»

  «k:if» (hold_event_q.nr > 0)
    {
      «m:/* »«x:We already have events pending. */»
      raise (SIGIO);
      errno = EINTR;
      «k:return» -1;
    }

  «k:for» (k = 0; k < nfds+1; k++)
    {
      «k:if» (readfds && FD_ISSET(k, readfds)) ++nr;
      «k:if» (writefds && FD_ISSET(k, writefds)) ++nr;
    }

  «k:if» (NSApp == «c:nil»
      || (timeout && timeout->tv_sec == 0 && timeout->tv_nsec == 0))
    «k:return» pselect (nfds, readfds, writefds, exceptfds, timeout, sigmask);

  «:objc-font-lock-background-face:«w:[»outerpool «f:release»«w:]»»;
  outerpool = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSAutoreleasePool» «f:alloc»«w:]»» «f:init»«w:]»»;


  send_appdefined = «c:YES»;
  «k:if» (nr > 0)
    {
      pthread_mutex_lock (&select_mutex);
      select_nfds = nfds;
      select_valid = 0;
      «k:if» (readfds)
        {
          select_readfds = *readfds;
          select_valid += SELECT_HAVE_READ;
        }
      «k:if» (writefds)
        {
          select_writefds = *writefds;
          select_valid += SELECT_HAVE_WRITE;
        }

      «k:if» (timeout)
        {
          select_timeout = *timeout;
          select_valid += SELECT_HAVE_TMO;
        }

      pthread_mutex_unlock (&select_mutex);

      «m:/* »«x:Inform fd_handler that select should be called */»
      c = «s:'g'»;
      emacs_write_sig (selfds[1], &c, 1);
    }
  «k:else» «k:if» (nr == 0 && timeout)
    {
      «m:/* »«x:No file descriptor, just a timeout, no need to wake fd_handler  */»
      «t:double» «v:time» = timespectod (*timeout);
      timed_entry = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSTimer» «f:scheduledTimerWithTimeInterval»: time»»
                                                      «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:target»: NSApp»»
                                                    «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:selector»:»»
                                  «:objc-font-lock-background-face:«:objc-font-lock-background-face:«k:@selector» (timeout_handler:)»»
                                                    «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:userInfo»: 0»»
                                                     «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:repeats»: «c:NO»«w:]»»»
                      «:objc-font-lock-background-face:«f:retain»«w:]»»;
    }
  «k:else» «m:/* »«x:No timeout and no file descriptors, can this happen?  */»
    {
      «m:/* »«x:Send appdefined so we exit from the loop */»
      ns_send_appdefined (-1);
    }

  EVENT_INIT (event);
  block_input ();
  emacs_event = &event;
  «k:if» (++apploopnr != 1)
    {
      emacs_abort ();
    }
  «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:run»«w:]»»;
  --apploopnr;
  emacs_event = NULL;
  «k:if» (nr > 0 && readfds)
    {
      c = «s:'s'»;
      emacs_write_sig (selfds[1], &c, 1);
    }
  unblock_input ();

  t = last_appdefined_event_data;

  «k:if» (t != NO_APPDEFINED_DATA)
    {
      last_appdefined_event_data = NO_APPDEFINED_DATA;

      «k:if» (t == -2)
        {
          «m:/* »«x:The NX_APPDEFINED event we received was a timeout. */»
          result = 0;
        }
      «k:else» «k:if» (t == -1)
        {
          «m:/* »«x:The NX_APPDEFINED event we received was the result of
             at least one real input event arriving.  */»
          errno = EINTR;
          result = -1;
        }
      «k:else»
        {
          «m:/* »«x:Received back from select () in fd_handler; copy the results */»
          pthread_mutex_lock (&select_mutex);
          «k:if» (readfds) *readfds = select_readfds;
          «k:if» (writefds) *writefds = select_writefds;
          pthread_mutex_unlock (&select_mutex);
          result = t;
        }
    }
  «k:else»
    {
      errno = EINTR;
      result = -1;
    }

  «k:return» result;
}



«m:/* »«x:==========================================================================

    Scrollbar handling

   ========================================================================== */»


«k:static» «t:void»
«f:ns_set_vertical_scroll_bar» («k:struct» «t:window» *«t:window»,
                           «t:int» «v:portion», «t:int» «v:whole», «t:int» «v:position»)
«m:/* »«x:--------------------------------------------------------------------------
      External (hook): Update or add scrollbar
   -------------------------------------------------------------------------- */»
{
  «t:Lisp_Object» «v:win»;
  «t:NSRect» «v:r», «v:v»;
  «k:struct» «t:frame» *«t:f» = XFRAME (WINDOW_FRAME (window));
  «t:EmacsView» *«v:view» = FRAME_NS_VIEW (f);
  «t:int» «v:window_y», «v:window_height»;
  «t:int» «v:top», «v:left», «v:height», «v:width», «v:sb_width», «v:sb_left»;
  «t:EmacsScroller» *«v:bar»;
  «t:BOOL» «v:fringe_extended_p»;

  «m:/* »«x:optimization; display engine sends WAY too many of these.. */»
  «k:if» («n:!»NILP (window->vertical_scroll_bar))
    {
      bar = XNS_SCROLL_BAR (window->vertical_scroll_bar);
      «k:if» («:objc-font-lock-background-face:«w:[»bar «f:checkSamePosition»: position «f:portion»: portion «f:whole»: whole«w:]»»)
        {
          «k:if» (view->scrollbarsNeedingUpdate == 0)
            {
              «k:if» («n:!»windows_or_buffers_changed)
                  «k:return»;
            }
          «k:else»
            view->scrollbarsNeedingUpdate--;
        }
    }

  NSTRACE (ns_set_vertical_scroll_bar);

  «m:/* »«x:Get dimensions.  */»
  window_box (window, ANY_AREA, 0, &window_y, 0, &window_height);
  top = window_y;
  height = window_height;
  width = WINDOW_CONFIG_SCROLL_BAR_COLS (window) * FRAME_COLUMN_WIDTH (f);
  left = WINDOW_SCROLL_BAR_AREA_X (window);

  «m:/* »«x:allow for displaying a skinnier scrollbar than char area allotted */»
  sb_width = (WINDOW_CONFIG_SCROLL_BAR_WIDTH (window) > 0) ?
    WINDOW_CONFIG_SCROLL_BAR_WIDTH (window) : width;
  sb_left = left;

  r = NSMakeRect (sb_left, top, sb_width, height);
  «m:/* »«x:the parent view is flipped, so we need to flip y value */»
  v = «:objc-font-lock-background-face:«w:[»view «f:frame»«w:]»»;
  r.origin.y = (v.size.height - r.size.height - r.origin.y);

  fringe_extended_p = WINDOW_FRINGE_EXTENDED_P (window);

  XSETWINDOW (win, window);
  block_input ();

  «m:/* »«x:we want at least 5 lines to display a scrollbar */»
  «k:if» (WINDOW_TOTAL_LINES (window) < 5)
    {
      «k:if» («n:!»NILP (window->vertical_scroll_bar))
        {
          bar = XNS_SCROLL_BAR (window->vertical_scroll_bar);
          «:objc-font-lock-background-face:«w:[»bar «f:removeFromSuperview»«w:]»»;
          wset_vertical_scroll_bar (window, Qnil);
        }
      ns_clear_frame_area (f, sb_left, top, width, height);
      unblock_input ();
      «k:return»;
    }

  «k:if» (NILP (window->vertical_scroll_bar))
    {
      «k:if» (width > 0 && height > 0)
	{
	  «k:if» (fringe_extended_p)
	    ns_clear_frame_area (f, sb_left, top, sb_width, height);
	  «k:else»
	    ns_clear_frame_area (f, left, top, width, height);
        }

      bar = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsScroller» «f:alloc»«w:]»» «f:initFrame»: r «f:window»: win«w:]»»;
      wset_vertical_scroll_bar (window, make_save_ptr (bar));
    }
  «k:else»
    {
      «t:NSRect» «v:oldRect»;
      bar = XNS_SCROLL_BAR (window->vertical_scroll_bar);
      oldRect = «:objc-font-lock-background-face:«w:[»bar «f:frame»«w:]»»;
      r.size.width = oldRect.size.width;
      «k:if» (FRAME_LIVE_P (f) && «n:!»NSEqualRects (oldRect, r))
        {
          «k:if» (oldRect.origin.x != r.origin.x)
              ns_clear_frame_area (f, sb_left, top, width, height);
          «:objc-font-lock-background-face:«w:[»bar «f:setFrame»: r«w:]»»;
        }
    }

  «:objc-font-lock-background-face:«w:[»bar «f:setPosition»: position «f:portion»: portion «f:whole»: whole«w:]»»;
  unblock_input ();
}


«k:static» «t:void»
«f:ns_condemn_scroll_bars» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     External (hook): arrange for all frame's scrollbars to be removed
     at next call to judge_scroll_bars, except for those redeemed.
   -------------------------------------------------------------------------- */»
{
  «t:int» «v:i»;
  «t:id» «v:view»;
  «t:NSArray» *«v:subviews» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»FRAME_NS_VIEW (f) «f:superview»«w:]»» «f:subviews»«w:]»»;

  NSTRACE (ns_condemn_scroll_bars);

  «k:for» (i =«:objc-font-lock-background-face:«w:[»subviews «f:count»«w:]»»-1; i >= 0; i--)
    {
      view = «:objc-font-lock-background-face:«w:[»subviews «f:objectAtIndex»: i«w:]»»;
      «k:if» («:objc-font-lock-background-face:«w:[»view «f:isKindOfClass»: «:objc-font-lock-background-face:«w:[»«t:EmacsScroller» «f:class»«w:]»»«w:]»»)
        «:objc-font-lock-background-face:«w:[»view «f:condemn»«w:]»»;
    }
}


«k:static» «t:void»
«f:ns_redeem_scroll_bar» («k:struct» «t:window» *«t:window»)
«m:/* »«x:--------------------------------------------------------------------------
     External (hook): arrange to spare this window's scrollbar
     at next call to judge_scroll_bars.
   -------------------------------------------------------------------------- */»
{
  «t:id» «v:bar»;
  NSTRACE (ns_redeem_scroll_bar);
  «k:if» («n:!»NILP (window->vertical_scroll_bar))
    {
      bar = XNS_SCROLL_BAR (window->vertical_scroll_bar);
      «:objc-font-lock-background-face:«w:[»bar «f:reprieve»«w:]»»;
    }
}


«k:static» «t:void»
«f:ns_judge_scroll_bars» («k:struct» «t:frame» *«t:f»)
«m:/* »«x:--------------------------------------------------------------------------
     External (hook): destroy all scrollbars on frame that weren't
     redeemed after call to condemn_scroll_bars.
   -------------------------------------------------------------------------- */»
{
  «t:int» «v:i»;
  «t:id» «v:view»;
  «t:EmacsView» *«v:eview» = FRAME_NS_VIEW (f);
  «t:NSArray» *«v:subviews» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»eview «f:superview»«w:]»» «f:subviews»«w:]»»;
  «t:BOOL» «v:removed» = «c:NO»;

  NSTRACE (ns_judge_scroll_bars);
  «k:for» (i = «:objc-font-lock-background-face:«w:[»subviews «f:count»«w:]»»-1; i >= 0; --i)
    {
      view = «:objc-font-lock-background-face:«w:[»subviews «f:objectAtIndex»: i«w:]»»;
      «k:if» («n:!»«:objc-font-lock-background-face:«w:[»view «f:isKindOfClass»: «:objc-font-lock-background-face:«w:[»«t:EmacsScroller» «f:class»«w:]»»«w:]»») «k:continue»;
      «:objc-font-lock-background-face:«w:[»view «f:judge»«w:]»»;
      removed = «c:YES»;
    }

  «k:if» (removed)
    «:objc-font-lock-background-face:«w:[»eview «f:updateFrameSize»: «c:NO»«w:]»»;
}

«m:/* »«x:==========================================================================

    Initialization

   ========================================================================== */»

«t:int»
«f:x_display_pixel_height» («k:struct» «t:ns_display_info» *«t:dpyinfo»)
{
  «t:NSArray» *«v:screens» = «:objc-font-lock-background-face:«w:[»«t:NSScreen» «f:screens»«w:]»»;
  «t:NSEnumerator» *«v:enumerator» = «:objc-font-lock-background-face:«w:[»screens «f:objectEnumerator»«w:]»»;
  «t:NSScreen» *«v:screen»;
  «t:NSRect» «v:frame»;

  frame = NSZeroRect;
  «k:while» ((screen = «:objc-font-lock-background-face:«w:[»enumerator «f:nextObject»«w:]»») != «c:nil»)
    frame = NSUnionRect (frame, «:objc-font-lock-background-face:«w:[»screen «f:frame»«w:]»»);

  «k:return» NSHeight (frame);
}

«t:int»
«f:x_display_pixel_width» («k:struct» «t:ns_display_info» *«t:dpyinfo»)
{
  «t:NSArray» *«v:screens» = «:objc-font-lock-background-face:«w:[»«t:NSScreen» «f:screens»«w:]»»;
  «t:NSEnumerator» *«v:enumerator» = «:objc-font-lock-background-face:«w:[»screens «f:objectEnumerator»«w:]»»;
  «t:NSScreen» *«v:screen»;
  «t:NSRect» «v:frame»;

  frame = NSZeroRect;
  «k:while» ((screen = «:objc-font-lock-background-face:«w:[»enumerator «f:nextObject»«w:]»») != «c:nil»)
    frame = NSUnionRect (frame, «:objc-font-lock-background-face:«w:[»screen «f:frame»«w:]»»);

  «k:return» NSWidth (frame);
}


«k:static» «t:Lisp_Object» «f:ns_string_to_lispmod» («k:const» «t:char» *«v:s»)
«m:/* »«x:--------------------------------------------------------------------------
     Convert modifier name to lisp symbol
   -------------------------------------------------------------------------- */»
{
  «k:if» («n:!»strncmp (SSDATA (SYMBOL_NAME (Qmeta)), s, 10))
    «k:return» Qmeta;
  «k:else» «k:if» («n:!»strncmp (SSDATA (SYMBOL_NAME (Qsuper)), s, 10))
    «k:return» Qsuper;
  «k:else» «k:if» («n:!»strncmp (SSDATA (SYMBOL_NAME (Qcontrol)), s, 10))
    «k:return» Qcontrol;
  «k:else» «k:if» («n:!»strncmp (SSDATA (SYMBOL_NAME (Qalt)), s, 10))
    «k:return» Qalt;
  «k:else» «k:if» («n:!»strncmp (SSDATA (SYMBOL_NAME (Qhyper)), s, 10))
    «k:return» Qhyper;
  «k:else» «k:if» («n:!»strncmp (SSDATA (SYMBOL_NAME (Qnone)), s, 10))
    «k:return» Qnone;
  «k:else»
    «k:return» Qnil;
}


«k:static» «t:void»
«f:ns_default» («k:const» «t:char» *«v:parameter», «t:Lisp_Object» *«v:result»,
           «t:Lisp_Object» «v:yesval», «t:Lisp_Object» «v:noval»,
           «t:BOOL» «v:is_float», «t:BOOL» «v:is_modstring»)
«m:/* »«x:--------------------------------------------------------------------------
      Check a parameter value in user's preferences
   -------------------------------------------------------------------------- */»
{
  «k:const» «t:char» *«v:value» = ns_get_defaults_value (parameter);

  «k:if» (value)
    {
      «t:double» «v:f»;
      «t:char» *«v:pos»;
      «k:if» (c_strcasecmp (value, «s:"YES"») == 0)
        *result = yesval;
      «k:else» «k:if» (c_strcasecmp (value, «s:"NO"») == 0)
        *result = noval;
      «k:else» «k:if» (is_float && (f = strtod (value, &pos), pos != value))
        *result = make_float (f);
      «k:else» «k:if» (is_modstring && value)
        *result = ns_string_to_lispmod (value);
      «k:else» fprintf (stderr,
                   «s:"Bad value for default \"%s\": \"%s\"\n"», parameter, value);
    }
}


«k:static» «t:void»
«f:ns_initialize_display_info» («k:struct» «t:ns_display_info» *«t:dpyinfo»)
«m:/* »«x:--------------------------------------------------------------------------
      Initialize global info and storage for display.
   -------------------------------------------------------------------------- */»
{
    «t:NSScreen» *«v:screen» = «:objc-font-lock-background-face:«w:[»«t:NSScreen» «f:mainScreen»«w:]»»;
    «t:NSWindowDepth» «v:depth» = «:objc-font-lock-background-face:«w:[»screen «f:depth»«w:]»»;

    dpyinfo->resx = 72.27; «m:/* »«x:used 75.0, but this makes pt == pixel, expected */»
    dpyinfo->resy = 72.27;
    dpyinfo->color_p = «n:!»«:objc-font-lock-background-face:«w:[»«t:NSDeviceWhiteColorSpace» «f:isEqualToString»:»
                                                  «:objc-font-lock-background-face:NSColorSpaceFromDepth (depth)«w:]»»
                && «n:!»«:objc-font-lock-background-face:«w:[»«t:NSCalibratedWhiteColorSpace» «f:isEqualToString»:»
                                                 «:objc-font-lock-background-face:NSColorSpaceFromDepth (depth)«w:]»»;
    dpyinfo->n_planes = NSBitsPerPixelFromDepth (depth);
    dpyinfo->color_table = xmalloc (sizeof *dpyinfo->color_table);
    dpyinfo->color_table->colors = NULL;
    dpyinfo->root_window = 42; «m:/* »«x:a placeholder.. */»
    dpyinfo->x_highlight_frame = dpyinfo->x_focus_frame = NULL;
    dpyinfo->n_fonts = 0;
    dpyinfo->smallest_font_height = 1;
    dpyinfo->smallest_char_width = 1;

    reset_mouse_highlight (&dpyinfo->mouse_highlight);
}


«m:/* »«x:This and next define (many of the) public functions in this file. */»
«m:/* »«x:x_... are generic versions in xdisp.c that we, and other terms, get away
         with using despite presence in the "system dependent" redisplay
         interface.  In addition, many of the ns_ methods have code that is
         shared with all terms, indicating need for further refactoring. */»
«k:extern» «t:frame_parm_handler» «v:ns_frame_parm_handlers»[];
«k:static» «k:struct» «t:redisplay_interface» «t:ns_redisplay_interface» =
{
  ns_frame_parm_handlers,
  x_produce_glyphs,
  x_write_glyphs,
  x_insert_glyphs,
  x_clear_end_of_line,
  ns_scroll_run,
  ns_after_update_window_line,
  ns_update_window_begin,
  ns_update_window_end,
  0, «m:/* »«x:flush_display */»
  x_clear_window_mouse_face,
  x_get_glyph_overhangs,
  x_fix_overlapping_area,
  ns_draw_fringe_bitmap,
  0, «m:/* »«x:define_fringe_bitmap */» «m:/* »«x:FIXME: simplify ns_draw_fringe_bitmap */»
  0, «m:/* »«x:destroy_fringe_bitmap */»
  ns_compute_glyph_string_overhangs,
  ns_draw_glyph_string,
  ns_define_frame_cursor,
  ns_clear_frame_area,
  ns_draw_window_cursor,
  ns_draw_vertical_window_border,
  ns_draw_window_divider,
  ns_shift_glyphs_for_insert
};


«k:static» «t:void»
«f:ns_delete_display» («k:struct» «t:ns_display_info» *«t:dpyinfo»)
{
  «m:/* »«x:TODO... */»
}


«m:/* »«x:This function is called when the last frame on a display is deleted. */»
«k:static» «t:void»
«f:ns_delete_terminal» («k:struct» «t:terminal» *«t:terminal»)
{
  «k:struct» «t:ns_display_info» *«t:dpyinfo» = terminal->display_info.ns;

  «m:/* »«x:Protect against recursive calls.  delete_frame in
     delete_terminal calls us back when it deletes our last frame.  */»
  «k:if» («n:!»terminal->name)
    «k:return»;

  block_input ();

  x_destroy_all_bitmaps (dpyinfo);
  ns_delete_display (dpyinfo);
  unblock_input ();
}


«k:static» «k:struct» «t:terminal» *
«t:ns_create_terminal» («k:struct» «t:ns_display_info» *«t:dpyinfo»)
«m:/* »«x:--------------------------------------------------------------------------
      Set up use of NS before we make the first connection.
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:terminal» *«t:terminal»;

  NSTRACE (ns_create_terminal);

  terminal = create_terminal ();

  terminal->type = output_ns;
  terminal->display_info.ns = dpyinfo;
  dpyinfo->terminal = terminal;

  terminal->rif = &ns_redisplay_interface;

  terminal->clear_frame_hook = ns_clear_frame;
  terminal->ins_del_lines_hook = 0; «m:/* »«x:XXX vestigial? */»
  terminal->delete_glyphs_hook = 0; «m:/* »«x:XXX vestigial? */»
  terminal->ring_bell_hook = ns_ring_bell;
  terminal->reset_terminal_modes_hook = NULL;
  terminal->set_terminal_modes_hook = NULL;
  terminal->update_begin_hook = ns_update_begin;
  terminal->update_end_hook = ns_update_end;
  terminal->set_terminal_window_hook = NULL; «m:/* »«x:XXX vestigial? */»
  terminal->read_socket_hook = ns_read_socket;
  terminal->frame_up_to_date_hook = ns_frame_up_to_date;
  terminal->mouse_position_hook = ns_mouse_position;
  terminal->frame_rehighlight_hook = ns_frame_rehighlight;
  terminal->frame_raise_lower_hook = ns_frame_raise_lower;

  terminal->fullscreen_hook = ns_fullscreen_hook;

  terminal->set_vertical_scroll_bar_hook = ns_set_vertical_scroll_bar;
  terminal->condemn_scroll_bars_hook = ns_condemn_scroll_bars;
  terminal->redeem_scroll_bar_hook = ns_redeem_scroll_bar;
  terminal->judge_scroll_bars_hook = ns_judge_scroll_bars;

  terminal->delete_frame_hook = x_destroy_window;
  terminal->delete_terminal_hook = ns_delete_terminal;

  «k:return» terminal;
}


«k:struct» «t:ns_display_info» *
«t:ns_term_init» («t:Lisp_Object» «v:display_name»)
«m:/* »«x:--------------------------------------------------------------------------
     Start the Application and get things rolling.
   -------------------------------------------------------------------------- */»
{
  «k:struct» «t:terminal» *«t:terminal»;
  «k:struct» «t:ns_display_info» *«t:dpyinfo»;
  «k:static» «t:int» «v:ns_initialized» = 0;
  «t:Lisp_Object» «v:tmp»;

  «k:if» (ns_initialized) «k:return» x_display_list;
  ns_initialized = 1;

  NSTRACE (ns_term_init);

  «:objc-font-lock-background-face:«w:[»outerpool «f:release»«w:]»»;
  outerpool = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSAutoreleasePool» «f:alloc»«w:]»» «f:init»«w:]»»;

  «m:/* »«x:count object allocs (About, click icon); on OS X use ObjectAlloc tool */»
  «m:/*»«x:GSDebugAllocationActive (YES); */»
  block_input ();

  baud_rate = 38400;
  «t:Fset_input_interrupt_mode» («v:Qnil»);

  «k:if» (selfds[0] == -1)
    {
      «k:if» (emacs_pipe (selfds) != 0)
        {
          fprintf (stderr, «s:"Failed to create pipe: %s\n"»,
                   emacs_strerror (errno));
          emacs_abort ();
        }

      fcntl (selfds[0], F_SETFL, O_NONBLOCK|fcntl (selfds[0], F_GETFL));
      FD_ZERO (&select_readfds);
      FD_ZERO (&select_writefds);
      pthread_mutex_init (&select_mutex, NULL);
    }

  ns_pending_files = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSMutableArray» «f:alloc»«w:]»» «f:init»«w:]»»;
  ns_pending_service_names = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSMutableArray» «f:alloc»«w:]»» «f:init»«w:]»»;
  ns_pending_service_args = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSMutableArray» «f:alloc»«w:]»» «f:init»«w:]»»;

«m:/* »«x:Start app and create the main menu, window, view.
     Needs to be here because ns_initialize_display_info () uses AppKit classes.
     The view will then ask the NSApp to stop and return to Emacs. */»
  «:objc-font-lock-background-face:«w:[»«t:EmacsApp» «f:sharedApplication»«w:]»»;
  «k:if» (NSApp == «c:nil»)
    «k:return» NULL;
  «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setDelegate»: NSApp«w:]»»;

  «m:/* »«x:Start the select thread.  */»
  «:objc-font-lock-background-face:«w:[»«t:NSThread» «f:detachNewThreadSelector»:«k:@selector» (fd_handler:)»
                           «:objc-font-lock-background-face:«f:toTarget»:NSApp»
                         «:objc-font-lock-background-face:«f:withObject»:«c:nil»«w:]»»;

  «m:/* »«x:debugging: log all notifications */»
  «m:/*   »«x:[[NSNotificationCenter defaultCenter] addObserver: NSApp
                                         selector: @selector (logNotification:)
                                             name: nil object: nil]; */»

  dpyinfo = xzalloc (sizeof *dpyinfo);

  ns_initialize_display_info (dpyinfo);
  terminal = ns_create_terminal (dpyinfo);

  terminal->kboard = allocate_kboard (Qns);
  «m:/* »«x:Don't let the initial kboard remain current longer than necessary.
     That would cause problems if a file loaded on startup tries to
     prompt in the mini-buffer.  */»
  «k:if» (current_kboard == initial_kboard)
    current_kboard = terminal->kboard;
  terminal->kboard->reference_count++;

  dpyinfo->next = x_display_list;
  x_display_list = dpyinfo;

  dpyinfo->name_list_element = Fcons (display_name, Qnil);

  terminal->name = xstrdup (SSDATA (display_name));

  unblock_input ();

  «k:if» («n:!»inhibit_x_resources)
    {
      ns_default («s:"GSFontAntiAlias"», &ns_antialias_text,
                 Qt, Qnil, «c:NO», «c:NO»);
      tmp = Qnil;
      «m:/* »«x:this is a standard variable */»
      ns_default («s:"AppleAntiAliasingThreshold"», &tmp,
                 make_float (10.0), make_float (6.0), «c:YES», «c:NO»);
      ns_antialias_threshold = NILP (tmp) ? 10.0 : XFLOATINT (tmp);
    }

  {
    «t:NSColorList» *«v:cl» = «:objc-font-lock-background-face:«w:[»«t:NSColorList» «f:colorListNamed»: @«s:"Emacs"»«w:]»»;

    «k:if» ( cl == «c:nil» )
      {
        «t:Lisp_Object» «v:color_file», «v:color_map», «v:color»;
        «t:unsigned» «t:long» c;
        «t:char» *«v:name»;

        color_file = Fexpand_file_name (build_string («s:"rgb.txt"»),
                         «t:Fsymbol_value» («v:intern» («s:"data-directory"»)));

        color_map = Fx_load_color_file (color_file);
        «k:if» (NILP (color_map))
          fatal («s:"Could not read %s.\n"», SDATA (color_file));

        cl = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSColorList» «f:alloc»«w:]»» «f:initWithName»: @«s:"Emacs"»«w:]»»;
        «k:for» ( ; CONSP (color_map); color_map = XCDR (color_map))
          {
            color = XCAR (color_map);
            name = SSDATA (XCAR (color));
            c = XINT (XCDR (color));
            «:objc-font-lock-background-face:«w:[»cl «f:setColor»:»
                  «:objc-font-lock-background-face:«:objc-font-lock-background-face:«w:[»«t:NSColor» «f:colorForEmacsRed»: RED_FROM_ULONG (c) / 255.0»»
                                      «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:green»: GREEN_FROM_ULONG (c) / 255.0»»
                                       «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:blue»: BLUE_FROM_ULONG (c) / 255.0»»
                                      «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:alpha»: 1.0«w:]»»»
                  «:objc-font-lock-background-face:«f:forKey»: «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»: name«w:]»»«w:]»»;
          }
        «:objc-font-lock-background-face:«w:[»cl «f:writeToFile»: «c:nil»«w:]»»;
      }
  }

  {
«p:#ifdef» NS_IMPL_GNUSTEP
    Vwindow_system_version = build_string (gnustep_base_version);
«p:#else»
    «m:/*»«x:PSnextrelease (128, c); */»
    «t:char» «v:c»[DBL_BUFSIZE_BOUND];
    «t:int» «v:len» = dtoastr (c, «t:sizeof» «v:c», 0, 0, NSAppKitVersionNumber);
    Vwindow_system_version = make_unibyte_string (c, len);
«p:#endif»
  }

  delete_keyboard_wait_descriptor (0);

  ns_app_name = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSProcessInfo» «f:processInfo»«w:]»» «f:processName»«w:]»»;

«m:/* »«x:Set up OS X app menu */»
«p:#ifdef» NS_IMPL_COCOA
  {
    «t:NSMenu» *«v:appMenu»;
    «t:NSMenuItem» *«v:item»;
    «m:/* »«x:set up the application menu */»
    svcsMenu = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsMenu» «f:alloc»«w:]»» «f:initWithTitle»: @«s:"Services"»«w:]»»;
    «:objc-font-lock-background-face:«w:[»svcsMenu «f:setAutoenablesItems»: «c:NO»«w:]»»;
    appMenu = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsMenu» «f:alloc»«w:]»» «f:initWithTitle»: @«s:"Emacs"»«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:setAutoenablesItems»: «c:NO»«w:]»»;
    mainMenu = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsMenu» «f:alloc»«w:]»» «f:initWithTitle»: @«s:""»«w:]»»;
    dockMenu = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsMenu» «f:alloc»«w:]»» «f:initWithTitle»: @«s:""»«w:]»»;

    «:objc-font-lock-background-face:«w:[»appMenu «f:insertItemWithTitle»: @«s:"About Emacs"»»
                          «:objc-font-lock-background-face:«f:action»: «k:@selector» (orderFrontStandardAboutPanel:)»
                   «:objc-font-lock-background-face:«f:keyEquivalent»: @«s:""»»
                         «:objc-font-lock-background-face:«f:atIndex»: 0«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:insertItem»: «:objc-font-lock-background-face:«w:[»«t:NSMenuItem» «f:separatorItem»«w:]»» «f:atIndex»: 1«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:insertItemWithTitle»: @«s:"Preferences..."»»
                          «:objc-font-lock-background-face:«f:action»: «k:@selector» (showPreferencesWindow:)»
                   «:objc-font-lock-background-face:«f:keyEquivalent»: @«s:","»»
                         «:objc-font-lock-background-face:«f:atIndex»: 2«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:insertItem»: «:objc-font-lock-background-face:«w:[»«t:NSMenuItem» «f:separatorItem»«w:]»» «f:atIndex»: 3«w:]»»;
    item = «:objc-font-lock-background-face:«w:[»appMenu «f:insertItemWithTitle»: @«s:"Services"»»
                                 «:objc-font-lock-background-face:«f:action»: «k:@selector» (menuDown:)»
                          «:objc-font-lock-background-face:«f:keyEquivalent»: @«s:""»»
                                «:objc-font-lock-background-face:«f:atIndex»: 4«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:setSubmenu»: svcsMenu «f:forItem»: item«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:insertItem»: «:objc-font-lock-background-face:«w:[»«t:NSMenuItem» «f:separatorItem»«w:]»» «f:atIndex»: 5«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:insertItemWithTitle»: @«s:"Hide Emacs"»»
                          «:objc-font-lock-background-face:«f:action»: «k:@selector» (hide:)»
                   «:objc-font-lock-background-face:«f:keyEquivalent»: @«s:"h"»»
                         «:objc-font-lock-background-face:«f:atIndex»: 6«w:]»»;
    item =  «:objc-font-lock-background-face:«w:[»appMenu «f:insertItemWithTitle»: @«s:"Hide Others"»»
                          «:objc-font-lock-background-face:«f:action»: «k:@selector» (hideOtherApplications:)»
                   «:objc-font-lock-background-face:«f:keyEquivalent»: @«s:"h"»»
                         «:objc-font-lock-background-face:«f:atIndex»: 7«w:]»»;
    «:objc-font-lock-background-face:«w:[»item «f:setKeyEquivalentModifierMask»: NSCommandKeyMask | NSAlternateKeyMask«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:insertItem»: «:objc-font-lock-background-face:«w:[»«t:NSMenuItem» «f:separatorItem»«w:]»» «f:atIndex»: 8«w:]»»;
    «:objc-font-lock-background-face:«w:[»appMenu «f:insertItemWithTitle»: @«s:"Quit Emacs"»»
                          «:objc-font-lock-background-face:«f:action»: «k:@selector» (terminate:)»
                   «:objc-font-lock-background-face:«f:keyEquivalent»: @«s:"q"»»
                         «:objc-font-lock-background-face:«f:atIndex»: 9«w:]»»;

    item = «:objc-font-lock-background-face:«w:[»mainMenu «f:insertItemWithTitle»: ns_app_name»
                                  «:objc-font-lock-background-face:«f:action»: «k:@selector» (menuDown:)»
                           «:objc-font-lock-background-face:«f:keyEquivalent»: @«s:""»»
                                 «:objc-font-lock-background-face:«f:atIndex»: 0«w:]»»;
    «:objc-font-lock-background-face:«w:[»mainMenu «f:setSubmenu»: appMenu «f:forItem»: item«w:]»»;
    «:objc-font-lock-background-face:«w:[»dockMenu «f:insertItemWithTitle»: @«s:"New Frame"»»
			   «:objc-font-lock-background-face:«f:action»: «k:@selector» (newFrame:)»
		    «:objc-font-lock-background-face:«f:keyEquivalent»: @«s:""»»
			  «:objc-font-lock-background-face:«f:atIndex»: 0«w:]»»;

    «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setMainMenu»: mainMenu«w:]»»;
    «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setAppleMenu»: appMenu«w:]»»;
    «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setServicesMenu»: svcsMenu«w:]»»;
    «m:/* »«x:Needed at least on Cocoa, to get dock menu to show windows */»
    «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setWindowsMenu»: «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSMenu» «f:alloc»«w:]»» «f:init»«w:]»»«w:]»»;

    «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSNotificationCenter» «f:defaultCenter»«w:]»»»
      «:objc-font-lock-background-face:«f:addObserver»: mainMenu»
         «:objc-font-lock-background-face:«f:selector»: «k:@selector» (trackingNotification:)»
             «:objc-font-lock-background-face:«f:name»: NSMenuDidBeginTrackingNotification «f:object»: mainMenu«w:]»»;
    «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSNotificationCenter» «f:defaultCenter»«w:]»»»
      «:objc-font-lock-background-face:«f:addObserver»: mainMenu»
         «:objc-font-lock-background-face:«f:selector»: «k:@selector» (trackingNotification:)»
             «:objc-font-lock-background-face:«f:name»: NSMenuDidEndTrackingNotification «f:object»: mainMenu«w:]»»;
  }
«p:#endif» «m:/* »«x:MAC OS X menu setup */»

  «m:/* »«x:Register our external input/output types, used for determining
     applicable services and also drag/drop eligibility. */»
  ns_send_types = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSArray» «f:arrayWithObjects»: NSStringPboardType, «c:nil»«w:]»» «f:retain»«w:]»»;
  ns_return_types = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSArray» «f:arrayWithObjects»: NSStringPboardType, «c:nil»«w:]»»»
                      «:objc-font-lock-background-face:«f:retain»«w:]»»;
  ns_drag_types = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSArray» «f:arrayWithObjects»:»»
                            «:objc-font-lock-background-face:«:objc-font-lock-background-face:NSStringPboardType,»»
                            «:objc-font-lock-background-face:«:objc-font-lock-background-face:NSTabularTextPboardType,»»
                            «:objc-font-lock-background-face:«:objc-font-lock-background-face:NSFilenamesPboardType,»»
                            «:objc-font-lock-background-face:«:objc-font-lock-background-face:NSURLPboardType, «c:nil»«w:]»» «f:retain»«w:]»»;

  «m:/* »«x:If fullscreen is in init/default-frame-alist, focus isn't set
     right for fullscreen windows, so set this.  */»
  «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:activateIgnoringOtherApps»:«c:YES»«w:]»»;

  «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:run»«w:]»»;
  ns_do_open_file = «c:YES»;

«p:#ifdef» NS_IMPL_GNUSTEP
  «m:/* »«x:GNUstep steals SIGCHLD for use in NSTask, but we don't use NSTask.
     We must re-catch it so subprocess works.  */»
  catch_child_signal ();
«p:#endif»
  «k:return» dpyinfo;
}


«t:void»
«f:ns_term_shutdown» («t:int» «v:sig»)
{
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSUserDefaults» «f:standardUserDefaults»«w:]»» «f:synchronize»«w:]»»;

  «m:/* »«x:code not reached in emacs.c after this is called by shut_down_emacs: */»
  «k:if» (STRINGP (Vauto_save_list_file_name))
    unlink (SSDATA (Vauto_save_list_file_name));

  «k:if» (sig == 0 || sig == SIGTERM)
    {
      «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:terminate»: NSApp«w:]»»;
    }
  «k:else» «m:// »«x:force a stack trace to happen
»    {
      emacs_abort ();
    }
}


«m:/* »«x:==========================================================================

    EmacsApp implementation

   ========================================================================== */»


«k:@implementation» «t:EmacsApp»

- («t:id»)«f:init»
{
  «k:if» («k:self» = «:objc-font-lock-background-face:«w:[»«k:super» «f:init»«w:]»»)
    {
«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_9
      «k:self»->isFirst = «c:YES»;
«p:#endif»
«p:#ifdef» NS_IMPL_GNUSTEP
      «k:self»->applicationDidFinishLaunchingCalled = «c:NO»;
«p:#endif»
    }

  «k:return» «k:self»;
}

«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_9
- («t:void»)«f:run»
{
    «t:NSAutoreleasePool» *«v:pool» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSAutoreleasePool» «f:alloc»«w:]»» «f:init»«w:]»»;

    «k:if» (isFirst) «:objc-font-lock-background-face:«w:[»«k:self» «f:finishLaunching»«w:]»»;
    isFirst = «c:NO»;

    shouldKeepRunning = «c:YES»;
    «k:do»
      {
        «:objc-font-lock-background-face:«w:[»pool «f:release»«w:]»»;
        pool = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSAutoreleasePool» «f:alloc»«w:]»» «f:init»«w:]»»;

        «t:NSEvent» *«v:event» =
          «:objc-font-lock-background-face:«w:[»«k:self» «f:nextEventMatchingMask»:NSAnyEventMask»
                            «:objc-font-lock-background-face:«f:untilDate»:«:objc-font-lock-background-face:«w:[»«t:NSDate» «f:distantFuture»«w:]»»»
                               «:objc-font-lock-background-face:«f:inMode»:NSDefaultRunLoopMode»
                              «:objc-font-lock-background-face:«f:dequeue»:«c:YES»«w:]»»;
        «:objc-font-lock-background-face:«w:[»«k:self» «f:sendEvent»:event«w:]»»;
        «:objc-font-lock-background-face:«w:[»«k:self» «f:updateWindows»«w:]»»;
    } «k:while» (shouldKeepRunning);

    «:objc-font-lock-background-face:«w:[»pool «f:release»«w:]»»;
}

- («t:void»)«f:stop»: («t:id»)«v:sender»
{
    shouldKeepRunning = «c:NO»;
    «m:// »«x:Stop possible dialog also.  Noop if no dialog present.
»    «m:// »«x:The file dialog still leaks 7k - 10k on 10.9 though.
»    «:objc-font-lock-background-face:«w:[»«k:super» «f:stop»:sender«w:]»»;
}
«p:#endif»

- («t:void»)«f:logNotification»: («t:NSNotification» *)«v:notification»
{
  «k:const» «t:char» *«v:name» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»notification «f:name»«w:]»» «f:UTF8String»«w:]»»;
  «k:if» («n:!»strstr (name, «s:"Update"») && «n:!»strstr (name, «s:"NSMenu"»)
      && «n:!»strstr (name, «s:"WindowNumber"»))
    NSLog (@«s:"notification: '%@'"», «:objc-font-lock-background-face:«w:[»notification «f:name»«w:]»»);
}


- («t:void»)«f:sendEvent»: («t:NSEvent» *)«v:theEvent»
«m:/* »«x:--------------------------------------------------------------------------
     Called when NSApp is running for each event received.  Used to stop
     the loop when we choose, since there's no way to just run one iteration.
   -------------------------------------------------------------------------- */»
{
  «t:int» «v:type» = «:objc-font-lock-background-face:«w:[»theEvent «f:type»«w:]»»;
  «t:NSWindow» *«v:window» = «:objc-font-lock-background-face:«w:[»theEvent «f:window»«w:]»»;

«m:/*  »«x:NSTRACE (sendEvent); */»
«m:/*»«x:fprintf (stderr, "received event of type %d\t%d\n", type);*/»

«p:#ifdef» NS_IMPL_GNUSTEP
  «m:// »«x:Keyboard events aren't propagated to file dialogs for some reason.
»  «k:if» («:objc-font-lock-background-face:«w:[»«t:NSApp» «f:modalWindow»«w:]»» != «c:nil» &&
      (type == NSKeyDown || type == NSKeyUp || type == NSFlagsChanged))
    {
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSApp» «f:modalWindow»«w:]»» «f:sendEvent»: theEvent«w:]»»;
      «k:return»;
    }
«p:#endif»

  «k:if» (type == NSApplicationDefined)
    {
      «k:switch» («:objc-font-lock-background-face:«w:[»theEvent «f:data2»«w:]»»)
        {
«p:#ifdef» NS_IMPL_COCOA
        «k:case» NSAPP_DATA2_RUNASSCRIPT:
          ns_run_ascript ();
          «:objc-font-lock-background-face:«w:[»«k:self» «f:stop»: «k:self»«w:]»»;
          «k:return»;
«p:#endif»
        «k:case» NSAPP_DATA2_RUNFILEDIALOG:
          ns_run_file_dialog ();
          «:objc-font-lock-background-face:«w:[»«k:self» «f:stop»: «k:self»«w:]»»;
          «k:return»;
        }
    }

  «k:if» (type == NSCursorUpdate && window == «c:nil»)
    {
      fprintf (stderr, «s:"Dropping external cursor update event.\n"»);
      «k:return»;
    }

  «k:if» (type == NSApplicationDefined)
    {
      «m:/* »«x:Events posted by ns_send_appdefined interrupt the run loop here.
         But, if a modal window is up, an appdefined can still come through,
         (e.g., from a makeKeyWindow event) but stopping self also stops the
         modal loop. Just defer it until later. */»
      «k:if» («:objc-font-lock-background-face:«w:[»«t:NSApp» «f:modalWindow»«w:]»» == «c:nil»)
        {
          last_appdefined_event_data = «:objc-font-lock-background-face:«w:[»theEvent «f:data1»«w:]»»;
          «:objc-font-lock-background-face:«w:[»«k:self» «f:stop»: «k:self»«w:]»»;
        }
      «k:else»
        {
          send_appdefined = «c:YES»;
        }
    }


«p:#ifdef» NS_IMPL_COCOA
  «m:/* »«x:If no dialog and none of our frames have focus and it is a move, skip it.
     It is a mouse move in an auxiliary menu, i.e. on the top right on OSX,
     such as Wifi, sound, date or similar.
     This prevents "spooky" highlighting in the frame under the menu.  */»
  «k:if» (type == NSMouseMoved && «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:modalWindow»«w:]»» == «c:nil»)
    {
      «k:struct» «t:ns_display_info» *«t:di»;
      «t:BOOL» «v:has_focus» = «c:NO»;
      «k:for» (di = x_display_list; «n:!» has_focus && di; di = di->next)
        has_focus = di->x_focus_frame != 0;
      «k:if» («n:!» has_focus)
        «k:return»;
    }
«p:#endif»

  «:objc-font-lock-background-face:«w:[»«k:super» «f:sendEvent»: theEvent«w:]»»;
}


- («t:void»)«f:showPreferencesWindow»: («t:id»)«v:sender»
{
  «k:struct» «t:frame» *«t:emacsframe» = SELECTED_FRAME ();
  «t:NSEvent» *«v:theEvent» = «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:currentEvent»«w:]»»;

  «k:if» («n:!»emacs_event)
    «k:return»;
  emacs_event->kind = NS_NONKEY_EVENT;
  emacs_event->code = KEY_NS_SHOW_PREFS;
  emacs_event->modifiers = 0;
  EV_TRAILER (theEvent);
}


- («t:void»)«f:newFrame»: («t:id»)«v:sender»
{
  «k:struct» «t:frame» *«t:emacsframe» = SELECTED_FRAME ();
  «t:NSEvent» *«v:theEvent» = «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:currentEvent»«w:]»»;

  «k:if» («n:!»emacs_event)
    «k:return»;
  emacs_event->kind = NS_NONKEY_EVENT;
  emacs_event->code = KEY_NS_NEW_FRAME;
  emacs_event->modifiers = 0;
  EV_TRAILER (theEvent);
}


«m:/* »«x:Open a file (used by below, after going into queue read by ns_read_socket) */»
- («t:BOOL») «f:openFile»: («t:NSString» *)«v:fileName»
{
  «k:struct» «t:frame» *«t:emacsframe» = SELECTED_FRAME ();
  «t:NSEvent» *«v:theEvent» = «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:currentEvent»«w:]»»;

  «k:if» («n:!»emacs_event)
    «k:return» «c:NO»;

  emacs_event->kind = NS_NONKEY_EVENT;
  emacs_event->code = KEY_NS_OPEN_FILE_LINE;
  ns_input_file = append2 (ns_input_file, build_string («:objc-font-lock-background-face:«w:[»fileName «f:UTF8String»«w:]»»));
  ns_input_line = Qnil; «m:/* »«x:can be start or cons start,end */»
  emacs_event->modifiers =0;
  EV_TRAILER (theEvent);

  «k:return» «c:YES»;
}


«m:/* »«x:**************************************************************************

      EmacsApp delegate implementation

   ************************************************************************** */»

- («t:void»)«f:applicationDidFinishLaunching»: («t:NSNotification» *)«v:notification»
«m:/* »«x:--------------------------------------------------------------------------
     When application is loaded, terminate event loop in ns_term_init
   -------------------------------------------------------------------------- */»
{
  NSTRACE (applicationDidFinishLaunching);
«p:#ifdef» NS_IMPL_GNUSTEP
  ((«t:EmacsApp» *)«k:self»)->applicationDidFinishLaunchingCalled = «c:YES»;
«p:#endif»
  «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setServicesProvider»: NSApp«w:]»»;
  ns_send_appdefined (-2);
}


«m:/* »«x:Termination sequences:
    C-x C-c:
    Cmd-Q:
    MenuBar | File | Exit:
    Select Quit from App menubar:
        -terminate
	KEY_NS_POWER_OFF, (save-buffers-kill-emacs)
	ns_term_shutdown()

    Select Quit from Dock menu:
    Logout attempt:
        -appShouldTerminate
          Cancel -> Nothing else
          Accept ->

	  -terminate
	  KEY_NS_POWER_OFF, (save-buffers-kill-emacs)
	  ns_term_shutdown()

*/»

- («t:void») «f:terminate»: («t:id»)«v:sender»
{
  «k:struct» «t:frame» *«t:emacsframe» = SELECTED_FRAME ();

  «k:if» («n:!»emacs_event)
    «k:return»;

  emacs_event->kind = NS_NONKEY_EVENT;
  emacs_event->code = KEY_NS_POWER_OFF;
  emacs_event->arg = Qt; «m:/* »«x:mark as non-key event */»
  EV_TRAILER ((«t:id»)«c:nil»);
}


- («t:NSApplicationTerminateReply»)«f:applicationShouldTerminate»: («t:id»)«v:sender»
{
  «t:int» «v:ret»;

  «k:if» (NILP (ns_confirm_quit)) «m://   »«x:|| ns_shutdown_properly  --> TO DO
»    «k:return» NSTerminateNow;

    ret = NSRunAlertPanel(ns_app_name,
                          @«s:"Exit requested.  Would you like to Save Buffers and Exit, or Cancel the request?"»,
                          @«s:"Save Buffers and Exit"», @«s:"Cancel"», «c:nil»);

    «k:if» (ret == NSAlertDefaultReturn)
        «k:return» NSTerminateNow;
    «k:else» «k:if» (ret == NSAlertAlternateReturn)
        «k:return» NSTerminateCancel;
    «k:return» NSTerminateNow;  «m:/* »«x:just in case */»
}

«k:static» «t:int»
«f:not_in_argv» («t:NSString» *«v:arg»)
{
  «t:int» «v:k»;
  «k:const» «t:char» *«v:a» = «:objc-font-lock-background-face:«w:[»arg «f:UTF8String»«w:]»»;
  «k:for» (k = 1; k < initial_argc; ++k)
    «k:if» (strcmp (a, initial_argv[k]) == 0) «k:return» 0;
  «k:return» 1;
}

«m:/*   »«x:Notification from the Workspace to open a file */»
- («t:BOOL»)«f:application»: «v:sender» «f:openFile»: («t:NSString» *)«v:file»
{
  «k:if» (ns_do_open_file || not_in_argv (file))
    «:objc-font-lock-background-face:«w:[»ns_pending_files «f:addObject»: file«w:]»»;
  «k:return» «c:YES»;
}


«m:/*   »«x:Open a file as a temporary file */»
- («t:BOOL»)«f:application»: «v:sender» «f:openTempFile»: («t:NSString» *)«v:file»
{
  «k:if» (ns_do_open_file || not_in_argv (file))
    «:objc-font-lock-background-face:«w:[»ns_pending_files «f:addObject»: file«w:]»»;
  «k:return» «c:YES»;
}


«m:/*   »«x:Notification from the Workspace to open a file noninteractively (?) */»
- («t:BOOL»)«f:application»: «v:sender» «f:openFileWithoutUI»: («t:NSString» *)«v:file»
{
  «k:if» (ns_do_open_file || not_in_argv (file))
    «:objc-font-lock-background-face:«w:[»ns_pending_files «f:addObject»: file«w:]»»;
  «k:return» «c:YES»;
}

«m:/*   »«x:Notification from the Workspace to open multiple files */»
- («t:void»)«f:application»: «v:sender» «f:openFiles»: («t:NSArray» *)«v:fileList»
{
  «t:NSEnumerator» *«v:files» = «:objc-font-lock-background-face:«w:[»fileList «f:objectEnumerator»«w:]»»;
  «t:NSString» *«v:file»;
  «m:/* »«x:Don't open files from the command line unconditionally,
     Cocoa parses the command line wrong, --option value tries to open value
     if --option is the last option.  */»
  «k:while» ((file = «:objc-font-lock-background-face:«w:[»files «f:nextObject»«w:]»») != «c:nil»)
    «k:if» (ns_do_open_file || not_in_argv (file))
      «:objc-font-lock-background-face:«w:[»ns_pending_files «f:addObject»: file«w:]»»;

  «:objc-font-lock-background-face:«w:[»«k:self» «f:replyToOpenOrPrint»: NSApplicationDelegateReplySuccess«w:]»»;

}


«m:/* »«x:Handle dock menu requests.  */»
- («t:NSMenu» *)«f:applicationDockMenu»: («t:NSApplication» *) «v:sender»
{
  «k:return» dockMenu;
}


«m:/* »«x:TODO: these may help w/IO switching btwn terminal and NSApp */»
- («t:void»)«f:applicationWillBecomeActive»: («t:NSNotification» *)«v:notification»
{
  «m://»«x:ns_app_active=YES;
»}
- («t:void»)«f:applicationDidBecomeActive»: («t:NSNotification» *)«v:notification»
{
  NSTRACE (applicationDidBecomeActive);

«p:#ifdef» NS_IMPL_GNUSTEP
  «k:if» («n:!» applicationDidFinishLaunchingCalled)
    «:objc-font-lock-background-face:«w:[»«k:self» «f:applicationDidFinishLaunching»:notification«w:]»»;
«p:#endif»
  «m://»«x:ns_app_active=YES;
»
  ns_update_auto_hide_menu_bar ();
  «m:// »«x:No constraining takes place when the application is not active.
»  ns_constrain_all_frames ();
}
- («t:void»)«f:applicationDidResignActive»: («t:NSNotification» *)«v:notification»
{
  «m://»«x:ns_app_active=NO;
»  ns_send_appdefined (-1);
}



«m:/* »«x:==========================================================================

    EmacsApp aux handlers for managing event loop

   ========================================================================== */»


- («t:void»)«f:timeout_handler»: («t:NSTimer» *)«v:timedEntry»
«m:/* »«x:--------------------------------------------------------------------------
     The timeout specified to ns_select has passed.
   -------------------------------------------------------------------------- */»
{
  «m:/*»«x:NSTRACE (timeout_handler); */»
  ns_send_appdefined (-2);
}

«p:#ifdef» NS_IMPL_GNUSTEP
- («t:void»)«f:sendFromMainThread»:(«t:id»)«v:unused»
{
  ns_send_appdefined (nextappdefined);
}
«p:#endif»

- («t:void»)«f:fd_handler»:(«t:id»)«v:unused»
«m:/* »«x:--------------------------------------------------------------------------
     Check data waiting on file descriptors and terminate if so
   -------------------------------------------------------------------------- */»
{
  «t:int» «v:result»;
  «t:int» «v:waiting» = 1, «v:nfds»;
  «t:char» «v:c»;

  «t:fd_set» «v:readfds», «v:writefds», *«v:wfds»;
  «k:struct» «t:timespec» «t:timeout», *«t:tmo»;
  «t:NSAutoreleasePool» *«v:pool» = «c:nil»;

  «m:/* »«x:NSTRACE (fd_handler); */»

  «k:for» (;;)
    {
      «:objc-font-lock-background-face:«w:[»pool «f:release»«w:]»»;
      pool = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSAutoreleasePool» «f:alloc»«w:]»» «f:init»«w:]»»;

      «k:if» (waiting)
        {
          «t:fd_set» «v:fds»;
          FD_ZERO (&fds);
          FD_SET (selfds[0], &fds);
          result = select (selfds[0]+1, &fds, NULL, NULL, NULL);
          «k:if» (result > 0 && read (selfds[0], &c, 1) == 1 && c == «s:'g'»)
	    waiting = 0;
        }
      «k:else»
        {
          pthread_mutex_lock (&select_mutex);
          nfds = select_nfds;

          «k:if» (select_valid & SELECT_HAVE_READ)
            readfds = select_readfds;
          «k:else»
            FD_ZERO (&readfds);

          «k:if» (select_valid & SELECT_HAVE_WRITE)
            {
              writefds = select_writefds;
              wfds = &writefds;
            }
          «k:else»
            wfds = NULL;
          «k:if» (select_valid & SELECT_HAVE_TMO)
            {
              timeout = select_timeout;
              tmo = &timeout;
            }
          «k:else»
            tmo = NULL;

          pthread_mutex_unlock (&select_mutex);

          FD_SET (selfds[0], &readfds);
          «k:if» (selfds[0] >= nfds) nfds = selfds[0]+1;

          result = pselect (nfds, &readfds, wfds, NULL, tmo, NULL);

          «k:if» (result == 0)
            ns_send_appdefined (-2);
          «k:else» «k:if» (result > 0)
            {
              «k:if» (FD_ISSET (selfds[0], &readfds))
                {
                  «k:if» (read (selfds[0], &c, 1) == 1 && c == «s:'s'»)
		    waiting = 1;
                }
              «k:else»
                {
                  pthread_mutex_lock (&select_mutex);
                  «k:if» (select_valid & SELECT_HAVE_READ)
                    select_readfds = readfds;
                  «k:if» (select_valid & SELECT_HAVE_WRITE)
                    select_writefds = writefds;
                  «k:if» (select_valid & SELECT_HAVE_TMO)
                    select_timeout = timeout;
                  pthread_mutex_unlock (&select_mutex);

                  ns_send_appdefined (result);
                }
            }
          waiting = 1;
        }
    }
}



«m:/* »«x:==========================================================================

    Service provision

   ========================================================================== */»

«m:/* »«x:called from system: queue for next pass through event loop */»
- («t:void»)«f:requestService»: («t:NSPasteboard» *)«v:pboard»
              «f:userData»: («t:NSString» *)«v:userData»
                 «f:error»: («t:NSString» **)«v:error»
{
  «:objc-font-lock-background-face:«w:[»ns_pending_service_names «f:addObject»: userData«w:]»»;
  «:objc-font-lock-background-face:«w:[»ns_pending_service_args «f:addObject»: «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»:»»
      «:objc-font-lock-background-face:«:objc-font-lock-background-face:SSDATA (ns_string_from_pasteboard (pboard))«w:]»»«w:]»»;
}


«m:/* »«x:called from ns_read_socket to clear queue */»
- («t:BOOL»)«f:fulfillService»: («t:NSString» *)«v:name» «f:withArg»: («t:NSString» *)«v:arg»
{
  «k:struct» «t:frame» *«t:emacsframe» = SELECTED_FRAME ();
  «t:NSEvent» *«v:theEvent» = «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:currentEvent»«w:]»»;

  «k:if» («n:!»emacs_event)
    «k:return» «c:NO»;

  emacs_event->kind = NS_NONKEY_EVENT;
  emacs_event->code = KEY_NS_SPI_SERVICE_CALL;
  ns_input_spi_name = build_string («:objc-font-lock-background-face:«w:[»name «f:UTF8String»«w:]»»);
  ns_input_spi_arg = build_string («:objc-font-lock-background-face:«w:[»arg «f:UTF8String»«w:]»»);
  emacs_event->modifiers = EV_MODIFIERS (theEvent);
  EV_TRAILER (theEvent);

  «k:return» «c:YES»;
}


«k:@end»  «m:/* »«x:EmacsApp */»



«m:/* »«x:==========================================================================

    EmacsView implementation

   ========================================================================== */»


«k:@implementation» «t:EmacsView»

«m:/* »«x:needed to inform when window closed from LISP */»
- («t:void») «f:setWindowClosing»: («t:BOOL»)«v:closing»
{
  windowClosing = closing;
}


- («t:void»)«f:dealloc»
{
  NSTRACE (EmacsView_dealloc);
  «:objc-font-lock-background-face:«w:[»toolbar «f:release»«w:]»»;
  «k:if» (fs_state == FULLSCREEN_BOTH)
    «:objc-font-lock-background-face:«w:[»nonfs_window «f:release»«w:]»»;
  «:objc-font-lock-background-face:«w:[»«k:super» «f:dealloc»«w:]»»;
}


«m:/* »«x:called on font panel selection */»
- («t:void»)«f:changeFont»: («t:id»)«v:sender»
{
  «t:NSEvent» *«v:e» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:currentEvent»«w:]»»;
  «k:struct» «t:face» *«t:face» = FRAME_DEFAULT_FACE (emacsframe);
  «k:struct» «t:font» *«t:font» = face->font;
  «t:id» «v:newFont»;
  «t:CGFloat» «v:size»;
  «t:NSFont» *«v:nsfont»;

  NSTRACE (changeFont);

  «k:if» («n:!»emacs_event)
    «k:return»;

  «k:if» (EQ (font->driver->type, Qns))
    nsfont = ((«k:struct» «t:nsfont_info» *)font)->nsfont;
«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
  «k:else»
    nsfont = («t:NSFont» *) macfont_get_nsctfont (font);
«p:#endif»

  «k:if» ((newFont = «:objc-font-lock-background-face:«w:[»sender «f:convertFont»: nsfont«w:]»»))
    {
      SET_FRAME_GARBAGED (emacsframe); «m:/* »«x:now needed as of 2008/10 */»

      emacs_event->kind = NS_NONKEY_EVENT;
      emacs_event->modifiers = 0;
      emacs_event->code = KEY_NS_CHANGE_FONT;

      size = «:objc-font-lock-background-face:«w:[»newFont «f:pointSize»«w:]»»;
      ns_input_fontsize = make_number (lrint (size));
      ns_input_font = build_string («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»newFont «f:familyName»«w:]»» «f:UTF8String»«w:]»»);
      EV_TRAILER (e);
    }
}


- («t:BOOL»)«f:acceptsFirstResponder»
{
  NSTRACE (acceptsFirstResponder);
  «k:return» «c:YES»;
}


- («t:void»)«f:resetCursorRects»
{
  «t:NSRect» «v:visible» = «:objc-font-lock-background-face:«w:[»«k:self» «f:visibleRect»«w:]»»;
  «t:NSCursor» *«v:currentCursor» = FRAME_POINTER_TYPE (emacsframe);
  NSTRACE (resetCursorRects);

  «k:if» (currentCursor == «c:nil»)
    currentCursor = «:objc-font-lock-background-face:«w:[»«t:NSCursor» «f:arrowCursor»«w:]»»;

  «k:if» («n:!»NSIsEmptyRect (visible))
    «:objc-font-lock-background-face:«w:[»«k:self» «f:addCursorRect»: visible «f:cursor»: currentCursor«w:]»»;
  «:objc-font-lock-background-face:«w:[»currentCursor «f:setOnMouseEntered»: «c:YES»«w:]»»;
}



«m:/*****************************************************************************»«x:/»
«m:/* »«x:Keyboard handling. */»
«p:#define» «v:NS_KEYLOG» 0

- («t:void»)«f:keyDown»: («t:NSEvent» *)«v:theEvent»
{
  «t:Mouse_HLInfo» *«v:hlinfo» = MOUSE_HL_INFO (emacsframe);
  «t:int» «v:code»;
  «t:unsigned» «v:fnKeysym» = 0;
  «k:static» «t:NSMutableArray» *«v:nsEvArray»;
«p:#if» «n:!»«p:defined» (NS_IMPL_COCOA) || MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_6
  «k:static» «t:BOOL» «v:firstTime» = «c:YES»;
«p:#endif»
  «t:int» «v:left_is_none»;
  «t:unsigned» «t:int» flags = «:objc-font-lock-background-face:«w:[»theEvent «f:modifierFlags»«w:]»»;

  NSTRACE (keyDown);

  «m:/* »«x:Rhapsody and OS X give up and down events for the arrow keys */»
  «k:if» (ns_fake_keydown == «c:YES»)
    ns_fake_keydown = «c:NO»;
  «k:else» «k:if» («:objc-font-lock-background-face:«w:[»theEvent «f:type»«w:]»» != NSKeyDown)
    «k:return»;

  «k:if» («n:!»emacs_event)
    «k:return»;

 «k:if» («n:!»«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:isKeyWindow»«w:]»»
     && «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:window»«w:]»» «f:isKindOfClass»: «:objc-font-lock-background-face:«w:[»«t:EmacsWindow» «f:class»«w:]»»«w:]»»
     «m:/* »«x:we must avoid an infinite loop here. */»
     && («t:EmacsView» *)«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:window»«w:]»» «f:delegate»«w:]»» != «k:self»)
   {
     «m:/* »«x:XXX: There is an occasional condition in which, when Emacs display
         updates a different frame from the current one, and temporarily
         selects it, then processes some interrupt-driven input
         (dispnew.c:3878), OS will send the event to the correct NSWindow, but
         for some reason that window has its first responder set to the NSView
         most recently updated (I guess), which is not the correct one. */»
     «:objc-font-lock-background-face:«w:[»(«t:EmacsView» *)«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:window»«w:]»» «f:delegate»«w:]»» «f:keyDown»: theEvent«w:]»»;
     «k:return»;
   }

  «k:if» (nsEvArray == «c:nil»)
    nsEvArray = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSMutableArray» «f:alloc»«w:]»» «f:initWithCapacity»: 1«w:]»»;

  «:objc-font-lock-background-face:«w:[»«t:NSCursor» «f:setHiddenUntilMouseMoves»: «c:YES»«w:]»»;

  «k:if» (hlinfo->mouse_face_hidden && INTEGERP (Vmouse_highlight))
    {
      clear_mouse_face (hlinfo);
      hlinfo->mouse_face_hidden = 1;
    }

  «k:if» («n:!»processingCompose)
    {
      «m:/* »«x:When using screen sharing, no left or right information is sent,
         so use Left key in those cases.  */»
      «t:int» «v:is_left_key», «v:is_right_key»;

      code = («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:charactersIgnoringModifiers»«w:]»» «f:length»«w:]»» == 0) ?
        0 : «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:charactersIgnoringModifiers»«w:]»» «f:characterAtIndex»: 0«w:]»»;

      «m:/* »«x:(Carbon way: [theEvent keyCode]) */»

      «m:/* »«x:is it a "function key"? */»
      fnKeysym = (code < 0x00ff && (flags&NSNumericPadKeyMask))
	? ns_convert_key («:objc-font-lock-background-face:«w:[»theEvent «f:keyCode»«w:]»» | NSNumericPadKeyMask)
	: ns_convert_key (code);

      «k:if» (fnKeysym)
        {
          «m:/* »«x:COUNTERHACK: map 'Delete' on upper-right main KB to 'Backspace',
             because Emacs treats Delete and KP-Delete same (in simple.el). */»
          «k:if» ((fnKeysym == 0xFFFF && «:objc-font-lock-background-face:«w:[»theEvent «f:keyCode»«w:]»» == 0x33)
«p:#ifdef» NS_IMPL_GNUSTEP
              «m:/*  »«x:GNUstep uses incompatible keycodes, even for those that are
                  supposed to be hardware independent.  Just check for delete.
                  Keypad delete does not have keysym 0xFFFF.
                  See http://savannah.gnu.org/bugs/?25395
              */»
              || (fnKeysym == 0xFFFF && code == 127)
«p:#endif»
            )
            code = 0xFF08; «m:/* »«x:backspace */»
          «k:else»
            code = fnKeysym;
        }

      «m:/* »«x:are there modifiers? */»
      emacs_event->modifiers = 0;

      «k:if» (flags & NSHelpKeyMask)
          emacs_event->modifiers |= hyper_modifier;

      «k:if» (flags & NSShiftKeyMask)
        emacs_event->modifiers |= shift_modifier;

      is_right_key = (flags & NSRightCommandKeyMask) == NSRightCommandKeyMask;
      is_left_key = (flags & NSLeftCommandKeyMask) == NSLeftCommandKeyMask
        || («n:!» is_right_key && (flags & NSCommandKeyMask) == NSCommandKeyMask);

      «k:if» (is_right_key)
        emacs_event->modifiers |= parse_solitary_modifier
          (EQ (ns_right_command_modifier, Qleft)
           ? ns_command_modifier
           : ns_right_command_modifier);

      «k:if» (is_left_key)
        {
          emacs_event->modifiers |= parse_solitary_modifier
            (ns_command_modifier);

          «m:/* »«x:if super (default), take input manager's word so things like
             dvorak / qwerty layout work */»
          «k:if» (EQ (ns_command_modifier, Qsuper)
              && «n:!»fnKeysym
              && «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:characters»«w:]»» «f:length»«w:]»» != 0)
            {
              «m:/* »«x:XXX: the code we get will be unshifted, so if we have
                 a shift modifier, must convert ourselves */»
              «k:if» («n:!»(flags & NSShiftKeyMask))
                code = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:characters»«w:]»» «f:characterAtIndex»: 0«w:]»»;
«p:#if» 0
              «m:/* »«x:this is ugly and also requires linking w/Carbon framework
                 (for LMGetKbdType) so for now leave this rare (?) case
                 undealt with.. in future look into CGEvent methods */»
              «k:else»
                {
                  «t:long» «v:smv» = GetScriptManagerVariable (smKeyScript);
                  «t:Handle» «v:uchrHandle» = GetResource
                    («s:'uchr'», GetScriptVariable (smv, smScriptKeys));
                  «t:UInt32» «v:dummy» = 0;
                  UCKeyTranslate ((«t:UCKeyboardLayout»*)*uchrHandle,
                                 «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:characters»«w:]»» «f:characterAtIndex»: 0«w:]»»,
                                 kUCKeyActionDisplay,
                                 (flags & ~NSCommandKeyMask) >> 8,
                                 «t:LMGetKbdType» (), kUCKeyTranslateNoDeadKeysMask,
                                 &dummy, 1, &dummy, &code);
                  code &= 0xFF;
                }
«p:#endif»
            }
        }

      is_right_key = (flags & NSRightControlKeyMask) == NSRightControlKeyMask;
      is_left_key = (flags & NSLeftControlKeyMask) == NSLeftControlKeyMask
        || («n:!» is_right_key && (flags & NSControlKeyMask) == NSControlKeyMask);

      «k:if» (is_right_key)
          emacs_event->modifiers |= parse_solitary_modifier
              (EQ (ns_right_control_modifier, Qleft)
               ? ns_control_modifier
               : ns_right_control_modifier);

      «k:if» (is_left_key)
        emacs_event->modifiers |= parse_solitary_modifier
          (ns_control_modifier);

      «k:if» (flags & NS_FUNCTION_KEY_MASK && «n:!»fnKeysym)
          emacs_event->modifiers |=
            parse_solitary_modifier (ns_function_modifier);

      left_is_none = NILP (ns_alternate_modifier)
        || EQ (ns_alternate_modifier, Qnone);

      is_right_key = (flags & NSRightAlternateKeyMask)
        == NSRightAlternateKeyMask;
      is_left_key = (flags & NSLeftAlternateKeyMask) == NSLeftAlternateKeyMask
        || («n:!» is_right_key
            && (flags & NSAlternateKeyMask) == NSAlternateKeyMask);

      «k:if» (is_right_key)
        {
          «k:if» ((NILP (ns_right_alternate_modifier)
               || EQ (ns_right_alternate_modifier, Qnone)
               || (EQ (ns_right_alternate_modifier, Qleft) && left_is_none))
              && «n:!»fnKeysym)
            {   «m:/* »«x:accept pre-interp alt comb */»
              «k:if» («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:characters»«w:]»» «f:length»«w:]»» > 0)
                code = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:characters»«w:]»» «f:characterAtIndex»: 0«w:]»»;
              «m:/*»«x:HACK: clear lone shift modifier to stop next if from firing */»
              «k:if» (emacs_event->modifiers == shift_modifier)
                emacs_event->modifiers = 0;
            }
          «k:else»
            emacs_event->modifiers |= parse_solitary_modifier
              (EQ (ns_right_alternate_modifier, Qleft)
               ? ns_alternate_modifier
               : ns_right_alternate_modifier);
        }

      «k:if» (is_left_key) «m:/* »«x:default = meta */»
        {
          «k:if» (left_is_none && «n:!»fnKeysym)
            {   «m:/* »«x:accept pre-interp alt comb */»
              «k:if» («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:characters»«w:]»» «f:length»«w:]»» > 0)
                code = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:characters»«w:]»» «f:characterAtIndex»: 0«w:]»»;
              «m:/*»«x:HACK: clear lone shift modifier to stop next if from firing */»
              «k:if» (emacs_event->modifiers == shift_modifier)
                emacs_event->modifiers = 0;
            }
          «k:else»
              emacs_event->modifiers |=
                parse_solitary_modifier (ns_alternate_modifier);
        }

  «k:if» (NS_KEYLOG)
    fprintf (stderr, «s:"keyDown: code =%x\tfnKey =%x\tflags = %x\tmods = %x\n"»,
             code, fnKeysym, flags, emacs_event->modifiers);

      «m:/* »«x:if it was a function key or had modifiers, pass it directly to emacs */»
      «k:if» (fnKeysym || (emacs_event->modifiers
                       && (emacs_event->modifiers != shift_modifier)
                       && «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»theEvent «f:charactersIgnoringModifiers»«w:]»» «f:length»«w:]»» > 0))
«m:/*»«x:[[theEvent characters] length] */»
        {
          emacs_event->kind = NON_ASCII_KEYSTROKE_EVENT;
          «k:if» (code < 0x20)
            code |= (1<<28)|(3<<16);
          «k:else» «k:if» (code == 0x7f)
            code |= (1<<28)|(3<<16);
          «k:else» «k:if» («n:!»fnKeysym)
            emacs_event->kind = code > 0xFF
              ? MULTIBYTE_CHAR_KEYSTROKE_EVENT : ASCII_KEYSTROKE_EVENT;

          emacs_event->code = code;
          EV_TRAILER (theEvent);
          processingCompose = «c:NO»;
          «k:return»;
        }
    }


«p:#if» «n:!»«p:defined» (NS_IMPL_COCOA) || MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_6
  «m:/* »«x:if we get here we should send the key for input manager processing */»
  «m:/* »«x:Disable warning, there is nothing a user can do about it anyway, and
     it does not seem to matter.  */»
«p:#if» 0
  «k:if» (firstTime && «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSInputManager» «f:currentInputManager»«w:]»»»
                     «:objc-font-lock-background-face:«f:wantsToDelayTextChangeNotifications»«w:]»» == «c:NO»)
    fprintf (stderr,
          «s:"Emacs: WARNING: TextInput mgr wants marked text to be permanent!\n"»);
«p:#endif»
  firstTime = «c:NO»;
«p:#endif»
  «k:if» (NS_KEYLOG && «n:!»processingCompose)
    fprintf (stderr, «s:"keyDown: Begin compose sequence.\n"»);

  processingCompose = «c:YES»;
  «:objc-font-lock-background-face:«w:[»nsEvArray «f:addObject»: theEvent«w:]»»;
  «:objc-font-lock-background-face:«w:[»«k:self» «f:interpretKeyEvents»: nsEvArray«w:]»»;
  «:objc-font-lock-background-face:«w:[»nsEvArray «f:removeObject»: theEvent«w:]»»;
}


«p:#ifdef» NS_IMPL_COCOA
«m:/* »«x:Needed to pick up Ctrl-tab and possibly other events that OS X has
   decided not to send key-down for.
   See http://osdir.com/ml/editors.vim.mac/2007-10/msg00141.html
   This only applies on Tiger and earlier.
   If it matches one of these, send it on to keyDown. */»
-(«t:void»)«f:keyUp»: («t:NSEvent» *)«v:theEvent»
{
  «t:int» «v:flags» = «:objc-font-lock-background-face:«w:[»theEvent «f:modifierFlags»«w:]»»;
  «t:int» «v:code» = «:objc-font-lock-background-face:«w:[»theEvent «f:keyCode»«w:]»»;
  «k:if» (floor (NSAppKitVersionNumber) <= 824 «m:/*»«x:NSAppKitVersionNumber10_4*/» &&
      code == 0x30 && (flags & NSControlKeyMask) && «n:!»(flags & NSCommandKeyMask))
    {
      «k:if» (NS_KEYLOG)
        fprintf (stderr, «s:"keyUp: passed test"»);
      ns_fake_keydown = «c:YES»;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:keyDown»: theEvent«w:]»»;
    }
}
«p:#endif»


«m:/* »«x:<NSTextInput> implementation (called through super interpretKeyEvents:]). */»


«m:/* »«x:<NSTextInput>: called when done composing;
   NOTE: also called when we delete over working text, followed immed.
         by doCommandBySelector: deleteBackward: */»
- («t:void»)«f:insertText»: («t:id»)«v:aString»
{
  «t:int» «v:code»;
  «t:int» «v:len» = «:objc-font-lock-background-face:«w:[»(«t:NSString» *)«t:aString» «f:length»«w:]»»;
  «t:int» «v:i»;

  «k:if» (NS_KEYLOG)
    NSLog (@«s:"insertText '%@'\tlen = %d"», aString, len);
  processingCompose = «c:NO»;

  «k:if» («n:!»emacs_event)
    «k:return»;

  «m:/* »«x:first, clear any working text */»
  «k:if» (workingText != «c:nil»)
    «:objc-font-lock-background-face:«w:[»«k:self» «f:deleteWorkingText»«w:]»»;

  «m:/* »«x:now insert the string as keystrokes */»
  «k:for» (i =0; i<len; i++)
    {
      code = «:objc-font-lock-background-face:«w:[»aString «f:characterAtIndex»: i«w:]»»;
      «m:/* »«x:TODO: still need this? */»
      «k:if» (code == 0x2DC)
        code = «s:'~'»; «m:/* »«x:0x7E */»
      «k:if» (code != 32) «m:/* »«x:Space */»
        emacs_event->modifiers = 0;
      emacs_event->kind
	= code > 0xFF ? MULTIBYTE_CHAR_KEYSTROKE_EVENT : ASCII_KEYSTROKE_EVENT;
      emacs_event->code = code;
      EV_TRAILER ((«t:id»)«c:nil»);
    }
}


«m:/* »«x:<NSTextInput>: inserts display of composing characters */»
- («t:void»)«f:setMarkedText»: («t:id»)«v:aString» «f:selectedRange»: («t:NSRange»)«v:selRange»
{
  «t:NSString» *«v:str» = «:objc-font-lock-background-face:«w:[»aString «f:respondsToSelector»: «k:@selector» (string)«w:]»» ?
    «:objc-font-lock-background-face:«w:[»aString «f:string»«w:]»» : aString;
  «k:if» (NS_KEYLOG)
    NSLog (@«s:"setMarkedText '%@' len =%lu range %lu from %lu"»,
           str, («t:unsigned» «t:long»)«:objc-font-lock-background-face:«w:[»str «f:length»«w:]»»,
           («t:unsigned» «t:long»)selRange.length,
           («t:unsigned» «t:long»)selRange.location);

  «k:if» (workingText != «c:nil»)
    «:objc-font-lock-background-face:«w:[»«k:self» «f:deleteWorkingText»«w:]»»;
  «k:if» («:objc-font-lock-background-face:«w:[»str «f:length»«w:]»» == 0)
    «k:return»;

  «k:if» («n:!»emacs_event)
    «k:return»;

  processingCompose = «c:YES»;
  workingText = «:objc-font-lock-background-face:«w:[»str «f:copy»«w:]»»;
  ns_working_text = build_string («:objc-font-lock-background-face:«w:[»workingText «f:UTF8String»«w:]»»);

  emacs_event->kind = NS_TEXT_EVENT;
  emacs_event->code = KEY_NS_PUT_WORKING_TEXT;
  EV_TRAILER ((«t:id»)«c:nil»);
}


«m:/* »«x:delete display of composing characters [not in <NSTextInput>] */»
- («t:void»)«f:deleteWorkingText»
{
  «k:if» (workingText == «c:nil»)
    «k:return»;
  «k:if» (NS_KEYLOG)
    NSLog(@«s:"deleteWorkingText len =%lu\n"», («t:unsigned» «t:long»)«:objc-font-lock-background-face:«w:[»workingText «f:length»«w:]»»);
  «:objc-font-lock-background-face:«w:[»workingText «f:release»«w:]»»;
  workingText = «c:nil»;
  processingCompose = «c:NO»;

  «k:if» («n:!»emacs_event)
    «k:return»;

  emacs_event->kind = NS_TEXT_EVENT;
  emacs_event->code = KEY_NS_UNPUT_WORKING_TEXT;
  EV_TRAILER ((«t:id»)«c:nil»);
}


- («t:BOOL»)«f:hasMarkedText»
{
  «k:return» workingText != «c:nil»;
}


- («t:NSRange»)«f:markedRange»
{
  «t:NSRange» «v:rng» = workingText != «c:nil»
    ? NSMakeRange (0, «:objc-font-lock-background-face:«w:[»workingText «f:length»«w:]»») : NSMakeRange (NSNotFound, 0);
  «k:if» (NS_KEYLOG)
    NSLog (@«s:"markedRange request"»);
  «k:return» rng;
}


- («t:void»)«f:unmarkText»
{
  «k:if» (NS_KEYLOG)
    NSLog (@«s:"unmark (accept) text"»);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:deleteWorkingText»«w:]»»;
  processingCompose = «c:NO»;
}


«m:/* »«x:used to position char selection windows, etc. */»
- («t:NSRect»)«f:firstRectForCharacterRange»: («t:NSRange»)«v:theRange»
{
  «t:NSRect» «v:rect»;
  «t:NSPoint» «v:pt»;
  «k:struct» «t:window» *«t:win» = XWINDOW (FRAME_SELECTED_WINDOW (emacsframe));
  «k:if» (NS_KEYLOG)
    NSLog (@«s:"firstRectForCharRange request"»);

  rect.size.width = theRange.length * FRAME_COLUMN_WIDTH (emacsframe);
  rect.size.height = FRAME_LINE_HEIGHT (emacsframe);
  pt.x = WINDOW_TEXT_TO_FRAME_PIXEL_X (win, win->phys_cursor.x);
  pt.y = WINDOW_TO_FRAME_PIXEL_Y (win, win->phys_cursor.y
                                       +FRAME_LINE_HEIGHT (emacsframe));

  pt = «:objc-font-lock-background-face:«w:[»«k:self» «f:convertPoint»: pt «f:toView»: «c:nil»«w:]»»;
  pt = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:convertBaseToScreen»: pt«w:]»»;
  rect.origin = pt;
  «k:return» rect;
}


- («t:NSInteger»)«f:conversationIdentifier»
{
  «k:return» («t:NSInteger»)«k:self»;
}


- («t:void»)«f:doCommandBySelector»: («t:SEL»)«v:aSelector»
{
  «k:if» (NS_KEYLOG)
    NSLog (@«s:"doCommandBySelector: %@"», «t:NSStringFromSelector» («v:aSelector»));

  processingCompose = «c:NO»;
  «k:if» (aSelector == «k:@selector» (deleteBackward:))
    {
      «m:/* »«x:happens when user backspaces over an ongoing composition:
         throw a 'delete' into the event queue */»
      «k:if» («n:!»emacs_event)
        «k:return»;
      emacs_event->kind = NON_ASCII_KEYSTROKE_EVENT;
      emacs_event->code = 0xFF08;
      EV_TRAILER ((«t:id»)«c:nil»);
    }
}

- («t:NSArray» *)«f:validAttributesForMarkedText»
{
  «k:static» «t:NSArray» *«v:arr» = «c:nil»;
  «k:if» (arr == «c:nil») arr = «:objc-font-lock-background-face:«w:[»«t:NSArray» «f:new»«w:]»»;
 «m:/* »«x:[[NSArray arrayWithObject: NSUnderlineStyleAttributeName] retain]; */»
  «k:return» arr;
}

- («t:NSRange»)«f:selectedRange»
{
  «k:if» (NS_KEYLOG)
    NSLog (@«s:"selectedRange request"»);
  «k:return» NSMakeRange (NSNotFound, 0);
}

«p:#if» «p:defined» (NS_IMPL_COCOA) || GNUSTEP_GUI_MAJOR_VERSION > 0 || \
    GNUSTEP_GUI_MINOR_VERSION > 22
- («t:NSUInteger»)«f:characterIndexForPoint»: («t:NSPoint»)«v:thePoint»
«p:#else»
- («t:unsigned» «t:int»)characterIndexForPoint: («t:NSPoint»)thePoint
«p:#endif»
{
  «k:if» (NS_KEYLOG)
    NSLog (@«s:"characterIndexForPoint request"»);
  «k:return» 0;
}

- («t:NSAttributedString» *)«f:attributedSubstringFromRange»: («t:NSRange»)«v:theRange»
{
  «k:static» «t:NSAttributedString» *«v:str» = «c:nil»;
  «k:if» (str == «c:nil») str = «:objc-font-lock-background-face:«w:[»«t:NSAttributedString» «f:new»«w:]»»;
  «k:if» (NS_KEYLOG)
    NSLog (@«s:"attributedSubstringFromRange request"»);
  «k:return» str;
}

«m:/* »«x:End <NSTextInput> impl. */»
«m:/*****************************************************************************»«x:/»


«m:/* »«x:This is what happens when the user presses a mouse button.  */»
- («t:void»)«f:mouseDown»: («t:NSEvent» *)«v:theEvent»
{
  «k:struct» «t:ns_display_info» *«t:dpyinfo» = FRAME_DISPLAY_INFO (emacsframe);
  «t:NSPoint» «v:p» = «:objc-font-lock-background-face:«w:[»«k:self» «f:convertPoint»: «:objc-font-lock-background-face:«w:[»theEvent «f:locationInWindow»«w:]»» «f:fromView»: «c:nil»«w:]»»;

  NSTRACE (mouseDown);

  «:objc-font-lock-background-face:«w:[»«k:self» «f:deleteWorkingText»«w:]»»;

  «k:if» («n:!»emacs_event)
    «k:return»;

  dpyinfo->last_mouse_frame = emacsframe;
  «m:/* »«x:appears to be needed to prevent spurious movement events generated on
     button clicks */»
  emacsframe->mouse_moved = 0;

  «k:if» («:objc-font-lock-background-face:«w:[»theEvent «f:type»«w:]»» == NSScrollWheel)
    {
      «t:CGFloat» «v:delta» = «:objc-font-lock-background-face:«w:[»theEvent «f:deltaY»«w:]»»;
      «m:/* »«x:Mac notebooks send wheel events w/delta =0 when trackpad scrolling */»
      «k:if» (delta == 0)
        {
          delta = «:objc-font-lock-background-face:«w:[»theEvent «f:deltaX»«w:]»»;
          «k:if» (delta == 0)
            {
              NSTRACE (deltaIsZero);
              «k:return»;
            }
          emacs_event->kind = HORIZ_WHEEL_EVENT;
        }
      «k:else»
        emacs_event->kind = WHEEL_EVENT;

      emacs_event->code = 0;
      emacs_event->modifiers = EV_MODIFIERS (theEvent) |
        ((delta > 0) ? up_modifier : down_modifier);
    }
  «k:else»
    {
      emacs_event->kind = MOUSE_CLICK_EVENT;
      emacs_event->code = EV_BUTTON (theEvent);
      emacs_event->modifiers = EV_MODIFIERS (theEvent)
                             | EV_UDMODIFIERS (theEvent);
    }
  XSETINT (emacs_event->x, lrint (p.x));
  XSETINT (emacs_event->y, lrint (p.y));
  EV_TRAILER (theEvent);
}


- («t:void»)«f:rightMouseDown»: («t:NSEvent» *)«v:theEvent»
{
  NSTRACE (rightMouseDown);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseDown»: theEvent«w:]»»;
}


- («t:void»)«f:otherMouseDown»: («t:NSEvent» *)«v:theEvent»
{
  NSTRACE (otherMouseDown);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseDown»: theEvent«w:]»»;
}


- («t:void»)«f:mouseUp»: («t:NSEvent» *)«v:theEvent»
{
  NSTRACE (mouseUp);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseDown»: theEvent«w:]»»;
}


- («t:void»)«f:rightMouseUp»: («t:NSEvent» *)«v:theEvent»
{
  NSTRACE (rightMouseUp);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseDown»: theEvent«w:]»»;
}


- («t:void»)«f:otherMouseUp»: («t:NSEvent» *)«v:theEvent»
{
  NSTRACE (otherMouseUp);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseDown»: theEvent«w:]»»;
}


- («t:void») «f:scrollWheel»: («t:NSEvent» *)«v:theEvent»
{
  NSTRACE (scrollWheel);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseDown»: theEvent«w:]»»;
}


«m:/* »«x:Tell emacs the mouse has moved. */»
- («t:void»)«f:mouseMoved»: («t:NSEvent» *)«v:e»
{
  «t:Mouse_HLInfo» *«v:hlinfo» = MOUSE_HL_INFO (emacsframe);
  «k:struct» «t:ns_display_info» *«t:dpyinfo» = FRAME_DISPLAY_INFO (emacsframe);
  «t:Lisp_Object» «v:frame»;
  «t:NSPoint» «v:pt»;

«m://  »«x:NSTRACE (mouseMoved);
»
  dpyinfo->last_mouse_movement_time = EV_TIMESTAMP (e);
  pt = «:objc-font-lock-background-face:«w:[»«k:self» «f:convertPoint»: «:objc-font-lock-background-face:«w:[»e «f:locationInWindow»«w:]»» «f:fromView»: «c:nil»«w:]»»;
  dpyinfo->last_mouse_motion_x = pt.x;
  dpyinfo->last_mouse_motion_y = pt.y;

  «m:/* »«x:update any mouse face */»
  «k:if» (hlinfo->mouse_face_hidden)
    {
      hlinfo->mouse_face_hidden = 0;
      clear_mouse_face (hlinfo);
    }

  «m:/* »«x:tooltip handling */»
  previous_help_echo_string = help_echo_string;
  help_echo_string = Qnil;

  «k:if» («n:!»NILP (Vmouse_autoselect_window))
    {
      NSTRACE (mouse_autoselect_window);
      «k:static» «t:Lisp_Object» «v:last_mouse_window»;
      «t:Lisp_Object» «v:window»
	= window_from_coordinates (emacsframe, pt.x, pt.y, 0, 0);

      «k:if» (WINDOWP (window)
          && «n:!»EQ (window, last_mouse_window)
          && «n:!»EQ (window, selected_window)
          && (focus_follows_mouse
              || (EQ (XWINDOW (window)->frame,
                      XWINDOW (selected_window)->frame))))
        {
          NSTRACE (in_window);
          emacs_event->kind = SELECT_WINDOW_EVENT;
          emacs_event->frame_or_window = window;
          EV_TRAILER2 (e);
        }
      «m:/* »«x:Remember the last window where we saw the mouse.  */»
      last_mouse_window = window;
    }

  «k:if» («n:!»note_mouse_movement (emacsframe, pt.x, pt.y))
    help_echo_string = previous_help_echo_string;

  XSETFRAME (frame, emacsframe);
  «k:if» («n:!»NILP (help_echo_string) || «n:!»NILP (previous_help_echo_string))
    {
      «m:/* »«x:NOTE: help_echo_{window,pos,object} are set in xdisp.c
         (note_mouse_highlight), which is called through the
         note_mouse_movement () call above */»
      gen_help_event (help_echo_string, frame, help_echo_window,
                      help_echo_object, help_echo_pos);
    }
  «k:else»
    {
      help_echo_string = Qnil;
      gen_help_event (Qnil, frame, Qnil, Qnil, 0);
    }

  «k:if» (emacsframe->mouse_moved && send_appdefined)
    ns_send_appdefined (-1);
}


- («t:void»)«f:mouseDragged»: («t:NSEvent» *)«v:e»
{
  NSTRACE (mouseDragged);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseMoved»: e«w:]»»;
}


- («t:void»)«f:rightMouseDragged»: («t:NSEvent» *)«v:e»
{
  NSTRACE (rightMouseDragged);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseMoved»: e«w:]»»;
}


- («t:void»)«f:otherMouseDragged»: («t:NSEvent» *)«v:e»
{
  NSTRACE (otherMouseDragged);
  «:objc-font-lock-background-face:«w:[»«k:self» «f:mouseMoved»: e«w:]»»;
}


- («t:BOOL»)«f:windowShouldClose»: («t:id»)«v:sender»
{
  «t:NSEvent» *«v:e» =«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:currentEvent»«w:]»»;

  NSTRACE (windowShouldClose);
  windowClosing = «c:YES»;
  «k:if» («n:!»emacs_event)
    «k:return» «c:NO»;
  emacs_event->kind = DELETE_WINDOW_EVENT;
  emacs_event->modifiers = 0;
  emacs_event->code = 0;
  EV_TRAILER (e);
  «m:/* »«x:Don't close this window, let this be done from lisp code.  */»
  «k:return» «c:NO»;
}

- («t:void») «f:updateFrameSize»: («t:BOOL») «v:delay»;
{
  «t:NSWindow» *«v:window» = «:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»»;
  «t:NSRect» «v:wr» = «:objc-font-lock-background-face:«w:[»window «f:frame»«w:]»»;
  «t:int» «v:extra» = 0;
  «t:int» «v:oldc» = cols, «v:oldr» = rows;
  «t:int» «v:oldw» = FRAME_PIXEL_WIDTH (emacsframe);
  «t:int» «v:oldh» = FRAME_PIXEL_HEIGHT (emacsframe);
  «t:int» «v:neww», «v:newh»;

  NSTRACE (updateFrameSize);
  NSTRACE_SIZE («s:"Original size"», NSMakeSize (oldw, oldh));

  «k:if» («n:!» «:objc-font-lock-background-face:«w:[»«k:self» «f:isFullscreen»«w:]»»)
    {
«p:#ifdef» NS_IMPL_GNUSTEP
      «m:// »«x:GNUStep does not always update the tool bar height.  Force it.
»      «k:if» (toolbar) update_frame_tool_bar (emacsframe);
«p:#endif»

      extra = FRAME_NS_TITLEBAR_HEIGHT (emacsframe)
        + «f:FRAME_TOOLBAR_HEIGHT» (emacsframe);
    }

  neww = («t:int»)wr.size.width - emacsframe->border_width;
  newh = («t:int»)wr.size.height - extra;

  cols = FRAME_PIXEL_WIDTH_TO_TEXT_COLS (emacsframe, neww);
  rows = FRAME_PIXEL_HEIGHT_TO_TEXT_LINES (emacsframe, newh);

  «k:if» (cols < MINWIDTH)
    cols = MINWIDTH;

  «k:if» (rows < MINHEIGHT)
    rows = MINHEIGHT;

  «k:if» (oldr != rows || oldc != cols || neww != oldw || newh != oldh)
    {
      «t:NSView» *«v:view» = FRAME_NS_VIEW (emacsframe);
      «t:NSWindow» *«v:win» = «:objc-font-lock-background-face:«w:[»view «f:window»«w:]»»;
      «t:NSSize» «v:sz» = «:objc-font-lock-background-face:«w:[»win «f:resizeIncrements»«w:]»»;

      change_frame_size (emacsframe,
                         FRAME_PIXEL_TO_TEXT_WIDTH (emacsframe, neww),
                         FRAME_PIXEL_TO_TEXT_HEIGHT (emacsframe, newh),
                         0, delay, 0, 1);
      SET_FRAME_GARBAGED (emacsframe);
      cancel_mouse_face (emacsframe);

      «m:// »«x:Did resize increments change because of a font change?
»      «k:if» (sz.width != FRAME_COLUMN_WIDTH (emacsframe) ||
          sz.height != FRAME_LINE_HEIGHT (emacsframe))
        {
          sz.width = FRAME_COLUMN_WIDTH (emacsframe);
          sz.height = FRAME_LINE_HEIGHT (emacsframe);
          «:objc-font-lock-background-face:«w:[»win «f:setResizeIncrements»: sz«w:]»»;

          NSTRACE_SIZE («s:"New size"», NSMakeSize (neww, newh));
        }

      «:objc-font-lock-background-face:«w:[»view «f:setFrame»: NSMakeRect (0, 0, neww, newh)«w:]»»;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:windowDidMove»:«c:nil»«w:]»»;   «m:// »«x:Update top/left.
»    }
}

- («t:NSSize»)«f:windowWillResize»: («t:NSWindow» *)«v:sender» «f:toSize»: («t:NSSize»)«v:frameSize»
«m:/* »«x:normalize frame to gridded text size */»
{
  «t:int» «v:extra» = 0;

  NSTRACE (windowWillResize);
  NSTRACE_SIZE («s:"Original size"», frameSize);
«m:/*»«x:fprintf (stderr,"Window will resize: %.0f x %.0f\n",frameSize.width,frameSize.height); */»

  «k:if» (fs_state == FULLSCREEN_MAXIMIZED
      && (maximized_width != («t:int»)frameSize.width
          || maximized_height != («t:int»)frameSize.height))
    «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: FULLSCREEN_NONE«w:]»»;
  «k:else» «k:if» (fs_state == FULLSCREEN_WIDTH
           && maximized_width != («t:int»)frameSize.width)
    «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: FULLSCREEN_NONE«w:]»»;
  «k:else» «k:if» (fs_state == FULLSCREEN_HEIGHT
           && maximized_height != («t:int»)frameSize.height)
    «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: FULLSCREEN_NONE«w:]»»;
  «k:if» (fs_state == FULLSCREEN_NONE)
    maximized_width = maximized_height = -1;

  «k:if» («n:!» «:objc-font-lock-background-face:«w:[»«k:self» «f:isFullscreen»«w:]»»)
    {
      extra = FRAME_NS_TITLEBAR_HEIGHT (emacsframe)
        + «f:FRAME_TOOLBAR_HEIGHT» (emacsframe);
    }

  cols = FRAME_PIXEL_WIDTH_TO_TEXT_COLS (emacsframe, frameSize.width);
  «k:if» (cols < MINWIDTH)
    cols = MINWIDTH;

  rows = FRAME_PIXEL_HEIGHT_TO_TEXT_LINES (emacsframe,
                                           frameSize.height - extra);
  «k:if» (rows < MINHEIGHT)
    rows = MINHEIGHT;
«p:#ifdef» NS_IMPL_COCOA
  {
    «m:/* »«x:this sets window title to have size in it; the wm does this under GS */»
    «t:NSRect» «v:r» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:frame»«w:]»»;
    «k:if» (r.size.height == frameSize.height && r.size.width == frameSize.width)
      {
        «k:if» (old_title != 0)
          {
            xfree (old_title);
            old_title = 0;
          }
      }
    «k:else» «k:if» (fs_state == FULLSCREEN_NONE && «n:!» maximizing_resize)
      {
        «t:char» *«v:size_title»;
        «t:NSWindow» *«v:window» = «:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»»;
        «k:if» (old_title == 0)
          {
            «t:char» *«v:t» = strdup («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:title»«w:]»» «f:UTF8String»«w:]»»);
            «m:/* »«x:MODIFIED: Unicode dash replaced with "-" */»
            «t:char» *«v:pos» = strstr (t, «s:"  -  "»);
            «k:if» (pos)
              *pos = «s:'\0'»;
            old_title = t;
          }
        size_title = xmalloc (strlen (old_title) + 40);
        «m:/* »«x:MODIFIED: Unicode dash replaced with "-" */»
	esprintf (size_title, «s:"%s  -  (%d x %d)"», old_title, cols, rows);
        «:objc-font-lock-background-face:«w:[»window «f:setTitle»: «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»: size_title«w:]»»«w:]»»;
        «:objc-font-lock-background-face:«w:[»window «f:display»«w:]»»;
        xfree (size_title);
      }
  }
«p:#endif» «m:/* »«x:NS_IMPL_COCOA */»
«m:/*»«x:fprintf (stderr,"    ...size became %.0f x %.0f  (%d x %d)\n",frameSize.width,frameSize.height,cols,rows); */»

  «k:return» frameSize;
}


- («t:void»)«f:windowDidResize»: («t:NSNotification» *)«v:notification»
{
  «k:if» («n:!» «:objc-font-lock-background-face:«w:[»«k:self» «f:fsIsNative»«w:]»»)
    {
      «t:NSWindow» *«v:theWindow» = «:objc-font-lock-background-face:«w:[»notification «f:object»«w:]»»;
      «m:/* »«x:We can get notification on the non-FS window when in
         fullscreen mode.  */»
      «k:if» («:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» != theWindow) «k:return»;
    }

«p:#ifdef» NS_IMPL_GNUSTEP
  «t:NSWindow» *«v:theWindow» = «:objc-font-lock-background-face:«w:[»notification «f:object»«w:]»»;

   «m:/* »«x:In GNUstep, at least currently, it's possible to get a didResize
      without getting a willResize.. therefore we need to act as if we got
      the willResize now */»
  «t:NSSize» «v:sz» = «:objc-font-lock-background-face:«w:[»theWindow «f:frame»«w:]»».size;
  sz = «:objc-font-lock-background-face:«w:[»«k:self» «f:windowWillResize»: theWindow «f:toSize»: sz«w:]»»;
«p:#endif» «m:/* »«x:NS_IMPL_GNUSTEP */»

  NSTRACE (windowDidResize);
«m:/*»«x:fprintf (stderr,"windowDidResize: %.0f\n",[theWindow frame].size.height); */»

«k:if» (cols > 0 && rows > 0)
    {
      «:objc-font-lock-background-face:«w:[»«k:self» «f:updateFrameSize»: «c:YES»«w:]»»;
    }

  ns_send_appdefined (-1);
}

«p:#ifdef» NS_IMPL_COCOA
- («t:void»)«f:viewDidEndLiveResize»
{
  «:objc-font-lock-background-face:«w:[»«k:super» «f:viewDidEndLiveResize»«w:]»»;
  «k:if» (old_title != 0)
    {
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:setTitle»: «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»: old_title«w:]»»«w:]»»;
      xfree (old_title);
      old_title = 0;
    }
  maximizing_resize = «c:NO»;
}
«p:#endif» «m:/* »«x:NS_IMPL_COCOA */»


- («t:void»)«f:windowDidBecomeKey»: («t:NSNotification» *)«v:notification»
«m:/* »«x:cf. x_detect_focus_change(), x_focus_changed(), x_new_focus_frame() */»
{
  «k:struct» «t:ns_display_info» *«t:dpyinfo» = FRAME_DISPLAY_INFO (emacsframe);
  «k:struct» «t:frame» *«t:old_focus» = dpyinfo->x_focus_frame;

  NSTRACE (windowDidBecomeKey);

  «k:if» (emacsframe != old_focus)
    dpyinfo->x_focus_frame = emacsframe;

  ns_frame_rehighlight (emacsframe);

  «k:if» (emacs_event)
    {
      emacs_event->kind = FOCUS_IN_EVENT;
      EV_TRAILER ((«t:id»)«c:nil»);
    }
}


- («t:void»)«f:windowDidResignKey»: («t:NSNotification» *)«v:notification»
«m:/* »«x:cf. x_detect_focus_change(), x_focus_changed(), x_new_focus_frame() */»
{
  «k:struct» «t:ns_display_info» *«t:dpyinfo» = FRAME_DISPLAY_INFO (emacsframe);
  «t:BOOL» «v:is_focus_frame» = dpyinfo->x_focus_frame == emacsframe;
  NSTRACE (windowDidResignKey);

  «k:if» (is_focus_frame)
    dpyinfo->x_focus_frame = 0;

  emacsframe->mouse_moved = 0;
  ns_frame_rehighlight (emacsframe);

  «m:/* »«x:FIXME: for some reason needed on second and subsequent clicks away
            from sole-frame Emacs to get hollow box to show */»
  «k:if» («n:!»windowClosing && «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:isVisible»«w:]»» == «c:YES»)
    {
      x_update_cursor (emacsframe, 1);
      x_set_frame_alpha (emacsframe);
    }

  «k:if» (emacs_event && is_focus_frame)
    {
      «:objc-font-lock-background-face:«w:[»«k:self» «f:deleteWorkingText»«w:]»»;
      emacs_event->kind = FOCUS_OUT_EVENT;
      EV_TRAILER ((«t:id»)«c:nil»);
    }
}


- («t:void»)«f:windowWillMiniaturize»: «v:sender»
{
  NSTRACE (windowWillMiniaturize);
}


- («t:BOOL»)«f:isFlipped»
{
  «k:return» «c:YES»;
}


- («t:BOOL»)«f:isOpaque»
{
  «k:return» «c:NO»;
}


- «f:initFrameFromEmacs»: («k:struct» «t:frame» *)«v:f»
{
  «t:NSRect» «v:r», «v:wr»;
  «t:Lisp_Object» «v:tem»;
  «t:NSWindow» *«v:win»;
  «t:NSSize» «v:sz»;
  «t:NSColor» *«v:col»;
  «t:NSString» *«v:name»;

  NSTRACE (initFrameFromEmacs);

  windowClosing = «c:NO»;
  processingCompose = «c:NO»;
  scrollbarsNeedingUpdate = 0;
  fs_state = FULLSCREEN_NONE;
  fs_before_fs = next_maximized = -1;
«p:#ifdef» HAVE_NATIVE_FS
  fs_is_native = ns_use_native_fullscreen;
«p:#else»
  fs_is_native = «c:NO»;
«p:#endif»
  maximized_width = maximized_height = -1;
  nonfs_window = «c:nil»;

«m:/*»«x:fprintf (stderr,"init with %d, %d\n",f->text_cols, f->text_lines); */»

  ns_userRect = NSMakeRect (0, 0, 0, 0);
  r = NSMakeRect (0, 0, FRAME_TEXT_COLS_TO_PIXEL_WIDTH (f, f->text_cols),
                 FRAME_TEXT_LINES_TO_PIXEL_HEIGHT (f, f->text_lines));
  «:objc-font-lock-background-face:«w:[»«k:self» «f:initWithFrame»: r«w:]»»;
  «:objc-font-lock-background-face:«w:[»«k:self» «f:setAutoresizingMask»: NSViewWidthSizable | NSViewHeightSizable«w:]»»;

  FRAME_NS_VIEW (f) = «k:self»;
  emacsframe = f;
«p:#ifdef» NS_IMPL_COCOA
  old_title = 0;
  maximizing_resize = «c:NO»;
«p:#endif»

  win = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsWindow» «f:alloc»«w:]»»»
            «:objc-font-lock-background-face:«f:initWithContentRect»: r»
                      «:objc-font-lock-background-face:«f:styleMask»: (NSResizableWindowMask |»
«:objc-font-lock-background-face:«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7»
                                  «:objc-font-lock-background-face:NSTitledWindowMask |»
«:objc-font-lock-background-face:«p:#endif»»
                                  «:objc-font-lock-background-face:NSMiniaturizableWindowMask |»
                                  «:objc-font-lock-background-face:NSClosableWindowMask)»
                        «:objc-font-lock-background-face:«f:backing»: NSBackingStoreBuffered»
                          «:objc-font-lock-background-face:«f:defer»: «c:YES»«w:]»»;

«p:#ifdef» HAVE_NATIVE_FS
    «:objc-font-lock-background-face:«w:[»win «f:setCollectionBehavior»:NSWindowCollectionBehaviorFullScreenPrimary«w:]»»;
«p:#endif»

  wr = «:objc-font-lock-background-face:«w:[»win «f:frame»«w:]»»;
  bwidth = f->border_width = wr.size.width - r.size.width;
  tibar_height = FRAME_NS_TITLEBAR_HEIGHT (f) = wr.size.height - r.size.height;

  «:objc-font-lock-background-face:«w:[»win «f:setAcceptsMouseMovedEvents»: «c:YES»«w:]»»;
  «:objc-font-lock-background-face:«w:[»win «f:setDelegate»: «k:self»«w:]»»;
  «:objc-font-lock-background-face:«w:[»win «f:useOptimizedDrawing»: «c:YES»«w:]»»;

  sz.width = FRAME_COLUMN_WIDTH (f);
  sz.height = FRAME_LINE_HEIGHT (f);
  «:objc-font-lock-background-face:«w:[»win «f:setResizeIncrements»: sz«w:]»»;

  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»win «f:contentView»«w:]»» «f:addSubview»: «k:self»«w:]»»;

  «k:if» (ns_drag_types)
    «:objc-font-lock-background-face:«w:[»«k:self» «f:registerForDraggedTypes»: ns_drag_types«w:]»»;

  tem = f->name;
  name = «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»:»
                   «:objc-font-lock-background-face:NILP (tem) ? «s:"Emacs"» : SSDATA (tem)«w:]»»;
  «:objc-font-lock-background-face:«w:[»win «f:setTitle»: name«w:]»»;

  «m:/* »«x:toolbar support */»
  toolbar = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsToolbar» «f:alloc»«w:]»» «f:initForView»: «k:self» «f:withIdentifier»:»
                         «:objc-font-lock-background-face:«:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithFormat»: @«s:"Emacs Frame %d"»,»»
                                   «:objc-font-lock-background-face:«:objc-font-lock-background-face:ns_window_num«w:]»»«w:]»»;
  «:objc-font-lock-background-face:«w:[»win «f:setToolbar»: toolbar«w:]»»;
  «:objc-font-lock-background-face:«w:[»toolbar «f:setVisible»: «c:NO»«w:]»»;
«p:#ifdef» NS_IMPL_COCOA
  {
    «t:NSButton» *«v:toggleButton»;
  toggleButton = «:objc-font-lock-background-face:«w:[»win «f:standardWindowButton»: NSWindowToolbarButton«w:]»»;
  «:objc-font-lock-background-face:«w:[»toggleButton «f:setTarget»: «k:self»«w:]»»;
  «:objc-font-lock-background-face:«w:[»toggleButton «f:setAction»: «k:@selector» (toggleToolbar: )«w:]»»;
  }
«p:#endif»
  FRAME_TOOLBAR_HEIGHT (f) = 0;

  tem = f->icon_name;
  «k:if» («n:!»NILP (tem))
    «:objc-font-lock-background-face:«w:[»win «f:setMiniwindowTitle»:»
           «:objc-font-lock-background-face:«:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»: SSDATA (tem)«w:]»»«w:]»»;

  {
    «t:NSScreen» *«v:screen» = «:objc-font-lock-background-face:«w:[»win «f:screen»«w:]»»;

    «k:if» (screen != 0)
      «:objc-font-lock-background-face:«w:[»win «f:setFrameTopLeftPoint»: NSMakePoint»
           «:objc-font-lock-background-face:(IN_BOUND (-«f:SCREENMAX», f->left_pos, SCREENMAX),»
            «:objc-font-lock-background-face:IN_BOUND (-«f:SCREENMAX»,»
                     «:objc-font-lock-background-face:«:objc-font-lock-background-face:«w:[»screen «f:frame»«w:]»».size.height - NS_TOP_POS (f), SCREENMAX))«w:]»»;
  }

  «:objc-font-lock-background-face:«w:[»win «f:makeFirstResponder»: «k:self»«w:]»»;

  col = ns_lookup_indexed_color (NS_FACE_BACKGROUND
                                  (FRAME_DEFAULT_FACE (emacsframe)), emacsframe);
  «:objc-font-lock-background-face:«w:[»win «f:setBackgroundColor»: col«w:]»»;
  «k:if» («:objc-font-lock-background-face:«w:[»col «f:alphaComponent»«w:]»» != («t:EmacsCGFloat») 1.0)
    «:objc-font-lock-background-face:«w:[»win «f:setOpaque»: «c:NO»«w:]»»;

  «:objc-font-lock-background-face:«w:[»«k:self» «f:allocateGState»«w:]»»;

  «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:registerServicesMenuSendTypes»: ns_send_types»
                           «:objc-font-lock-background-face:«f:returnTypes»: «c:nil»«w:]»»;

  ns_window_num++;
  «k:return» «k:self»;
}


- («t:void»)«f:windowDidMove»: «v:sender»
{
  «t:NSWindow» *«v:win» = «:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»»;
  «t:NSRect» «v:r» = «:objc-font-lock-background-face:«w:[»win «f:frame»«w:]»»;
  «t:NSArray» *«v:screens» = «:objc-font-lock-background-face:«w:[»«t:NSScreen» «f:screens»«w:]»»;
  «t:NSScreen» *«v:screen» = «:objc-font-lock-background-face:«w:[»screens «f:objectAtIndex»: 0«w:]»»;

  NSTRACE (windowDidMove);

  «k:if» («n:!»emacsframe->output_data.ns)
    «k:return»;
  «k:if» (screen != «c:nil»)
    {
      emacsframe->left_pos = r.origin.x;
      emacsframe->top_pos =
        «:objc-font-lock-background-face:«w:[»screen «f:frame»«w:]»».size.height - (r.origin.y + r.size.height);
    }
}


«m:/* »«x:Called AFTER method below, but before our windowWillResize call there leads
   to windowDidResize -> x_set_window_size.  Update emacs' notion of frame
   location so set_window_size moves the frame. */»
- («t:BOOL»)«f:windowShouldZoom»: («t:NSWindow» *)«v:sender» «f:toFrame»: («t:NSRect»)«v:newFrame»
{
  emacsframe->output_data.ns->zooming = 1;
  «k:return» «c:YES»;
}


«m:/* »«x:Override to do something slightly nonstandard, but nice.  First click on
   zoom button will zoom vertically.  Second will zoom completely.  Third
   returns to original. */»
- («t:NSRect»)«f:windowWillUseStandardFrame»:(«t:NSWindow» *)«v:sender»
                        «f:defaultFrame»:(«t:NSRect»)«v:defaultFrame»
{
  «t:NSRect» «v:result» = «:objc-font-lock-background-face:«w:[»sender «f:frame»«w:]»»;

  NSTRACE (windowWillUseStandardFrame);

  «k:if» (fs_before_fs != -1) «m:/* »«x:Entering fullscreen */»
      {
        result = defaultFrame;
      }
  «k:else» «k:if» (next_maximized == FULLSCREEN_HEIGHT
      || (next_maximized == -1
          && abs (defaultFrame.size.height - result.size.height)
          > FRAME_LINE_HEIGHT (emacsframe)))
    {
      «m:/* »«x:first click */»
      ns_userRect = result;
      maximized_height = result.size.height = defaultFrame.size.height;
      maximized_width = -1;
      result.origin.y = defaultFrame.origin.y;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: FULLSCREEN_HEIGHT«w:]»»;
«p:#ifdef» NS_IMPL_COCOA
      maximizing_resize = «c:YES»;
«p:#endif»
    }
  «k:else» «k:if» (next_maximized == FULLSCREEN_WIDTH)
    {
      ns_userRect = result;
      maximized_width = result.size.width = defaultFrame.size.width;
      maximized_height = -1;
      result.origin.x = defaultFrame.origin.x;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: FULLSCREEN_WIDTH«w:]»»;
    }
  «k:else» «k:if» (next_maximized == FULLSCREEN_MAXIMIZED
           || (next_maximized == -1
               && abs (defaultFrame.size.width - result.size.width)
               > FRAME_COLUMN_WIDTH (emacsframe)))
    {
      result = defaultFrame;  «m:/* »«x:second click */»
      maximized_width = result.size.width;
      maximized_height = result.size.height;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: FULLSCREEN_MAXIMIZED«w:]»»;
«p:#ifdef» NS_IMPL_COCOA
      maximizing_resize = «c:YES»;
«p:#endif»
    }
  «k:else»
    {
      «m:/* »«x:restore */»
      result = ns_userRect.size.height ? ns_userRect : result;
      ns_userRect = NSMakeRect (0, 0, 0, 0);
«p:#ifdef» NS_IMPL_COCOA
      maximizing_resize = fs_state != FULLSCREEN_NONE;
«p:#endif»
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: FULLSCREEN_NONE«w:]»»;
      maximized_width = maximized_height = -1;
    }

  «k:if» (fs_before_fs == -1) next_maximized = -1;
  «:objc-font-lock-background-face:«w:[»«k:self» «f:windowWillResize»: sender «f:toSize»: result.size«w:]»»;
  «k:return» result;
}


- («t:void»)«f:windowDidDeminiaturize»: «v:sender»
{
  NSTRACE (windowDidDeminiaturize);
  «k:if» («n:!»emacsframe->output_data.ns)
    «k:return»;

  SET_FRAME_ICONIFIED (emacsframe, 0);
  SET_FRAME_VISIBLE (emacsframe, 1);
  windows_or_buffers_changed = 63;

  «k:if» (emacs_event)
    {
      emacs_event->kind = DEICONIFY_EVENT;
      EV_TRAILER ((«t:id»)«c:nil»);
    }
}


- («t:void»)«f:windowDidExpose»: «v:sender»
{
  NSTRACE (windowDidExpose);
  «k:if» («n:!»emacsframe->output_data.ns)
    «k:return»;

  SET_FRAME_VISIBLE (emacsframe, 1);
  SET_FRAME_GARBAGED (emacsframe);

  «k:if» (send_appdefined)
    ns_send_appdefined (-1);
}


- («t:void»)«f:windowDidMiniaturize»: «v:sender»
{
  NSTRACE (windowDidMiniaturize);
  «k:if» («n:!»emacsframe->output_data.ns)
    «k:return»;

  SET_FRAME_ICONIFIED (emacsframe, 1);
  SET_FRAME_VISIBLE (emacsframe, 0);

  «k:if» (emacs_event)
    {
      emacs_event->kind = ICONIFY_EVENT;
      EV_TRAILER ((«t:id»)«c:nil»);
    }
}

«p:#ifdef» HAVE_NATIVE_FS
- («t:NSApplicationPresentationOptions»)«f:window»:(«t:NSWindow» *)«v:window»
      «f:willUseFullScreenPresentationOptions»:
  («t:NSApplicationPresentationOptions»)«v:proposedOptions»
{
  «k:return» proposedOptions|NSApplicationPresentationAutoHideToolbar;
}
«p:#endif»

- («t:void»)«f:windowWillEnterFullScreen»:(«t:NSNotification» *)«v:notification»
{
  fs_before_fs = fs_state;
}

- («t:void»)«f:windowDidEnterFullScreen»:(«t:NSNotification» *)«v:notification»
{
  «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: FULLSCREEN_BOTH«w:]»»;
  «k:if» («n:!» «:objc-font-lock-background-face:«w:[»«k:self» «f:fsIsNative»«w:]»»)
    {
      «:objc-font-lock-background-face:«w:[»«k:self» «f:windowDidBecomeKey»:notification«w:]»»;
      «:objc-font-lock-background-face:«w:[»nonfs_window «f:orderOut»:«k:self»«w:]»»;
    }
  «k:else»
    {
      «t:BOOL» «v:tbar_visible» = FRAME_EXTERNAL_TOOL_BAR (emacsframe) ? «c:YES» : «c:NO»;
«p:#ifdef» NS_IMPL_COCOA
«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
      «t:unsigned» «v:val» = («t:unsigned»)«:objc-font-lock-background-face:«w:[»«t:NSApp» «f:presentationOptions»«w:]»»;

      «m:// »«x:OSX 10.7 bug fix, the menu won't appear without this.
»      «m:// »«x:val is non-zero on other OSX versions.
»      «k:if» (val == 0)
        {
          «t:NSApplicationPresentationOptions» «v:options»
            = NSApplicationPresentationAutoHideDock
            | NSApplicationPresentationAutoHideMenuBar
            | NSApplicationPresentationFullScreen
            | NSApplicationPresentationAutoHideToolbar;

          «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setPresentationOptions»: options«w:]»»;
        }
«p:#endif»
«p:#endif»
      «:objc-font-lock-background-face:«w:[»toolbar «f:setVisible»:tbar_visible«w:]»»;
    }
}

- («t:void»)«f:windowWillExitFullScreen»:(«t:NSNotification» *)«v:notification»
{
  «k:if» (next_maximized != -1)
    fs_before_fs = next_maximized;
}

- («t:void»)«f:windowDidExitFullScreen»:(«t:NSNotification» *)«v:notification»
{
  «:objc-font-lock-background-face:«w:[»«k:self» «f:setFSValue»: fs_before_fs«w:]»»;
  fs_before_fs = -1;
«p:#ifdef» HAVE_NATIVE_FS
  «:objc-font-lock-background-face:«w:[»«k:self» «f:updateCollectionBehavior»«w:]»»;
«p:#endif»
  «k:if» (FRAME_EXTERNAL_TOOL_BAR (emacsframe))
    {
      «:objc-font-lock-background-face:«w:[»toolbar «f:setVisible»:«c:YES»«w:]»»;
      update_frame_tool_bar (emacsframe);
      «:objc-font-lock-background-face:«w:[»«k:self» «f:updateFrameSize»:«c:YES»«w:]»»;
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:display»«w:]»»;
    }
  «k:else»
    «:objc-font-lock-background-face:«w:[»toolbar «f:setVisible»:«c:NO»«w:]»»;

  «k:if» (next_maximized != -1)
    «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:performZoom»:«k:self»«w:]»»;
}

- («t:BOOL»)«f:fsIsNative»
{
  «k:return» fs_is_native;
}

- («t:BOOL»)«f:isFullscreen»
{
  «k:if» («n:!» fs_is_native) «k:return» nonfs_window != «c:nil»;
«p:#ifdef» HAVE_NATIVE_FS
  «k:return» («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:styleMask»«w:]»» & NSFullScreenWindowMask) != 0;
«p:#else»
  «k:return» «c:NO»;
«p:#endif»
}

«p:#ifdef» HAVE_NATIVE_FS
- («t:void»)«f:updateCollectionBehavior»
{
  «k:if» («n:!» «:objc-font-lock-background-face:«w:[»«k:self» «f:isFullscreen»«w:]»»)
    {
      «t:NSWindow» *«v:win» = «:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»»;
      «t:NSWindowCollectionBehavior» «v:b» = «:objc-font-lock-background-face:«w:[»win «f:collectionBehavior»«w:]»»;
      «k:if» (ns_use_native_fullscreen)
        b |= NSWindowCollectionBehaviorFullScreenPrimary;
      «k:else»
        b &= ~NSWindowCollectionBehaviorFullScreenPrimary;

      «:objc-font-lock-background-face:«w:[»win «f:setCollectionBehavior»: b«w:]»»;
      fs_is_native = ns_use_native_fullscreen;
    }
}
«p:#endif»

- («t:void»)«f:toggleFullScreen»: («t:id»)«v:sender»
{
  «t:NSWindow» *«v:w», *«v:fw»;
  «t:BOOL» «v:onFirstScreen»;
  «k:struct» «t:frame» *«t:f»;
  «t:NSSize» «v:sz»;
  «t:NSRect» «v:r», «v:wr»;
  «t:NSColor» *«v:col»;

  «k:if» (fs_is_native)
    {
«p:#ifdef» HAVE_NATIVE_FS
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:toggleFullScreen»:sender«w:]»»;
«p:#endif»
      «k:return»;
    }

  w = «:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»»;
  onFirstScreen = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»w «f:screen»«w:]»» «f:isEqual»:«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSScreen» «f:screens»«w:]»» «f:objectAtIndex»:0«w:]»»«w:]»»;
  f = emacsframe;
  wr = «:objc-font-lock-background-face:«w:[»w «f:frame»«w:]»»;
  col = ns_lookup_indexed_color (NS_FACE_BACKGROUND
                                 (FRAME_DEFAULT_FACE (f)),
                                 f);

  sz.width = FRAME_COLUMN_WIDTH (f);
  sz.height = FRAME_LINE_HEIGHT (f);

  «k:if» (fs_state != FULLSCREEN_BOTH)
    {
      «m:/* »«x:Hide dock and menubar if we are on the primary screen.  */»
      «k:if» (onFirstScreen)
        {
«p:#if» «p:defined» (NS_IMPL_COCOA) && \
  MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
          «t:NSApplicationPresentationOptions» «v:options»
            = NSApplicationPresentationAutoHideDock
            | NSApplicationPresentationAutoHideMenuBar;

          «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setPresentationOptions»: options«w:]»»;
«p:#else»
          «:objc-font-lock-background-face:«w:[»«t:NSMenu» «f:setMenuBarVisible»:«c:NO»«w:]»»;
«p:#endif»
        }

      fw = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:EmacsFSWindow» «f:alloc»«w:]»»»
                       «:objc-font-lock-background-face:«f:initWithContentRect»:«:objc-font-lock-background-face:«w:[»w «f:contentRectForFrameRect»:wr«w:]»»»
                                 «:objc-font-lock-background-face:«f:styleMask»:NSBorderlessWindowMask»
                                   «:objc-font-lock-background-face:«f:backing»:NSBackingStoreBuffered»
                                     «:objc-font-lock-background-face:«f:defer»:«c:YES»»
                                    «:objc-font-lock-background-face:«f:screen»:«:objc-font-lock-background-face:«w:[»w «f:screen»«w:]»»«w:]»»;

      «:objc-font-lock-background-face:«w:[»fw «f:setContentView»:«:objc-font-lock-background-face:«w:[»w «f:contentView»«w:]»»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:setTitle»:«:objc-font-lock-background-face:«w:[»w «f:title»«w:]»»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:setDelegate»:«k:self»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:setAcceptsMouseMovedEvents»: «c:YES»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:useOptimizedDrawing»: «c:YES»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:setResizeIncrements»: sz«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:setBackgroundColor»: col«w:]»»;
      «k:if» («:objc-font-lock-background-face:«w:[»col «f:alphaComponent»«w:]»» != («t:EmacsCGFloat») 1.0)
        «:objc-font-lock-background-face:«w:[»fw «f:setOpaque»: «c:NO»«w:]»»;

      f->border_width = 0;
      FRAME_NS_TITLEBAR_HEIGHT (f) = 0;
      tobar_height = FRAME_TOOLBAR_HEIGHT (f);
      FRAME_TOOLBAR_HEIGHT (f) = 0;

      nonfs_window = w;

      «:objc-font-lock-background-face:«w:[»«k:self» «f:windowWillEnterFullScreen»:«c:nil»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:makeKeyAndOrderFront»:NSApp«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:makeFirstResponder»:«k:self»«w:]»»;
      «:objc-font-lock-background-face:«w:[»w «f:orderOut»:«k:self»«w:]»»;
      r = «:objc-font-lock-background-face:«w:[»fw «f:frameRectForContentRect»:«:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»fw «f:screen»«w:]»» «f:frame»«w:]»»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:setFrame»: r «f:display»:«c:YES» «f:animate»:«c:YES»«w:]»»;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:windowDidEnterFullScreen»:«c:nil»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:display»«w:]»»;
    }
  «k:else»
    {
      fw = w;
      w = nonfs_window;
      nonfs_window = «c:nil»;

      «k:if» (onFirstScreen)
        {
«p:#if» «p:defined» (NS_IMPL_COCOA) && \
  MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
          «:objc-font-lock-background-face:«w:[»«t:NSApp» «f:setPresentationOptions»: NSApplicationPresentationDefault«w:]»»;
«p:#else»
          «:objc-font-lock-background-face:«w:[»«t:NSMenu» «f:setMenuBarVisible»:«c:YES»«w:]»»;
«p:#endif»
        }

      «:objc-font-lock-background-face:«w:[»w «f:setContentView»:«:objc-font-lock-background-face:«w:[»fw «f:contentView»«w:]»»«w:]»»;
      «:objc-font-lock-background-face:«w:[»w «f:setResizeIncrements»: sz«w:]»»;
      «:objc-font-lock-background-face:«w:[»w «f:setBackgroundColor»: col«w:]»»;
      «k:if» («:objc-font-lock-background-face:«w:[»col «f:alphaComponent»«w:]»» != («t:EmacsCGFloat») 1.0)
        «:objc-font-lock-background-face:«w:[»w «f:setOpaque»: «c:NO»«w:]»»;

      f->border_width = bwidth;
      FRAME_NS_TITLEBAR_HEIGHT (f) = tibar_height;
      «k:if» (FRAME_EXTERNAL_TOOL_BAR (f))
        FRAME_TOOLBAR_HEIGHT (f) = tobar_height;

      «:objc-font-lock-background-face:«w:[»«k:self» «f:windowWillExitFullScreen»:«c:nil»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:setFrame»: «:objc-font-lock-background-face:«w:[»w «f:frame»«w:]»» «f:display»:«c:YES» «f:animate»:«c:YES»«w:]»»;
      «:objc-font-lock-background-face:«w:[»fw «f:close»«w:]»»;
      «:objc-font-lock-background-face:«w:[»w «f:makeKeyAndOrderFront»:NSApp«w:]»»;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:windowDidExitFullScreen»:«c:nil»«w:]»»;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:updateFrameSize»:«c:YES»«w:]»»;
    }
}

- («t:void»)«f:handleFS»
{
  «k:if» (fs_state != emacsframe->want_fullscreen)
    {
      «k:if» (fs_state == FULLSCREEN_BOTH)
        {
          «:objc-font-lock-background-face:«w:[»«k:self» «f:toggleFullScreen»:«k:self»«w:]»»;
        }

      «k:switch» (emacsframe->want_fullscreen)
        {
        «k:case» FULLSCREEN_BOTH:
          «:objc-font-lock-background-face:«w:[»«k:self» «f:toggleFullScreen»:«k:self»«w:]»»;
          «k:break»;
        «k:case» FULLSCREEN_WIDTH:
          next_maximized = FULLSCREEN_WIDTH;
          «k:if» (fs_state != FULLSCREEN_BOTH)
            «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:performZoom»:«k:self»«w:]»»;
          «k:break»;
        «k:case» FULLSCREEN_HEIGHT:
          next_maximized = FULLSCREEN_HEIGHT;
          «k:if» (fs_state != FULLSCREEN_BOTH)
            «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:performZoom»:«k:self»«w:]»»;
          «k:break»;
        «k:case» FULLSCREEN_MAXIMIZED:
          next_maximized = FULLSCREEN_MAXIMIZED;
          «k:if» (fs_state != FULLSCREEN_BOTH)
            «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:performZoom»:«k:self»«w:]»»;
          «k:break»;
        «k:case» FULLSCREEN_NONE:
          «k:if» (fs_state != FULLSCREEN_BOTH)
            {
              next_maximized = FULLSCREEN_NONE;
              «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:performZoom»:«k:self»«w:]»»;
            }
          «k:break»;
        }

      emacsframe->want_fullscreen = FULLSCREEN_NONE;
    }

}

- («t:void») «f:setFSValue»: («t:int»)«v:value»
{
  «t:Lisp_Object» «v:lval» = Qnil;
  «k:switch» (value)
    {
    «k:case» FULLSCREEN_BOTH:
      lval = Qfullboth;
      «k:break»;
    «k:case» FULLSCREEN_WIDTH:
      lval = Qfullwidth;
      «k:break»;
    «k:case» FULLSCREEN_HEIGHT:
      lval = Qfullheight;
      «k:break»;
    «k:case» FULLSCREEN_MAXIMIZED:
      lval = Qmaximized;
      «k:break»;
    }
  store_frame_param (emacsframe, Qfullscreen, lval);
  fs_state = value;
}

- («t:void»)«f:mouseEntered»: («t:NSEvent» *)«v:theEvent»
{
  NSTRACE (mouseEntered);
  «k:if» (emacsframe)
    FRAME_DISPLAY_INFO (emacsframe)->last_mouse_movement_time
      = EV_TIMESTAMP (theEvent);
}


- («t:void»)«f:mouseExited»: («t:NSEvent» *)«v:theEvent»
{
  «t:Mouse_HLInfo» *«v:hlinfo» = emacsframe ? MOUSE_HL_INFO (emacsframe) : NULL;

  NSTRACE (mouseExited);

  «k:if» («n:!»hlinfo)
    «k:return»;

  FRAME_DISPLAY_INFO (emacsframe)->last_mouse_movement_time
    = EV_TIMESTAMP (theEvent);

  «k:if» (emacsframe == hlinfo->mouse_face_mouse_frame)
    {
      clear_mouse_face (hlinfo);
      hlinfo->mouse_face_mouse_frame = 0;
    }
}


- «f:menuDown»: «v:sender»
{
  NSTRACE (menuDown);
  «k:if» (context_menu_value == -1)
    context_menu_value = «:objc-font-lock-background-face:«w:[»sender «f:tag»«w:]»»;
  «k:else»
    {
      «t:NSInteger» «v:tag» = «:objc-font-lock-background-face:«w:[»sender «f:tag»«w:]»»;
      find_and_call_menu_selection (emacsframe, emacsframe->menu_bar_items_used,
                                    emacsframe->menu_bar_vector,
                                    («t:void» *)tag);
    }

  ns_send_appdefined (-1);
  «k:return» «k:self»;
}


- («t:EmacsToolbar» *)«f:toolbar»
{
  «k:return» toolbar;
}


«m:/* »«x:this gets called on toolbar button click */»
- «f:toolbarClicked»: («t:id»)«v:item»
{
  «t:NSEvent» *«v:theEvent»;
  «t:int» «v:idx» = «:objc-font-lock-background-face:«w:[»item «f:tag»«w:]»» * TOOL_BAR_ITEM_NSLOTS;

  NSTRACE (toolbarClicked);

  «k:if» («n:!»emacs_event)
    «k:return» «k:self»;

  «m:/* »«x:send first event (for some reason two needed) */»
  theEvent = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:currentEvent»«w:]»»;
  emacs_event->kind = TOOL_BAR_EVENT;
  XSETFRAME (emacs_event->arg, emacsframe);
  EV_TRAILER (theEvent);

  emacs_event->kind = TOOL_BAR_EVENT;
«m:/*   »«x:XSETINT (emacs_event->code, 0); */»
  emacs_event->arg = AREF (emacsframe->tool_bar_items,
			   idx + TOOL_BAR_ITEM_KEY);
  emacs_event->modifiers = EV_MODIFIERS (theEvent);
  EV_TRAILER (theEvent);
  «k:return» «k:self»;
}


- «f:toggleToolbar»: («t:id»)«v:sender»
{
  «k:if» («n:!»emacs_event)
    «k:return» «k:self»;

  emacs_event->kind = NS_NONKEY_EVENT;
  emacs_event->code = KEY_NS_TOGGLE_TOOLBAR;
  EV_TRAILER ((«t:id»)«c:nil»);
  «k:return» «k:self»;
}


- («t:void»)«f:drawRect»: («t:NSRect»)«v:rect»
{
  «t:int» «v:x» = NSMinX (rect), «v:y» = NSMinY (rect);
  «t:int» «v:width» = NSWidth (rect), «v:height» = NSHeight (rect);

  NSTRACE (drawRect);

  «k:if» («n:!»emacsframe || «n:!»emacsframe->output_data.ns)
    «k:return»;

  ns_clear_frame_area (emacsframe, x, y, width, height);
  expose_frame (emacsframe, x, y, width, height);

  «m:/*»«x:
    drawRect: may be called (at least in OS X 10.5) for invisible
    views as well for some reason.  Thus, do not infer visibility
    here.

    emacsframe->async_visible = 1;
    emacsframe->async_iconified = 0;
  */»
}


«m:/* »«x:NSDraggingDestination protocol methods.  Actually this is not really a
   protocol, but a category of Object.  O well...  */»

-(«t:NSUInteger») «f:draggingEntered»: («t:id» <«t:NSDraggingInfo»>) «v:sender»
{
  NSTRACE (draggingEntered);
  «k:return» NSDragOperationGeneric;
}


-(«t:BOOL»)«f:prepareForDragOperation»: («t:id» <«t:NSDraggingInfo»>) «v:sender»
{
  «k:return» «c:YES»;
}


-(«t:BOOL»)«f:performDragOperation»: («t:id» <«t:NSDraggingInfo»>) «v:sender»
{
  «t:id» «v:pb»;
  «t:int» «v:x», «v:y»;
  «t:NSString» *«v:type»;
  «t:NSEvent» *«v:theEvent» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:currentEvent»«w:]»»;
  «t:NSPoint» «v:position»;
  «t:NSDragOperation» «v:op» = «:objc-font-lock-background-face:«w:[»sender «f:draggingSourceOperationMask»«w:]»»;
  «t:int» «v:modifiers» = 0;

  NSTRACE (performDragOperation);

  «k:if» («n:!»emacs_event)
    «k:return» «c:NO»;

  position = «:objc-font-lock-background-face:«w:[»«k:self» «f:convertPoint»: «:objc-font-lock-background-face:«w:[»sender «f:draggingLocation»«w:]»» «f:fromView»: «c:nil»«w:]»»;
  x = lrint (position.x);  y = lrint (position.y);

  pb = «:objc-font-lock-background-face:«w:[»sender «f:draggingPasteboard»«w:]»»;
  type = «:objc-font-lock-background-face:«w:[»pb «f:availableTypeFromArray»: ns_drag_types«w:]»»;

  «k:if» («n:!» (op & (NSDragOperationMove|NSDragOperationDelete)) &&
      «m:// »«x:URL drags contain all operations (0xf), don't allow all to be set.
»      (op & 0xf) != 0xf)
    {
      «k:if» (op & NSDragOperationLink)
        modifiers |= NSControlKeyMask;
      «k:if» (op & NSDragOperationCopy)
        modifiers |= NSAlternateKeyMask;
      «k:if» (op & NSDragOperationGeneric)
        modifiers |= NSCommandKeyMask;
    }

  modifiers = EV_MODIFIERS2 (modifiers);
  «k:if» (type == 0)
    {
      «k:return» «c:NO»;
    }
  «k:else» «k:if» («:objc-font-lock-background-face:«w:[»type «f:isEqualToString»: NSFilenamesPboardType«w:]»»)
    {
      «t:NSArray» *«v:files»;
      «t:NSEnumerator» *«v:fenum»;
      «t:NSString» *«v:file»;

      «k:if» («n:!»(files = «:objc-font-lock-background-face:«w:[»pb «f:propertyListForType»: type«w:]»»))
        «k:return» «c:NO»;

      fenum = «:objc-font-lock-background-face:«w:[»files «f:objectEnumerator»«w:]»»;
      «k:while» ( (file = «:objc-font-lock-background-face:«w:[»fenum «f:nextObject»«w:]»») )
        {
          emacs_event->kind = DRAG_N_DROP_EVENT;
          XSETINT (emacs_event->x, x);
          XSETINT (emacs_event->y, y);
          ns_input_file = append2 (ns_input_file,
                                   build_string («:objc-font-lock-background-face:«w:[»file «f:UTF8String»«w:]»»));
          emacs_event->modifiers = modifiers;
          emacs_event->arg =  list2 (Qfile, build_string («:objc-font-lock-background-face:«w:[»file «f:UTF8String»«w:]»»));
          EV_TRAILER (theEvent);
        }
      «k:return» «c:YES»;
    }
  «k:else» «k:if» («:objc-font-lock-background-face:«w:[»type «f:isEqualToString»: NSURLPboardType«w:]»»)
    {
      «t:NSURL» *«v:url» = «:objc-font-lock-background-face:«w:[»NSURL «f:URLFromPasteboard»: pb«w:]»»;
      «k:if» (url == «c:nil») «k:return» «c:NO»;

      emacs_event->kind = DRAG_N_DROP_EVENT;
      XSETINT (emacs_event->x, x);
      XSETINT (emacs_event->y, y);
      emacs_event->modifiers = modifiers;
      emacs_event->arg =  list2 (Qurl,
                                 build_string («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»url «f:absoluteString»«w:]»»»
                                                 «:objc-font-lock-background-face:«f:UTF8String»«w:]»»));
      EV_TRAILER (theEvent);

      «k:if» («:objc-font-lock-background-face:«w:[»url «f:isFileURL»«w:]»» != «c:NO»)
        {
          «t:NSString» *«v:file» = «:objc-font-lock-background-face:«w:[»url «f:path»«w:]»»;
          ns_input_file = append2 (ns_input_file,
                                   build_string («:objc-font-lock-background-face:«w:[»file «f:UTF8String»«w:]»»));
        }
      «k:return» «c:YES»;
    }
  «k:else» «k:if» («:objc-font-lock-background-face:«w:[»type «f:isEqualToString»: NSStringPboardType«w:]»»
           || «:objc-font-lock-background-face:«w:[»type «f:isEqualToString»: NSTabularTextPboardType«w:]»»)
    {
      «t:NSString» *«v:data»;

      «k:if» («n:!» (data = «:objc-font-lock-background-face:«w:[»pb «f:stringForType»: type«w:]»»))
        «k:return» «c:NO»;

      emacs_event->kind = DRAG_N_DROP_EVENT;
      XSETINT (emacs_event->x, x);
      XSETINT (emacs_event->y, y);
      emacs_event->modifiers = modifiers;
      emacs_event->arg =  list2 (Qnil, build_string («:objc-font-lock-background-face:«w:[»data «f:UTF8String»«w:]»»));
      EV_TRAILER (theEvent);
      «k:return» «c:YES»;
    }
  «k:else»
    {
      error («s:"Invalid data type in dragging pasteboard."»);
      «k:return» «c:NO»;
    }
}


- («t:id») «f:validRequestorForSendType»: («t:NSString» *)«v:typeSent»
                      «f:returnType»: («t:NSString» *)«v:typeReturned»
{
  NSTRACE (validRequestorForSendType);
  «k:if» (typeSent != «c:nil» && «:objc-font-lock-background-face:«w:[»ns_send_types «f:indexOfObject»: typeSent«w:]»» != NSNotFound
      && typeReturned == «c:nil»)
    {
      «k:if» («n:!» NILP (ns_get_local_selection (QPRIMARY, QUTF8_STRING)))
        «k:return» «k:self»;
    }

  «k:return» «:objc-font-lock-background-face:«w:[»«k:super» «f:validRequestorForSendType»: typeSent»
                               «:objc-font-lock-background-face:«f:returnType»: typeReturned«w:]»»;
}


«m:/* »«x:The next two methods are part of NSServicesRequests informal protocol,
   supposedly called when a services menu item is chosen from this app.
   But this should not happen because we override the services menu with our
   own entries which call ns-perform-service.
   Nonetheless, it appeared to happen (under strange circumstances): bug#1435.
   So let's at least stub them out until further investigation can be done. */»

- («t:BOOL») «f:readSelectionFromPasteboard»: («t:NSPasteboard» *)«v:pb»
{
  «m:/* »«x:we could call ns_string_from_pasteboard(pboard) here but then it should
     be written into the buffer in place of the existing selection..
     ordinary service calls go through functions defined in ns-win.el */»
  «k:return» «c:NO»;
}

- («t:BOOL») «f:writeSelectionToPasteboard»: («t:NSPasteboard» *)«v:pb» «f:types»: («t:NSArray» *)«v:types»
{
  «t:NSArray» *«v:typesDeclared»;
  «t:Lisp_Object» «v:val»;

  «m:/* »«x:We only support NSStringPboardType */»
  «k:if» («:objc-font-lock-background-face:«w:[»types «f:containsObject»:NSStringPboardType«w:]»» == «c:NO») {
    «k:return» «c:NO»;
  }

  val = ns_get_local_selection (QPRIMARY, QUTF8_STRING);
  «k:if» (CONSP (val) && SYMBOLP (XCAR (val)))
    {
      val = XCDR (val);
      «k:if» (CONSP (val) && NILP (XCDR (val)))
        val = XCAR (val);
    }
  «k:if» («n:!» STRINGP (val))
    «k:return» «c:NO»;

  typesDeclared = «:objc-font-lock-background-face:«w:[»«t:NSArray» «f:arrayWithObject»:NSStringPboardType«w:]»»;
  «:objc-font-lock-background-face:«w:[»pb «f:declareTypes»:typesDeclared «f:owner»:«c:nil»«w:]»»;
  ns_string_to_pasteboard (pb, val);
  «k:return» «c:YES»;
}


«m:/* »«x:setMini =YES means set from internal (gives a finder icon), NO means set nil
   (gives a miniaturized version of the window); currently we use the latter for
   frames whose active buffer doesn't correspond to any file
   (e.g., '*scratch*') */»
- «f:setMiniwindowImage»: («t:BOOL») «v:setMini»
{
  «t:id» «v:image» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:miniwindowImage»«w:]»»;
  NSTRACE (setMiniwindowImage);

  «m:/* »«x:NOTE: under Cocoa miniwindowImage always returns nil, documentation
     about "AppleDockIconEnabled" notwithstanding, however the set message
     below has its effect nonetheless. */»
  «k:if» (image != emacsframe->output_data.ns->miniimage)
    {
      «k:if» (image && «:objc-font-lock-background-face:«w:[»image «f:isKindOfClass»: «:objc-font-lock-background-face:«w:[»«t:EmacsImage» «f:class»«w:]»»«w:]»»)
        «:objc-font-lock-background-face:«w:[»image «f:release»«w:]»»;
      «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:setMiniwindowImage»:»
                       «:objc-font-lock-background-face:setMini ? emacsframe->output_data.ns->miniimage : «c:nil»«w:]»»;
    }

  «k:return» «k:self»;
}


- («t:void») «f:setRows»: («t:int») «v:r» «f:andColumns»: («t:int») «v:c»
{
  rows = r;
  cols = c;
}

«k:@end»  «m:/* »«x:EmacsView */»



«m:/* »«x:==========================================================================

    EmacsWindow implementation

   ========================================================================== */»

«k:@implementation» «t:EmacsWindow»

«p:#ifdef» NS_IMPL_COCOA
- («t:id»)«f:accessibilityAttributeValue»:(«t:NSString» *)«v:attribute»
{
  «t:Lisp_Object» «v:str» = Qnil;
  «k:struct» «t:frame» *«t:f» = SELECTED_FRAME ();
  «k:struct» «t:buffer» *«t:curbuf» = XBUFFER (XWINDOW (f->selected_window)->contents);

  «k:if» («:objc-font-lock-background-face:«w:[»attribute «f:isEqualToString»:NSAccessibilityRoleAttribute«w:]»»)
    «k:return» NSAccessibilityTextFieldRole;

  «k:if» («:objc-font-lock-background-face:«w:[»attribute «f:isEqualToString»:NSAccessibilitySelectedTextAttribute«w:]»»
      && curbuf && «n:!» NILP (BVAR (curbuf, mark_active)))
    {
      str = ns_get_local_selection (QPRIMARY, QUTF8_STRING);
    }
  «k:else» «k:if» (curbuf && «:objc-font-lock-background-face:«w:[»attribute «f:isEqualToString»:NSAccessibilityValueAttribute«w:]»»)
    {
      «k:if» («n:!» NILP (BVAR (curbuf, mark_active)))
          str = ns_get_local_selection (QPRIMARY, QUTF8_STRING);

      «k:if» (NILP (str))
        {
          «t:ptrdiff_t» «v:start_byte» = BUF_BEGV_BYTE (curbuf);
          «t:ptrdiff_t» «v:byte_range» = BUF_ZV_BYTE (curbuf) - «f:start_byte»;
          «t:ptrdiff_t» «v:range» = BUF_ZV (curbuf) - «f:BUF_BEGV» (curbuf);

          «k:if» («n:!» NILP (BVAR (curbuf, enable_multibyte_characters)))
            str = make_uninit_multibyte_string (range, byte_range);
          «k:else»
            str = make_uninit_string (range);
          «m:/* »«x:To check: This returns emacs-utf-8, which is a superset of utf-8.
             Is this a problem?  */»
          memcpy (SDATA (str), BYTE_POS_ADDR (start_byte), byte_range);
        }
    }


  «k:if» («n:!» NILP (str))
    {
      «k:if» (CONSP (str) && SYMBOLP (XCAR (str)))
        {
          str = XCDR (str);
          «k:if» (CONSP (str) && NILP (XCDR (str)))
            str = XCAR (str);
        }
      «k:if» (STRINGP (str))
        {
          «k:const» «t:char» *«v:utfStr» = SSDATA (str);
          «t:NSString» *«v:nsStr» = «:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»: utfStr«w:]»»;
          «k:return» nsStr;
        }
    }

  «k:return» «:objc-font-lock-background-face:«w:[»«k:super» «f:accessibilityAttributeValue»:attribute«w:]»»;
}
«p:#endif» «m:/* »«x:NS_IMPL_COCOA */»

«m:/* »«x:If we have multiple monitors, one above the other, we don't want to
   restrict the height to just one monitor.  So we override this.  */»
- («t:NSRect»)«f:constrainFrameRect»:(«t:NSRect»)«v:frameRect» «f:toScreen»:(«t:NSScreen» *)«v:screen»
{
  «m:/* »«x:When making the frame visible for the first time or if there is just
     one screen, we want to constrain.  Other times not.  */»
  «t:NSUInteger» «v:nr_screens» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSScreen» «f:screens»«w:]»» «f:count»«w:]»»;
  «k:struct» «t:frame» *«t:f» = ((«t:EmacsView» *)«:objc-font-lock-background-face:«w:[»«k:self» «f:delegate»«w:]»»)->emacsframe;
  NSTRACE (constrainFrameRect);
  NSTRACE_RECT («s:"input"», frameRect);

  «k:if» (ns_menu_bar_should_be_hidden ())
    «k:return» frameRect;

  «m:/* »«x:The default implementation does two things 1) ensure that the top
     of the rectangle is below the menu bar (or below the top of the
     screen) and 2) resizes windows larger than the screen. As we
     don't want the latter, a smaller rectangle is used. */»
«p:#define» «v:FAKE_HEIGHT» 64
  «t:float» «v:old_top» = frameRect.origin.y + frameRect.size.height;
  «t:NSRect» «v:r»;
  r.size.height = FAKE_HEIGHT;
  r.size.width = frameRect.size.width;
  r.origin.x = frameRect.origin.x;
  r.origin.y = old_top - FAKE_HEIGHT;

  NSTRACE_RECT («s:"input to super"», r);

  r = «:objc-font-lock-background-face:«w:[»«k:super» «f:constrainFrameRect»:r «f:toScreen»:screen«w:]»»;

  NSTRACE_RECT («s:"output from super"», r);

  «t:float» «v:new_top» = r.origin.y + FAKE_HEIGHT;
  «k:if» (new_top < old_top)
  {
    frameRect.origin.y = new_top - frameRect.size.height;
  }

  NSTRACE_RECT («s:"output"», frameRect);

  «k:return» frameRect;
«p:#undef» FAKE_HEIGHT
}

«k:@end» «m:/* »«x:EmacsWindow */»


«k:@implementation» «t:EmacsFSWindow»

- («t:BOOL»)«f:canBecomeKeyWindow»
{
  «k:return» «c:YES»;
}

- («t:BOOL»)«f:canBecomeMainWindow»
{
  «k:return» «c:YES»;
}

«k:@end»

«m:/* »«x:==========================================================================

    EmacsScroller implementation

   ========================================================================== */»


«k:@implementation» «t:EmacsScroller»

«m:/* »«x:for repeat button push */»
«p:#define» «v:SCROLL_BAR_FIRST_DELAY» 0.5
«p:#define» «v:SCROLL_BAR_CONTINUOUS_DELAY» (1.0 / 15)

+ («t:CGFloat») «f:scrollerWidth»
{
  «m:/* »«x:TODO: if we want to allow variable widths, this is the place to do it,
           however neither GNUstep nor Cocoa support it very well */»
  «k:return» «:objc-font-lock-background-face:«w:[»«t:NSScroller» «f:scrollerWidth»«w:]»»;
}


- «f:initFrame»: («t:NSRect» )«v:r» «f:window»: («t:Lisp_Object»)«v:nwin»
{
  NSTRACE (EmacsScroller_initFrame);

  r.size.width = «:objc-font-lock-background-face:«w:[»«t:EmacsScroller» «f:scrollerWidth»«w:]»»;
  «:objc-font-lock-background-face:«w:[»«k:super» «f:initWithFrame»: r«m:/*»«x:NSMakeRect (0, 0, 0, 0)*/»«w:]»»;
  «:objc-font-lock-background-face:«w:[»«k:self» «f:setContinuous»: «c:YES»«w:]»»;
  «:objc-font-lock-background-face:«w:[»«k:self» «f:setEnabled»: «c:YES»«w:]»»;

  «m:/* »«x:Ensure auto resizing of scrollbars occurs within the emacs frame's view
     locked against the top and bottom edges, and right edge on OS X, where
     scrollers are on right. */»
«p:#ifdef» NS_IMPL_GNUSTEP
  «:objc-font-lock-background-face:«w:[»«k:self» «f:setAutoresizingMask»: NSViewMaxXMargin | NSViewHeightSizable«w:]»»;
«p:#else»
  «:objc-font-lock-background-face:«w:[»«k:self» «f:setAutoresizingMask»: NSViewMinXMargin | NSViewHeightSizable«w:]»»;
«p:#endif»

  win = nwin;
  condemned = «c:NO»;
  pixel_height = NSHeight (r);
  «k:if» (pixel_height == 0) pixel_height = 1;
  min_portion = 20 / pixel_height;

  frame = XFRAME (XWINDOW (win)->frame);
  «k:if» (FRAME_LIVE_P (frame))
    {
      «t:int» «v:i»;
      «t:EmacsView» *«v:view» = FRAME_NS_VIEW (frame);
      «t:NSView» *«v:sview» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»view «f:window»«w:]»» «f:contentView»«w:]»»;
      «t:NSArray» *«v:subs» = «:objc-font-lock-background-face:«w:[»sview «f:subviews»«w:]»»;

      «m:/* »«x:disable optimization stopping redraw of other scrollbars */»
      view->scrollbarsNeedingUpdate = 0;
      «k:for» (i =«:objc-font-lock-background-face:«w:[»subs «f:count»«w:]»»-1; i >= 0; i--)
        «k:if» («:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»subs «f:objectAtIndex»: i«w:]»» «f:isKindOfClass»: «:objc-font-lock-background-face:«w:[»«t:EmacsScroller» «f:class»«w:]»»«w:]»»)
          view->scrollbarsNeedingUpdate++;
      «:objc-font-lock-background-face:«w:[»sview «f:addSubview»: «k:self»«w:]»»;
    }

«m:/*  »«x:[self setFrame: r]; */»

  «k:return» «k:self»;
}


- («t:void»)«f:setFrame»: («t:NSRect»)«v:newRect»
{
  NSTRACE (EmacsScroller_setFrame);
«m:/*  »«x:block_input (); */»
  pixel_height = NSHeight (newRect);
  «k:if» (pixel_height == 0) pixel_height = 1;
  min_portion = 20 / pixel_height;
  «:objc-font-lock-background-face:«w:[»«k:super» «f:setFrame»: newRect«w:]»»;
  «:objc-font-lock-background-face:«w:[»«k:self» «f:display»«w:]»»;
«m:/*  »«x:unblock_input (); */»
}


- («t:void»)«f:dealloc»
{
  NSTRACE (EmacsScroller_dealloc);
  «k:if» («n:!»NILP (win))
    wset_vertical_scroll_bar (XWINDOW (win), Qnil);
  «:objc-font-lock-background-face:«w:[»«k:super» «f:dealloc»«w:]»»;
}


- «f:condemn»
{
  NSTRACE (condemn);
  condemned =«c:YES»;
  «k:return» «k:self»;
}


- «f:reprieve»
{
  NSTRACE (reprieve);
  condemned =«c:NO»;
  «k:return» «k:self»;
}


- «f:judge»
{
  NSTRACE (judge);
  «k:if» (condemned)
    {
      «t:EmacsView» *«v:view»;
      block_input ();
      «m:/* »«x:ensure other scrollbar updates after deletion */»
      view = («t:EmacsView» *)FRAME_NS_VIEW (frame);
      «k:if» (view != «c:nil»)
        view->scrollbarsNeedingUpdate++;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:removeFromSuperview»«w:]»»;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:release»«w:]»»;
      unblock_input ();
    }
  «k:return» «k:self»;
}


- («t:void»)«f:resetCursorRects»
{
  «t:NSRect» «v:visible» = «:objc-font-lock-background-face:«w:[»«k:self» «f:visibleRect»«w:]»»;
  NSTRACE (resetCursorRects);

  «k:if» («n:!»NSIsEmptyRect (visible))
    «:objc-font-lock-background-face:«w:[»«k:self» «f:addCursorRect»: visible «f:cursor»: «:objc-font-lock-background-face:«w:[»«t:NSCursor» «f:arrowCursor»«w:]»»«w:]»»;
  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSCursor» «f:arrowCursor»«w:]»» «f:setOnMouseEntered»: «c:YES»«w:]»»;
}


- («t:int») «f:checkSamePosition»: («t:int») «v:position» «f:portion»: («t:int») «v:portion»
                    «f:whole»: («t:int») «v:whole»
{
  «k:return» em_position ==position && em_portion ==portion && em_whole ==whole
    && portion != whole; «m:/* »«x:needed for resize empty buf */»
}


- «f:setPosition»: («t:int»)«v:position» «f:portion»: («t:int»)«v:portion» «f:whole»: («t:int»)«v:whole»
{
  NSTRACE (setPosition);

  em_position = position;
  em_portion = portion;
  em_whole = whole;

  «k:if» (portion >= whole)
    {
«p:#if» «p:defined» (NS_IMPL_COCOA) && MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_5
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setKnobProportion»: 1.0«w:]»»;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setDoubleValue»: 1.0«w:]»»;
«p:#else»
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setFloatValue»: 0.0 «f:knobProportion»: 1.0«w:]»»;
«p:#endif»
    }
  «k:else»
    {
      «t:float» «v:pos»;
      «t:CGFloat» «v:por»;
      portion = max ((«t:float»)whole*min_portion/pixel_height, portion);
      pos = («t:float»)position / (whole - portion);
      por = («t:CGFloat»)portion/whole;
«p:#if» «p:defined» (NS_IMPL_COCOA) && MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_5
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setKnobProportion»: por«w:]»»;
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setDoubleValue»: pos«w:]»»;
«p:#else»
      «:objc-font-lock-background-face:«w:[»«k:self» «f:setFloatValue»: pos «f:knobProportion»: por«w:]»»;
«p:#endif»
    }

  «m:/* »«x:Events may come here even if the event loop is not running.
     If we don't enter the event loop, the scroll bar will not update.
     So send SIGIO to ourselves.  */»
  «k:if» (apploopnr == 0) raise (SIGIO);

  «k:return» «k:self»;
}

«m:/* »«x:FIXME: unused at moment (see ns_mouse_position) at the moment because
     drag events will go directly to the EmacsScroller.  Leaving in for now. */»
-(«t:void»)«f:getMouseMotionPart»: («t:int» *)«v:part» «f:window»: («t:Lisp_Object» *)«v:window»
                        «f:x»: («t:Lisp_Object» *)«v:x» «f:y»: ( «t:Lisp_Object» *)«v:y»
{
  *part = last_hit_part;
  *window = win;
  XSETINT (*y, pixel_height);
  «k:if» («:objc-font-lock-background-face:«w:[»«k:self» «f:floatValue»«w:]»» > 0.999F)
    XSETINT (*x, pixel_height);
  «k:else»
    XSETINT (*x, «t:pixel_height» * «:objc-font-lock-background-face:«w:[»«k:self» «f:floatValue»«w:]»»);
}


«m:/* »«x:set up emacs_event */»
- («t:void») «f:sendScrollEventAtLoc»: («t:float»)«v:loc» «f:fromEvent»: («t:NSEvent» *)«v:e»
{
  «k:if» («n:!»emacs_event)
    «k:return»;

  emacs_event->part = last_hit_part;
  emacs_event->code = 0;
  emacs_event->modifiers = EV_MODIFIERS (e) | down_modifier;
  emacs_event->frame_or_window = win;
  emacs_event->timestamp = EV_TIMESTAMP (e);
  emacs_event->kind = SCROLL_BAR_CLICK_EVENT;
  emacs_event->arg = Qnil;
  XSETINT (emacs_event->x, loc * pixel_height);
  XSETINT (emacs_event->y, pixel_height-20);

  «k:if» (q_event_ptr)
    {
      n_emacs_events_pending++;
      kbd_buffer_store_event_hold (emacs_event, q_event_ptr);
    }
  «k:else»
    hold_event (emacs_event);
  EVENT_INIT (*emacs_event);
  ns_send_appdefined (-1);
}


«m:/* »«x:called manually thru timer to implement repeated button action w/hold-down */»
- «f:repeatScroll»: («t:NSTimer» *)«v:scrollEntry»
{
  «t:NSEvent» *«v:e» = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:currentEvent»«w:]»»;
  «t:NSPoint» «v:p» =  «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«k:self» «f:window»«w:]»» «f:mouseLocationOutsideOfEventStream»«w:]»»;
  «t:BOOL» «v:inKnob» = «:objc-font-lock-background-face:«w:[»«k:self» «f:testPart»: p«w:]»» == NSScrollerKnob;

  «m:/* »«x:clear timer if need be */»
  «k:if» (inKnob || «:objc-font-lock-background-face:«w:[»scroll_repeat_entry «f:timeInterval»«w:]»» == SCROLL_BAR_FIRST_DELAY)
    {
        «:objc-font-lock-background-face:«w:[»scroll_repeat_entry «f:invalidate»«w:]»»;
        «:objc-font-lock-background-face:«w:[»scroll_repeat_entry «f:release»«w:]»»;
        scroll_repeat_entry = «c:nil»;

        «k:if» (inKnob)
          «k:return» «k:self»;

        scroll_repeat_entry
	  = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSTimer» «f:scheduledTimerWithTimeInterval»:»»
			«:objc-font-lock-background-face:«:objc-font-lock-background-face:SCROLL_BAR_CONTINUOUS_DELAY»»
                                            «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:target»: «k:self»»»
                                          «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:selector»: «k:@selector» (repeatScroll:)»»
                                          «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:userInfo»: 0»»
                                           «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:repeats»: «c:YES»«w:]»»»
	      «:objc-font-lock-background-face:«f:retain»«w:]»»;
    }

  «:objc-font-lock-background-face:«w:[»«k:self» «f:sendScrollEventAtLoc»: 0 «f:fromEvent»: e«w:]»»;
  «k:return» «k:self»;
}


«m:/* »«x:Asynchronous mouse tracking for scroller.  This allows us to dispatch
   mouseDragged events without going into a modal loop. */»
- («t:void»)«f:mouseDown»: («t:NSEvent» *)«v:e»
{
  «t:NSRect» «v:sr», «v:kr»;
  «m:/* »«x:hitPart is only updated AFTER event is passed on */»
  «t:NSScrollerPart» «v:part» = «:objc-font-lock-background-face:«w:[»«k:self» «f:testPart»: «:objc-font-lock-background-face:«w:[»e «f:locationInWindow»«w:]»»«w:]»»;
  «t:CGFloat» «v:inc» = 0.0, «v:loc», «v:kloc», «v:pos»;
  «t:int» «v:edge» = 0;

  NSTRACE (EmacsScroller_mouseDown);

  «k:switch» (part)
    {
    «k:case» NSScrollerDecrementPage:
        last_hit_part = scroll_bar_above_handle; inc = -1.0; «k:break»;
    «k:case» NSScrollerIncrementPage:
        last_hit_part = scroll_bar_below_handle; inc = 1.0; «k:break»;
    «k:case» NSScrollerDecrementLine:
      last_hit_part = scroll_bar_up_arrow; inc = -0.1; «k:break»;
    «k:case» NSScrollerIncrementLine:
      last_hit_part = scroll_bar_down_arrow; inc = 0.1; «k:break»;
    «k:case» NSScrollerKnob:
      last_hit_part = scroll_bar_handle; «k:break»;
    «k:case» NSScrollerKnobSlot:  «m:/* »«x:GNUstep-only */»
      last_hit_part = scroll_bar_move_ratio; «k:break»;
    «k:default»:  «m:/* »«x:NSScrollerNoPart? */»
      fprintf (stderr, «s:"EmacsScoller-mouseDown: unexpected part %ld\n"»,
               («t:long») part);
      «k:return»;
    }

  «k:if» (inc != 0.0)
    {
      pos = 0;      «m:/* »«x:ignored */»

      «m:/* »«x:set a timer to repeat, as we can't let superclass do this modally */»
      scroll_repeat_entry
	= «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSTimer» «f:scheduledTimerWithTimeInterval»: SCROLL_BAR_FIRST_DELAY»»
                                            «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:target»: «k:self»»»
                                          «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:selector»: «k:@selector» (repeatScroll:)»»
                                          «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:userInfo»: 0»»
                                           «:objc-font-lock-background-face:«:objc-font-lock-background-face:«f:repeats»: «c:YES»«w:]»»»
	    «:objc-font-lock-background-face:«f:retain»«w:]»»;
    }
  «k:else»
    {
      «m:/* »«x:handle, or on GNUstep possibly slot */»
      «t:NSEvent» *«v:fake_event»;

      «m:/* »«x:compute float loc in slot and mouse offset on knob */»
      sr = «:objc-font-lock-background-face:«w:[»«k:self» «f:convertRect»: «:objc-font-lock-background-face:«w:[»«k:self» «f:rectForPart»: NSScrollerKnobSlot«w:]»»»
                      «:objc-font-lock-background-face:«f:toView»: «c:nil»«w:]»»;
      loc = NSHeight (sr) - («:objc-font-lock-background-face:«w:[»e «f:locationInWindow»«w:]»».y - NSMinY (sr));
      «k:if» (loc <= 0.0)
        {
          loc = 0.0;
          edge = -1;
        }
      «k:else» «k:if» (loc >= NSHeight (sr))
        {
          loc = NSHeight (sr);
          edge = 1;
        }

      «k:if» (edge)
        kloc = 0.5 * edge;
      «k:else»
        {
          kr = «:objc-font-lock-background-face:«w:[»«k:self» «f:convertRect»: «:objc-font-lock-background-face:«w:[»«k:self» «f:rectForPart»: NSScrollerKnob«w:]»»»
                          «:objc-font-lock-background-face:«f:toView»: «c:nil»«w:]»»;
          kloc = NSHeight (kr) - («:objc-font-lock-background-face:«w:[»e «f:locationInWindow»«w:]»».y - NSMinY (kr));
        }
      last_mouse_offset = kloc;

      «m:/* »«x:if knob, tell emacs a location offset by knob pos
         (to indicate top of handle) */»
      «k:if» (part == NSScrollerKnob)
          pos = (loc - last_mouse_offset) / NSHeight (sr);
      «k:else»
        «m:/* »«x:else this is a slot click on GNUstep: go straight there */»
        pos = loc / NSHeight (sr);

      «m:/* »«x:send a fake mouse-up to super to preempt modal -trackKnob: mode */»
      fake_event = «:objc-font-lock-background-face:«w:[»«t:NSEvent» «f:mouseEventWithType»: NSLeftMouseUp»
                                      «:objc-font-lock-background-face:«f:location»: «:objc-font-lock-background-face:«w:[»e «f:locationInWindow»«w:]»»»
                                 «:objc-font-lock-background-face:«f:modifierFlags»: «:objc-font-lock-background-face:«w:[»e «f:modifierFlags»«w:]»»»
                                     «:objc-font-lock-background-face:«f:timestamp»: «:objc-font-lock-background-face:«w:[»e «f:timestamp»«w:]»»»
                                  «:objc-font-lock-background-face:«f:windowNumber»: «:objc-font-lock-background-face:«w:[»e «f:windowNumber»«w:]»»»
                                       «:objc-font-lock-background-face:«f:context»: «:objc-font-lock-background-face:«w:[»e «f:context»«w:]»»»
                                   «:objc-font-lock-background-face:«f:eventNumber»: «:objc-font-lock-background-face:«w:[»e «f:eventNumber»«w:]»»»
                                    «:objc-font-lock-background-face:«f:clickCount»: «:objc-font-lock-background-face:«w:[»e «f:clickCount»«w:]»»»
                                      «:objc-font-lock-background-face:«f:pressure»: «:objc-font-lock-background-face:«w:[»e «f:pressure»«w:]»»«w:]»»;
      «:objc-font-lock-background-face:«w:[»«k:super» «f:mouseUp»: fake_event«w:]»»;
    }

  «k:if» (part != NSScrollerKnob)
    «:objc-font-lock-background-face:«w:[»«k:self» «f:sendScrollEventAtLoc»: pos «f:fromEvent»: e«w:]»»;
}


«m:/* »«x:Called as we manually track scroller drags, rather than superclass. */»
- («t:void»)«f:mouseDragged»: («t:NSEvent» *)«v:e»
{
    «t:NSRect» «v:sr»;
    «t:double» «v:loc», «v:pos»;

    NSTRACE (EmacsScroller_mouseDragged);

      sr = «:objc-font-lock-background-face:«w:[»«k:self» «f:convertRect»: «:objc-font-lock-background-face:«w:[»«k:self» «f:rectForPart»: NSScrollerKnobSlot«w:]»»»
                      «:objc-font-lock-background-face:«f:toView»: «c:nil»«w:]»»;
      loc = NSHeight (sr) - («:objc-font-lock-background-face:«w:[»e «f:locationInWindow»«w:]»».y - NSMinY (sr));

      «k:if» (loc <= 0.0)
        {
          loc = 0.0;
        }
      «k:else» «k:if» (loc >= NSHeight (sr) + «f:last_mouse_offset»)
        {
          loc = NSHeight (sr) + «f:last_mouse_offset»;
        }

      pos = (loc - last_mouse_offset) / NSHeight (sr);
      «:objc-font-lock-background-face:«w:[»«k:self» «f:sendScrollEventAtLoc»: pos «f:fromEvent»: e«w:]»»;
}


- («t:void»)«f:mouseUp»: («t:NSEvent» *)«v:e»
{
  «k:if» (scroll_repeat_entry)
    {
      «:objc-font-lock-background-face:«w:[»scroll_repeat_entry «f:invalidate»«w:]»»;
      «:objc-font-lock-background-face:«w:[»scroll_repeat_entry «f:release»«w:]»»;
      scroll_repeat_entry = «c:nil»;
    }
  last_hit_part = 0;
}


«m:/* »«x:treat scrollwheel events in the bar as though they were in the main window */»
- («t:void») «f:scrollWheel»: («t:NSEvent» *)«v:theEvent»
{
  «t:EmacsView» *«v:view» = («t:EmacsView» *)FRAME_NS_VIEW (frame);
  «:objc-font-lock-background-face:«w:[»view «f:mouseDown»: theEvent«w:]»»;
}

«k:@end»  «m:/* »«x:EmacsScroller */»


«p:#ifdef» NS_IMPL_GNUSTEP
«m:/* »«x:Dummy class to get rid of startup warnings.  */»
«k:@implementation» «t:EmacsDocument»

«k:@end»
«p:#endif»


«m:/* »«x:==========================================================================

   Font-related functions; these used to be in nsfaces.m

   ========================================================================== */»


«t:Lisp_Object»
«f:x_new_font» («k:struct» «t:frame» *«t:f», «t:Lisp_Object» «v:font_object», «t:int» «v:fontset»)
{
  «k:struct» «t:font» *«t:font» = XFONT_OBJECT (font_object);
  «t:EmacsView» *«v:view» = FRAME_NS_VIEW (f);

  «k:if» (fontset < 0)
    fontset = fontset_from_font (font_object);
  FRAME_FONTSET (f) = fontset;

  «k:if» (FRAME_FONT (f) == font)
    «m:/* »«x:This font is already set in frame F.  There's nothing more to
       do.  */»
    «k:return» font_object;

  FRAME_FONT (f) = font;

  FRAME_BASELINE_OFFSET (f) = font->baseline_offset;
  FRAME_COLUMN_WIDTH (f) = font->average_width;
  FRAME_LINE_HEIGHT (f) = font->height;

  compute_fringe_widths (f, 1);

  «m:/* »«x:Compute the scroll bar width in character columns.  */»
  «k:if» (FRAME_CONFIG_SCROLL_BAR_WIDTH (f) > 0)
    {
      «t:int» «v:wid» = FRAME_COLUMN_WIDTH (f);
      FRAME_CONFIG_SCROLL_BAR_COLS (f)
	= (FRAME_CONFIG_SCROLL_BAR_WIDTH (f) + «f:wid» - 1) / wid;
    }
  «k:else»
    {
      «t:int» «v:wid» = FRAME_COLUMN_WIDTH (f);
      FRAME_CONFIG_SCROLL_BAR_COLS (f) = (14 + wid - 1) / wid;
    }

  «m:/* »«x:Now make the frame display the given font.  */»
  «k:if» (FRAME_NS_WINDOW (f) != 0 && «n:!» «:objc-font-lock-background-face:«w:[»view «f:isFullscreen»«w:]»»)
    x_set_window_size (f, 0, FRAME_COLS (f) * FRAME_COLUMN_WIDTH (f),
                       FRAME_LINES (f) * FRAME_LINE_HEIGHT (f), 1);

  «k:return» font_object;
}


«m:/* »«x:XLFD: -foundry-family-weight-slant-swidth-adstyle-pxlsz-ptSz-resx-resy-spc-avgWidth-rgstry-encoding */»
«m:/* »«x:Note: ns_font_to_xlfd and ns_fontname_to_xlfd no longer needed, removed
         in 1.43. */»

«k:const» «t:char» *
«f:ns_xlfd_to_fontname» («k:const» «t:char» *«v:xlfd»)
«m:/* »«x:--------------------------------------------------------------------------
    Convert an X font name (XLFD) to an NS font name.
    Only family is used.
    The string returned is temporarily allocated.
   -------------------------------------------------------------------------- */»
{
  «t:char» *«v:name» = xmalloc (180);
  «t:int» «v:i», «v:len»;
  «k:const» «t:char» *«v:ret»;

  «k:if» («n:!»strncmp (xlfd, «s:"--"», 2))
    sscanf (xlfd, «s:"--%*[^-]-%[^-]179-"», name);
  «k:else»
    sscanf (xlfd, «s:"-%*[^-]-%[^-]179-"», name);

  «m:/* »«x:stopgap for malformed XLFD input */»
  «k:if» (strlen (name) == 0)
    strcpy (name, «s:"Monaco"»);

  «m:/* »«x:undo hack in ns_fontname_to_xlfd, converting '$' to '-', '_' to ' '
     also uppercase after '-' or ' ' */»
  name[0] = c_toupper (name[0]);
  «k:for» (len =strlen (name), i =0; i<len; i++)
    {
      «k:if» (name[i] == «s:'$'»)
        {
          name[i] = «s:'-'»;
          «k:if» (i+1<len)
            name[i+1] = c_toupper (name[i+1]);
        }
      «k:else» «k:if» (name[i] == «s:'_'»)
        {
          name[i] = «s:' '»;
          «k:if» (i+1<len)
            name[i+1] = c_toupper (name[i+1]);
        }
    }
«m:/*»«x:fprintf (stderr, "converted '%s' to '%s'\n",xlfd,name);  */»
  ret = «:objc-font-lock-background-face:«w:[»«:objc-font-lock-background-face:«w:[»«t:NSString» «f:stringWithUTF8String»: name«w:]»» «f:UTF8String»«w:]»»;
  xfree (name);
  «k:return» ret;
}


«t:void»
«f:syms_of_nsterm» («t:void»)
{
  NSTRACE (syms_of_nsterm);

  ns_antialias_threshold = 10.0;

  «m:/* »«x:from 23+ we need to tell emacs what modifiers there are.. */»
  DEFSYM (Qmodifier_value, «s:"modifier-value"»);
  DEFSYM (Qalt, «s:"alt"»);
  DEFSYM (Qhyper, «s:"hyper"»);
  DEFSYM (Qmeta, «s:"meta"»);
  DEFSYM (Qsuper, «s:"super"»);
  DEFSYM (Qcontrol, «s:"control"»);
  DEFSYM (QUTF8_STRING, «s:"UTF8_STRING"»);

  DEFSYM (Qfile, «s:"file"»);
  DEFSYM (Qurl, «s:"url"»);

  Fput («v:Qalt», Qmodifier_value, make_number (alt_modifier));
  Fput («v:Qhyper», Qmodifier_value, make_number (hyper_modifier));
  Fput («v:Qmeta», Qmodifier_value, make_number (meta_modifier));
  Fput («v:Qsuper», Qmodifier_value, make_number (super_modifier));
  Fput («v:Qcontrol», Qmodifier_value, make_number (ctrl_modifier));

  DEFVAR_LISP («s:"ns-input-file"», ns_input_file,
              «s:"The file specified in the last NS event."»);
  ns_input_file =Qnil;

  DEFVAR_LISP («s:"ns-working-text"», ns_working_text,
              «s:"String for visualizing working composition sequence."»);
  ns_working_text =Qnil;

  DEFVAR_LISP («s:"ns-input-font"», ns_input_font,
              «s:"The font specified in the last NS event."»);
  ns_input_font =Qnil;

  DEFVAR_LISP («s:"ns-input-fontsize"», ns_input_fontsize,
              «s:"The fontsize specified in the last NS event."»);
  ns_input_fontsize =Qnil;

  DEFVAR_LISP («s:"ns-input-line"», ns_input_line,
               «s:"The line specified in the last NS event."»);
  ns_input_line =Qnil;

  DEFVAR_LISP («s:"ns-input-spi-name"», ns_input_spi_name,
               «s:"The service name specified in the last NS event."»);
  ns_input_spi_name =Qnil;

  DEFVAR_LISP («s:"ns-input-spi-arg"», ns_input_spi_arg,
               «s:"The service argument specified in the last NS event."»);
  ns_input_spi_arg =Qnil;

  DEFVAR_LISP («s:"ns-alternate-modifier"», ns_alternate_modifier,
               «s:"This variable describes the behavior of the alternate or option key.\n\
Set to control, meta, alt, super, or hyper means it is taken to be that key.\n\
Set to none means that the alternate / option key is not interpreted by Emacs\n\
at all, allowing it to be used at a lower level for accented character entry."»);
  ns_alternate_modifier = Qmeta;

  DEFVAR_LISP («s:"ns-right-alternate-modifier"», ns_right_alternate_modifier,
               «s:"This variable describes the behavior of the right alternate or option key.\n\
Set to control, meta, alt, super, or hyper means it is taken to be that key.\n\
Set to left means be the same key as `ns-alternate-modifier'.\n\
Set to none means that the alternate / option key is not interpreted by Emacs\n\
at all, allowing it to be used at a lower level for accented character entry."»);
  ns_right_alternate_modifier = Qleft;

  DEFVAR_LISP («s:"ns-command-modifier"», ns_command_modifier,
               «s:"This variable describes the behavior of the command key.\n\
Set to control, meta, alt, super, or hyper means it is taken to be that key."»);
  ns_command_modifier = Qsuper;

  DEFVAR_LISP («s:"ns-right-command-modifier"», ns_right_command_modifier,
               «s:"This variable describes the behavior of the right command key.\n\
Set to control, meta, alt, super, or hyper means it is taken to be that key.\n\
Set to left means be the same key as `ns-command-modifier'.\n\
Set to none means that the command / option key is not interpreted by Emacs\n\
at all, allowing it to be used at a lower level for accented character entry."»);
  ns_right_command_modifier = Qleft;

  DEFVAR_LISP («s:"ns-control-modifier"», ns_control_modifier,
               «s:"This variable describes the behavior of the control key.\n\
Set to control, meta, alt, super, or hyper means it is taken to be that key."»);
  ns_control_modifier = Qcontrol;

  DEFVAR_LISP («s:"ns-right-control-modifier"», ns_right_control_modifier,
               «s:"This variable describes the behavior of the right control key.\n\
Set to control, meta, alt, super, or hyper means it is taken to be that key.\n\
Set to left means be the same key as `ns-control-modifier'.\n\
Set to none means that the control / option key is not interpreted by Emacs\n\
at all, allowing it to be used at a lower level for accented character entry."»);
  ns_right_control_modifier = Qleft;

  DEFVAR_LISP («s:"ns-function-modifier"», ns_function_modifier,
               «s:"This variable describes the behavior of the function key (on laptops).\n\
Set to control, meta, alt, super, or hyper means it is taken to be that key.\n\
Set to none means that the function key is not interpreted by Emacs at all,\n\
allowing it to be used at a lower level for accented character entry."»);
  ns_function_modifier = Qnone;

  DEFVAR_LISP («s:"ns-antialias-text"», ns_antialias_text,
               «s:"Non-nil (the default) means to render text antialiased."»);
  ns_antialias_text = Qt;

  DEFVAR_LISP («s:"ns-confirm-quit"», ns_confirm_quit,
               «s:"Whether to confirm application quit using dialog."»);
  ns_confirm_quit = Qnil;

  DEFVAR_LISP («s:"ns-auto-hide-menu-bar"», ns_auto_hide_menu_bar,
               doc: «m:/* »«x:Non-nil means that the menu bar is hidden, but appears when the mouse is near.
Only works on OSX 10.6 or later.  */»);
  ns_auto_hide_menu_bar = Qnil;

  DEFVAR_BOOL («s:"ns-use-native-fullscreen"», ns_use_native_fullscreen,
     doc: «m:/*»«x:Non-nil means to use native fullscreen on OSX >= 10.7.
Nil means use fullscreen the old (< 10.7) way.  The old way works better with
multiple monitors, but lacks tool bar.  This variable is ignored on OSX < 10.7.
Default is t for OSX >= 10.7, nil otherwise. */»);
«p:#ifdef» HAVE_NATIVE_FS
  ns_use_native_fullscreen = «c:YES»;
«p:#else»
  ns_use_native_fullscreen = «c:NO»;
«p:#endif»
  ns_last_use_native_fullscreen = ns_use_native_fullscreen;

  DEFVAR_BOOL («s:"ns-use-srgb-colorspace"», ns_use_srgb_colorspace,
     doc: «m:/*»«x:Non-nil means to use sRGB colorspace on OSX >= 10.7.
Note that this does not apply to images.
This variable is ignored on OSX < 10.7 and GNUStep.  Default is t. */»);
  ns_use_srgb_colorspace = «c:YES»;

  «m:/* »«x:TODO: move to common code */»
  DEFVAR_LISP («s:"x-toolkit-scroll-bars"», Vx_toolkit_scroll_bars,
	       doc: «m:/* »«x:Which toolkit scroll bars Emacs uses, if any.
A value of nil means Emacs doesn't use toolkit scroll bars.
With the X Window system, the value is a symbol describing the
X toolkit.  Possible values are: gtk, motif, xaw, or xaw3d.
With MS Windows or Nextstep, the value is t.  */»);
  Vx_toolkit_scroll_bars = Qt;

  DEFVAR_BOOL («s:"x-use-underline-position-properties"»,
	       x_use_underline_position_properties,
     doc: «m:/*»«x:Non-nil means make use of UNDERLINE_POSITION font properties.
A value of nil means ignore them.  If you encounter fonts with bogus
UNDERLINE_POSITION font properties, for example 7x13 on XFree prior
to 4.1, set this to nil. */»);
  x_use_underline_position_properties = 0;

  DEFVAR_BOOL («s:"x-underline-at-descent-line"»,
	       x_underline_at_descent_line,
     doc: «m:/* »«x:Non-nil means to draw the underline at the same place as the descent line.
A value of nil means to draw the underline according to the value of the
variable `x-use-underline-position-properties', which is usually at the
baseline level.  The default value is nil.  */»);
  x_underline_at_descent_line = 0;

  «m:/* »«x:Tell Emacs about this window system.  */»
  Fprovide («v:Qns», Qnil);

  DEFSYM (Qcocoa, «s:"cocoa"»);
  DEFSYM (Qgnustep, «s:"gnustep"»);

  syms_of_nsfont ();
«p:#ifdef» NS_IMPL_COCOA
  Fprovide («v:Qcocoa», Qnil);
«p:#if» MAC_OS_X_VERSION_MAX_ALLOWED >= 1050
  syms_of_macfont ();
«p:#endif»
«p:#else»
  Fprovide (Qgnustep, Qnil);
«p:#endif»

}
